diff --git a/Android.mk b/Android.mk
index 5379c57..d5785be 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,5 @@
 ################################################################################
-# Android optee-client and optee-supplicant makefile                                                #
+# Android optee-client, libsks and tee-supplicant makefile                     #
 ################################################################################
 LOCAL_PATH := $(call my-dir)
 
@@ -32,7 +32,7 @@ endif
 LOCAL_CFLAGS += -DDEBUGLEVEL_$(CFG_TEE_CLIENT_LOG_LEVEL)
 LOCAL_CFLAGS += -DBINARY_PREFIX=\"TEEC\"
 
-LOCAL_SRC_FILES := libteec/src/tee_client_api.c\
+LOCAL_SRC_FILES := libteec/src/tee_client_api.c \
                    libteec/src/teec_trace.c
 ifeq ($(CFG_TEE_BENCHMARK),y)
 LOCAL_CFLAGS += -DCFG_TEE_BENCHMARK
@@ -40,7 +40,7 @@ LOCAL_SRC_FILES += teec_benchmark.c
 endif
 
 LOCAL_C_INCLUDES := $(LOCAL_PATH)/public \
-                    $(LOCAL_PATH)/libteec/include \
+                    $(LOCAL_PATH)/libteec/include
 
 LOCAL_PRELINK_MODULE := false
 LOCAL_MODULE := libteec
@@ -52,5 +52,31 @@ LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/public
 
 include $(BUILD_SHARED_LIBRARY)
 
+# Build libsks.so
+include $(CLEAR_VARS)
+
+LOCAL_CFLAGS += $(optee_CFLAGS)
+
+LOCAL_SRC_FILES := libsks/src/pkcs11_api.c \
+                   libsks/src/ck_debug.c \
+                   libsks/src/ck_helpers.c \
+                   libsks/src/invoke_ta.c \
+                   libsks/src/pkcs11_token.c \
+                   libsks/src/serializer.c \
+                   libsks/src/serialize_ck.c \
+                   libsks/src/pkcs11_processing.c
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/public \
+                    $(LOCAL_PATH)/libsks/include
+
+LOCAL_SHARED_LIBRARIES := libteec
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE := libsks
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/libsks/include
+
+include $(BUILD_SHARED_LIBRARY)
+
 # TEE Supplicant
 include $(LOCAL_PATH)/tee-supplicant/tee_supplicant_android.mk
diff --git a/CMakeLists.txt b/CMakeLists.txt
index bc6b57b..323f3d2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -36,3 +36,4 @@ endif(CCACHE_FOUND)
 add_subdirectory (libteec)
 add_subdirectory (tee-supplicant)
 add_subdirectory (public)
+add_subdirectory (libsks)
diff --git a/Makefile b/Makefile
index 7aed849..d7a37a7 100644
--- a/Makefile
+++ b/Makefile
@@ -18,7 +18,7 @@ INCLUDEDIR ?= /usr/include
 
 CFG_TA_GPROF_SUPPORT ?= n
 
-.PHONY: all build build-libteec install copy_export \
+.PHONY: all build build-libteec build-libsks install copy_export \
 	clean cscope clean-cscope \
 	checkpatch-pre-req checkpatch-modified-patch checkpatch-modified-file \
 	checkpatch-last-commit-patch checkpatch-last-commit-file \
@@ -37,11 +37,15 @@ build-tee-supplicant: build-libteec
 	@echo "Building tee-supplicant"
 	$(MAKE) --directory=tee-supplicant  --no-print-directory --no-builtin-variables CFG_TEE_SUPP_LOG_LEVEL=$(CFG_TEE_SUPP_LOG_LEVEL)
 
-build: build-libteec build-tee-supplicant
+build: build-libteec build-tee-supplicant build-libsks
+
+build-libsks: build-libteec
+	@echo "Building libsks.so"
+	@$(MAKE) --directory=libsks --no-print-directory --no-builtin-variables
 
 install: copy_export
 
-clean: clean-libteec clean-tee-supplicant clean-cscope
+clean: clean-libteec clean-tee-supplicant clean-cscope clean-libsks
 
 clean-libteec:
 	@$(MAKE) --directory=libteec --no-print-directory clean
@@ -49,6 +53,10 @@ clean-libteec:
 clean-tee-supplicant:
 	@$(MAKE) --directory=tee-supplicant --no-print-directory clean
 
+clean-libsks:
+	@$(MAKE) --directory=libsks --no-print-directory clean
+
+
 cscope:
 	@echo "  CSCOPE"
 	${VPREFIX}find ${CURDIR} -name "*.[chsS]" > cscope.files
@@ -129,3 +137,6 @@ copy_export: build
 	cp -a ${O}/libteec/libteec.a $(DESTDIR)$(LIBDIR)
 	cp ${O}/tee-supplicant/tee-supplicant $(DESTDIR)$(SBINDIR)
 	cp public/*.h $(DESTDIR)$(INCLUDEDIR)
+	cp libsks/include/*.h $(DESTDIR)$(INCLUDEDIR)
+	cp -a ${O}/libsks/libsks.so* $(DESTDIR)$(LIBDIR)
+	cp -a ${O}/libsks/libsks.a $(DESTDIR)$(LIBDIR)
diff --git a/config.mk b/config.mk
index dc1acbe..f51065a 100644
--- a/config.mk
+++ b/config.mk
@@ -50,6 +50,18 @@ CFG_TA_TEST_PATH ?= y
 # Enable Global Platform Sockets support
 CFG_GP_SOCKETS ?= y
 
+# CFG_SKS_CMD_AS_PARAM
+# Provide SKS command identifier as TEEC parameter
+CFG_SKS_CMD_AS_PARAM ?= 0
+
+# CFG_SKS_CMD_IDENTIFIER
+# TEEC command id used as generic SKS CMD identifier
+CFG_SKS_CMD_IDENTIFIER ?= 0
+
+# CFG_SKS_TA_UUID
+# Default SKS TA UUID
+CFG_SKS_TA_UUID ?= "fd02c9da-306c-48c7-a49c-bbd827ae86ee"
+
 # Default output directory.
 # May be absolute, or relative to the optee_client source directory.
 O               ?= out
diff --git a/libsks/CMakeLists.txt b/libsks/CMakeLists.txt
new file mode 100644
index 0000000..40ce003
--- /dev/null
+++ b/libsks/CMakeLists.txt
@@ -0,0 +1,76 @@
+project(sks C)
+
+set(PROJECT_VERSION "1.0.0")
+
+################################################################################
+# Packages
+################################################################################
+find_package(Threads REQUIRED)
+if(NOT THREADS_FOUND)
+	message(FATAL_ERROR "Threads not found")
+endif()
+
+include(GNUInstallDirs)
+
+################################################################################
+# Source files
+################################################################################
+set (SRC
+	src/pkcs11_api.c
+	src/ck_debug.c
+	src/ck_helpers.c
+	src/invoke_ta.c
+	src/pkcs11_token.c
+	src/serializer.c
+	src/serialize_ck.c
+	src/pkcs11_processing.c
+)
+
+################################################################################
+# Built library
+################################################################################
+add_library (sks SHARED ${SRC})
+
+set_target_properties (sks PROPERTIES
+	VERSION ${PROJECT_VERSION}
+	SOVERSION ${PROJECT_NAME}
+)
+
+################################################################################
+# Flags always set
+################################################################################
+target_compile_definitions (sks
+	PRIVATE -D_GNU_SOURCE
+	PRIVATE -DBINARY_PREFIX="LT"
+)
+
+################################################################################
+# Optional flags
+################################################################################
+
+################################################################################
+# Public and private header and library dependencies
+################################################################################
+target_include_directories(sks
+	PUBLIC include
+	PRIVATE src
+)
+
+target_include_directories(teec
+	PUBLIC include
+)
+
+target_link_libraries (sks
+	PRIVATE pthread
+	PRIVATE teec
+	PRIVATE m
+)
+
+################################################################################
+# Install targets
+################################################################################
+install (TARGETS sks
+	DESTINATION ${CMAKE_INSTALL_LIBDIR}
+)
+
+add_subdirectory(include)
diff --git a/libsks/Makefile b/libsks/Makefile
new file mode 100644
index 0000000..829842b
--- /dev/null
+++ b/libsks/Makefile
@@ -0,0 +1,83 @@
+include ../flags.mk
+include ../config.mk
+
+OUT_DIR := $(OO)/libsks
+
+.PHONY: all libsks clean
+
+all: libsks
+install: libsks
+
+LIB_NAME	:= libsks
+MAJOR_VERSION	:= 0
+MINOR_VERSION	:= 0
+
+LIB_MAJOR		:= $(LIB_NAME).so.$(MAJOR_VERSION)
+LIB_MAJ_MIN		:= $(LIB_NAME).so.$(MAJOR_VERSION).$(MINOR_VERSION)
+LIBSKS_SO_LIBRARY	:= $(LIB_MAJ_MIN)
+LIBSKS_AR_LIBRARY	:= $(LIB_NAME).a
+
+LIBSKS_SRC_DIR		:= src
+
+LIBSKS_SRCS		= pkcs11_api.c
+LIBSKS_SRCS		+= ck_debug.c
+LIBSKS_SRCS 		+= ck_helpers.c
+LIBSKS_SRCS 		+= invoke_ta.c
+LIBSKS_SRCS 		+= pkcs11_token.c
+LIBSKS_SRCS		+= serializer.c
+LIBSKS_SRCS		+= serialize_ck.c
+LIBSKS_SRCS		+= pkcs11_processing.c
+
+LIBSKS_INCLUDES		= ${CURDIR}/include
+LIBSKS_INCLUDES 	+= ${CURDIR}/../public
+
+LIBSKS_CFLAGS		:= $(addprefix -I, $(LIBSKS_INCLUDES)) \
+				$(CFLAGS) -D_GNU_SOURCE -fPIC
+
+ifeq ($(CFG_SKS_CMD_AS_PARAM),1)
+LIBSKS_CFLAGS += -DCFG_SKS_CMD_AS_PARAM=1
+LIBSKS_CFLAGS += -DTEE_SKS_CMD_IDENTIFIER=$(CFG_SKS_CMD_IDENTIFIER)
+endif
+
+ifneq ($(CFG_SKS_TA_UUID),)
+LIBSKS_CFLAGS += -DTA_SKS_UUID=\"$(CFG_SKS_TA_UUID)\"
+endif
+
+LIBSKS_LFLAGS		:= $(LDFLAGS) -L$(OUT_DIR)/../libteec -lteec
+
+LIBSKS_OBJ_DIR		:= $(OUT_DIR)
+LIBSKS_OBJS		:= $(patsubst %.c,$(LIBSKS_OBJ_DIR)/%.o, $(LIBSKS_SRCS))
+
+$(LIBSKS_OBJ_DIR)/%.o: ${LIBSKS_SRC_DIR}/%.c
+	$(VPREFIX)mkdir -p $(LIBSKS_OBJ_DIR)
+	@echo "  CC      $<"
+	$(VPREFIX)$(CC) $(LIBSKS_CFLAGS) -c $< -o $@
+
+libsks: $(OUT_DIR)/$(LIBSKS_SO_LIBRARY)
+
+$(OUT_DIR)/$(LIBSKS_SO_LIBRARY): $(LIBSKS_OBJS)
+	@echo "  LINK    $@"
+	$(VPREFIX)$(CC) -shared -Wl,-soname,$(LIBSKS_SO_LIBRARY) -o $@ $+ $(LIBSKS_LFLAGS)
+	@echo ""
+
+libsks: $(OUT_DIR)/$(LIBSKS_AR_LIBRARY)
+
+$(OUT_DIR)/$(LIBSKS_AR_LIBRARY): $(LIBSKS_OBJS)
+	@echo "  AR      $@"
+	$(VPREFIX)$(AR) rcs $@ $+
+
+libsks:
+	$(VPREFIX)ln -sf $(LIB_MAJ_MIN) $(OUT_DIR)/$(LIB_MAJOR)
+	$(VPREFIX)ln -sf $(LIB_MAJOR) $(OUT_DIR)/$(LIB_NAME).so
+
+################################################################################
+# Cleaning up configuration
+################################################################################
+clean:
+	$(RM) $(LIBSKS_OBJS)
+	$(RM) $(OUT_DIR)/$(LIB_MAJ_MIN)
+	$(RM) $(OUT_DIR)/$(LIB_MAJOR)
+	$(RM) $(OUT_DIR)/$(LIBSKS_SO_LIBRARY)
+	$(RM) $(OUT_DIR)/$(LIBSKS_AR_LIBRARY)
+	$(call rmdir,$(OUT_DIR))
+
diff --git a/libsks/include/CMakeLists.txt b/libsks/include/CMakeLists.txt
new file mode 100644
index 0000000..24344ec
--- /dev/null
+++ b/libsks/include/CMakeLists.txt
@@ -0,0 +1,7 @@
+project (optee-cryptoki-headers C)
+
+FILE(GLOB INSTALL_HEADERS "*.h")
+
+add_library(${PROJECT_NAME} INTERFACE)
+
+install (FILES ${INSTALL_HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
diff --git a/libsks/include/pkcs11.h b/libsks/include/pkcs11.h
new file mode 100644
index 0000000..e230b94
--- /dev/null
+++ b/libsks/include/pkcs11.h
@@ -0,0 +1,1502 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2018, Linaro Limited
+ */
+
+#ifndef __PKCS11_H__
+#define __PKCS11_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * PKCS#11 Cryptoki API v2.40-errata01, See specification from:
+ * http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/errata01/os/pkcs11-base-v2.40-errata01-os-complete.html
+ */
+
+typedef unsigned char		CK_BYTE;
+typedef unsigned long int	CK_ULONG;
+typedef long int		CK_LONG;
+
+typedef CK_BYTE			CK_CHAR;
+typedef CK_BYTE			CK_UTF8CHAR;
+
+typedef CK_BYTE *		CK_BYTE_PTR;
+typedef CK_ULONG *		CK_ULONG_PTR;
+
+typedef CK_CHAR *		CK_CHAR_PTR;
+typedef CK_UTF8CHAR *		CK_UTF8CHAR_PTR;
+
+typedef void *			CK_VOID_PTR;
+typedef CK_VOID_PTR *		CK_VOID_PTR_PTR;
+
+typedef CK_BYTE			CK_BBOOL;
+
+#define CK_TRUE			1
+#define CK_FALSE		0
+
+typedef CK_ULONG		CK_FLAGS;
+
+#define CK_UNAVAILABLE_INFORMATION	(~0UL)
+#define CK_EFFECTIVELY_INFINITE	0
+
+typedef CK_ULONG		CK_SESSION_HANDLE;
+typedef CK_SESSION_HANDLE *	CK_SESSION_HANDLE_PTR;
+typedef CK_ULONG		CK_OBJECT_HANDLE;
+typedef CK_OBJECT_HANDLE *	CK_OBJECT_HANDLE_PTR;
+
+#define CK_INVALID_HANDLE	0
+
+typedef CK_ULONG		CK_SLOT_ID;
+typedef CK_SLOT_ID *		CK_SLOT_ID_PTR;
+
+typedef struct CK_VERSION	CK_VERSION;
+typedef struct CK_VERSION *	CK_VERSION_PTR;
+
+struct CK_VERSION {
+	CK_BYTE		major;
+	CK_BYTE		minor;
+};
+
+typedef struct CK_DATE		CK_DATE;
+typedef struct CK_DATE *	CK_DATE_PTR;
+
+struct CK_DATE {
+	CK_CHAR		year[4];
+	CK_CHAR		month[2];
+	CK_CHAR		day[2];
+};
+
+/*
+ * PKCS#11 Objects attributes
+ */
+
+typedef CK_ULONG		CK_ATTRIBUTE_TYPE;
+
+typedef struct CK_ATTRIBUTE	CK_ATTRIBUTE;
+typedef struct CK_ATTRIBUTE *	CK_ATTRIBUTE_PTR;
+
+struct CK_ATTRIBUTE {
+	CK_ATTRIBUTE_TYPE	type;
+	CK_VOID_PTR		pValue;
+	CK_ULONG		ulValueLen;
+};
+
+/*
+ * Values for CK_ATTRIBUTE_TYPE
+ *
+ * This does not cover the full PKCS#11 IDs.
+ */
+#define CKF_ARRAY_ATTRIBUTE		(1U << 30)
+#define CKA_VENDOR_DEFINED		(1U << 31)
+#define CKA_CLASS			0x0000
+#define CKA_TOKEN			0x0001
+#define CKA_PRIVATE			0x0002
+#define CKA_LABEL			0x0003
+#define CKA_APPLICATION			0x0010
+#define CKA_VALUE			0x0011
+#define CKA_OBJECT_ID			0x0012
+#define CKA_CERTIFICATE_TYPE		0x0080
+#define CKA_ISSUER			0x0081
+#define CKA_SERIAL_NUMBER		0x0082
+#define CKA_AC_ISSUER			0x0083
+#define CKA_OWNER			0x0084
+#define CKA_ATTR_TYPES			0x0085
+#define CKA_TRUSTED			0x0086
+#define CKA_CERTIFICATE_CATEGORY	0x0087
+#define CKA_JAVA_MIDP_SECURITY_DOMAIN	0x0088
+#define CKA_URL				0x0089
+#define CKA_HASH_OF_SUBJECT_PUBLIC_KEY	0x008a
+#define CKA_HASH_OF_ISSUER_PUBLIC_KEY	0x008b
+#define CKA_NAME_HASH_ALGORITHM		0x008c
+#define CKA_CHECK_VALUE			0x0090
+#define CKA_KEY_TYPE			0x0100
+#define CKA_SUBJECT			0x0101
+#define CKA_ID				0x0102
+#define CKA_SENSITIVE			0x0103
+#define CKA_ENCRYPT			0x0104
+#define CKA_DECRYPT			0x0105
+#define CKA_WRAP			0x0106
+#define CKA_UNWRAP			0x0107
+#define CKA_SIGN			0x0108
+#define CKA_SIGN_RECOVER		0x0109
+#define CKA_VERIFY			0x010a
+#define CKA_VERIFY_RECOVER		0x010b
+#define CKA_DERIVE			0x010c
+#define CKA_START_DATE			0x0110
+#define CKA_END_DATE			0x0111
+#define CKA_MODULUS			0x0120
+#define CKA_MODULUS_BITS		0x0121
+#define CKA_PUBLIC_EXPONENT		0x0122
+#define CKA_PRIVATE_EXPONENT		0x0123
+#define CKA_PRIME_1			0x0124
+#define CKA_PRIME_2			0x0125
+#define CKA_EXPONENT_1			0x0126
+#define CKA_EXPONENT_2			0x0127
+#define CKA_COEFFICIENT			0x0128
+#define CKA_PUBLIC_KEY_INFO		0x0129
+#define CKA_PRIME			0x0130
+#define CKA_SUBPRIME			0x0131
+#define CKA_BASE			0x0132
+#define CKA_PRIME_BITS			0x0133
+#define CKA_SUBPRIME_BITS		0x0134
+#define CKA_VALUE_BITS			0x0160
+#define CKA_VALUE_LEN			0x0161
+#define CKA_EXTRACTABLE			0x0162
+#define CKA_LOCAL			0x0163
+#define CKA_NEVER_EXTRACTABLE		0x0164
+#define CKA_ALWAYS_SENSITIVE		0x0165
+#define CKA_KEY_GEN_MECHANISM		0x0166
+#define CKA_MODIFIABLE			0x0170
+#define CKA_COPYABLE			0x0171
+#define CKA_DESTROYABLE			0x0172
+#define CKA_EC_PARAMS			0x0180
+#define CKA_EC_POINT			0x0181
+#define CKA_ALWAYS_AUTHENTICATE		0x0202
+#define CKA_WRAP_WITH_TRUSTED		0x0210
+#define CKA_WRAP_TEMPLATE		(0x0211 | CKF_ARRAY_ATTRIBUTE)
+#define CKA_UNWRAP_TEMPLATE		(0x0212 | CKF_ARRAY_ATTRIBUTE)
+#define CKA_DERIVE_TEMPLATE		(0x0213 | CKF_ARRAY_ATTRIBUTE)
+#define CKA_OTP_FORMAT			0x0220
+#define CKA_OTP_LENGTH			0x0221
+#define CKA_OTP_TIME_INTERVAL		0x0222
+#define CKA_OTP_USER_FRIENDLY_MODE	0x0223
+#define CKA_OTP_CHALLENGE_REQUIREMENT	0x0224
+#define CKA_OTP_TIME_REQUIREMENT	0x0225
+#define CKA_OTP_COUNTER_REQUIREMENT	0x0226
+#define CKA_OTP_PIN_REQUIREMENT		0x0227
+#define CKA_OTP_COUNTER			0x022e
+#define CKA_OTP_TIME			0x022f
+#define CKA_OTP_USER_IDENTIFIER		0x022a
+#define CKA_OTP_SERVICE_IDENTIFIER	0x022b
+#define CKA_OTP_SERVICE_LOGO		0x022c
+#define CKA_OTP_SERVICE_LOGO_TYPE	0x022d
+#define CKA_GOSTR3410_PARAMS		0x0250
+#define CKA_GOSTR3411_PARAMS		0x0251
+#define CKA_GOST28147_PARAMS		0x0252
+#define CKA_HW_FEATURE_TYPE		0x0300
+#define CKA_RESET_ON_INIT		0x0301
+#define CKA_HAS_RESET			0x0302
+#define CKA_PIXEL_X			0x0400
+#define CKA_PIXEL_Y			0x0401
+#define CKA_RESOLUTION			0x0402
+#define CKA_CHAR_ROWS			0x0403
+#define CKA_CHAR_COLUMNS		0x0404
+#define CKA_COLOR			0x0405
+#define CKA_BITS_PER_PIXEL		0x0406
+#define CKA_CHAR_SETS			0x0480
+#define CKA_ENCODING_METHODS		0x0481
+#define CKA_MIME_TYPES			0x0482
+#define CKA_MECHANISM_TYPE		0x0500
+#define CKA_REQUIRED_CMS_ATTRIBUTES	0x0501
+#define CKA_DEFAULT_CMS_ATTRIBUTES	0x0502
+#define CKA_SUPPORTED_CMS_ATTRIBUTES	0x0503
+#define CKA_ALLOWED_MECHANISMS		(0x0600 | CKF_ARRAY_ATTRIBUTE)
+
+/* Attribute CKA_CLASS refers to a CK_OBJECT_CLASS typed value */
+typedef CK_ULONG		CK_OBJECT_CLASS;
+typedef CK_OBJECT_CLASS *	CK_OBJECT_CLASS_PTR;
+
+/* Values for type CK_OBJECT_CLASS */
+#define CKO_VENDOR_DEFINED		(1U << 31)
+#define CKO_DATA			0x0
+#define CKO_CERTIFICATE			0x1
+#define CKO_PUBLIC_KEY			0x2
+#define CKO_PRIVATE_KEY			0x3
+#define CKO_SECRET_KEY			0x4
+#define CKO_HW_FEATURE			0x5
+#define CKO_DOMAIN_PARAMETERS		0x6
+#define CKO_MECHANISM			0x7
+#define CKO_OTP_KEY			0x8
+
+/* Attribute CKA_KEY_TYPE refers to a CK_KEY_TYPE typed value */
+typedef CK_ULONG		CK_KEY_TYPE;
+typedef CK_KEY_TYPE *		CK_KEY_TYPE_PTR;
+
+/*
+ * Values for type CK_KEY_TYPE
+ *
+ * This does not cover the full PKCS#11 IDs.
+ */
+#define CKK_VENDOR_DEFINED		(1U << 31)
+#define CKK_RSA				0x000
+#define CKK_DSA				0x001
+#define CKK_DH				0x002
+#define CKK_ECDSA			0x003
+#define CKK_EC				0x003
+#define CKK_GENERIC_SECRET		0x010
+#define CKK_DES			0x013
+#define CKK_DES2			0x014
+#define CKK_DES3			0x015
+#define CKK_AES				0x01f
+#define CKK_HOTP			0x023
+#define CKK_MD5_HMAC			0x027
+#define CKK_SHA_1_HMAC			0x028
+#define CKK_SHA256_HMAC			0x02b
+#define CKK_SHA384_HMAC			0x02c
+#define CKK_SHA512_HMAC			0x02d
+#define CKK_SHA224_HMAC			0x02e
+
+/* Attribute CKA_CERTIFICATE_TYPE refers to a CK_CERTIFICATE_TYPE typed value */
+typedef CK_ULONG		CK_CERTIFICATE_TYPE;
+typedef CK_CERTIFICATE_TYPE *	CK_CERTIFICATE_TYPE_PTR;
+
+/*
+ * Values for type CK_CERTIFICATE_TYPE
+ */
+#define CKC_VENDOR_DEFINED		(1U << 31)
+#define CKC_X_509				0x000
+#define CKC_X_509_ATTR_CER			0x001
+#define CKC_WTLS				0x002
+
+/*
+ * Mechanisms
+ *
+ * Note: a mechanism can be referenced as object reference in some PKCS#11 API
+ * functions. In such case, the object hold attribute CKA_MECHANISM_TYPE which
+ * refers to a CK_MECHANISM_TYPE typed value that defines the target mechanism.
+ */
+
+typedef CK_ULONG		CK_MECHANISM_TYPE;
+typedef CK_MECHANISM_TYPE *	CK_MECHANISM_TYPE_PTR;
+
+/*
+ * Values for type CK_MECHANISM_TYPE
+ *
+ * This does not cover the full PKCS#11 IDs.
+ */
+#define CKM_VENDOR_DEFINED		(1U << 31)
+#define CKM_RSA_PKCS_KEY_PAIR_GEN	0x00000
+#define CKM_RSA_PKCS			0x00001
+#define CKM_RSA_9796			0x00002
+#define CKM_RSA_X_509			0x00003
+#define CKM_SHA1_RSA_PKCS		0x00006
+#define CKM_RSA_PKCS_OAEP		0x00009
+#define CKM_RSA_PKCS_PSS		0x0000d
+#define CKM_SHA1_RSA_PKCS_PSS		0x0000e
+#define CKM_SHA256_RSA_PKCS		0x00040
+#define CKM_SHA384_RSA_PKCS		0x00041
+#define CKM_SHA512_RSA_PKCS		0x00042
+#define CKM_SHA256_RSA_PKCS_PSS		0x00043
+#define CKM_SHA384_RSA_PKCS_PSS		0x00044
+#define CKM_SHA512_RSA_PKCS_PSS		0x00045
+#define CKM_SHA224_RSA_PKCS		0x00046
+#define CKM_SHA224_RSA_PKCS_PSS		0x00047
+#define CKM_SHA512_224			0x00048
+#define CKM_SHA512_224_HMAC		0x00049
+#define CKM_SHA512_224_HMAC_GENERAL	0x0004a
+#define CKM_SHA512_224_KEY_DERIVATION	0x0004b
+#define CKM_SHA512_256			0x0004c
+#define CKM_SHA512_256_HMAC		0x0004d
+#define CKM_SHA512_256_HMAC_GENERAL	0x0004e
+#define CKM_SHA512_256_KEY_DERIVATION	0x0004f
+#define CKM_DES_KEY_GEN		0x00120
+#define CKM_DES_ECB			0x00121
+#define CKM_DES_CBC			0x00122
+#define CKM_DES_MAC			0x00123
+#define CKM_DES_MAC_GENERAL		0x00124
+#define CKM_DES_CBC_PAD		0x00125
+#define CKM_DES3_ECB			0x00132
+#define CKM_DES3_CBC			0x00133
+#define CKM_DES3_MAC			0x00134
+#define CKM_DES3_MAC_GENERAL		0x00135
+#define CKM_DES3_CBC_PAD		0x00136
+#define CKM_DES3_CMAC_GENERAL		0x00137
+#define CKM_DES3_CMAC			0x00138
+#define CKM_MD5				0x00210
+#define CKM_MD5_HMAC			0x00211
+#define CKM_MD5_HMAC_GENERAL		0x00212
+#define CKM_SHA_1			0x00220
+#define CKM_SHA_1_HMAC			0x00221
+#define CKM_SHA_1_HMAC_GENERAL		0x00222
+#define CKM_SHA256			0x00250
+#define CKM_SHA256_HMAC			0x00251
+#define CKM_SHA256_HMAC_GENERAL		0x00252
+#define CKM_SHA224			0x00255
+#define CKM_SHA224_HMAC			0x00256
+#define CKM_SHA224_HMAC_GENERAL		0x00257
+#define CKM_SHA384			0x00260
+#define CKM_SHA384_HMAC			0x00261
+#define CKM_SHA384_HMAC_GENERAL		0x00262
+#define CKM_SHA512			0x00270
+#define CKM_SHA512_HMAC			0x00271
+#define CKM_SHA512_HMAC_GENERAL		0x00272
+#define CKM_HOTP_KEY_GEN		0x00290
+#define CKM_HOTP			0x00291
+#define CKM_GENERIC_SECRET_KEY_GEN	0x00350
+#define CKM_MD5_KEY_DERIVATION		0x00390
+#define CKM_MD2_KEY_DERIVATION		0x00391
+#define CKM_SHA1_KEY_DERIVATION		0x00392
+#define CKM_SHA256_KEY_DERIVATION	0x00393
+#define CKM_SHA384_KEY_DERIVATION	0x00394
+#define CKM_SHA512_KEY_DERIVATION	0x00395
+#define CKM_SHA224_KEY_DERIVATION	0x00396
+#define CKM_EC_KEY_PAIR_GEN		0x01040
+#define CKM_ECDSA			0x01041
+#define CKM_ECDSA_SHA1			0x01042
+#define CKM_ECDSA_SHA224		0x01043
+#define CKM_ECDSA_SHA256		0x01044
+#define CKM_ECDSA_SHA384		0x01045
+#define CKM_ECDSA_SHA512		0x01046
+#define CKM_ECDH1_DERIVE		0x01050
+#define CKM_ECDH1_COFACTOR_DERIVE	0x01051
+#define CKM_ECMQV_DERIVE		0x01052
+#define CKM_ECDH_AES_KEY_WRAP		0x01053
+#define CKM_RSA_AES_KEY_WRAP		0x01054
+#define CKM_AES_KEY_GEN			0x01080
+#define CKM_AES_ECB			0x01081
+#define CKM_AES_CBC			0x01082
+#define CKM_AES_MAC			0x01083
+#define CKM_AES_MAC_GENERAL		0x01084
+#define CKM_AES_CBC_PAD			0x01085
+#define CKM_AES_CTR			0x01086
+#define CKM_AES_GCM			0x01087
+#define CKM_AES_CCM			0x01088
+#define CKM_AES_CTS			0x01089
+#define CKM_AES_CMAC			0x0108a
+#define CKM_AES_CMAC_GENERAL		0x0108b
+#define CKM_AES_XCBC_MAC		0x0108c
+#define CKM_AES_XCBC_MAC_96		0x0108d
+#define CKM_AES_GMAC			0x0108e
+#define CKM_DES3_ECB_ENCRYPT_DATA	0x01102
+#define CKM_DES3_CBC_ENCRYPT_DATA	0x01103
+#define CKM_AES_ECB_ENCRYPT_DATA	0x01104
+#define CKM_AES_CBC_ENCRYPT_DATA	0x01105
+#define CKM_AES_KEY_WRAP		0x02109
+#define CKM_AES_KEY_WRAP_PAD		0x0210a
+
+typedef struct CK_MECHANISM_INFO	CK_MECHANISM_INFO;
+typedef struct CK_MECHANISM_INFO *	CK_MECHANISM_INFO_PTR;
+
+struct CK_MECHANISM_INFO {
+	CK_ULONG		ulMinKeySize;
+	CK_ULONG		ulMaxKeySize;
+	CK_FLAGS		flags;
+};
+
+/* Flags for field flags of struct ck_mechanism_info */
+#define CKF_HW				(1U << 0)
+#define CKF_ENCRYPT			(1U << 8)
+#define CKF_DECRYPT			(1U << 9)
+#define CKF_DIGEST			(1U << 10)
+#define CKF_SIGN			(1U << 11)
+#define CKF_SIGN_RECOVER		(1U << 12)
+#define CKF_VERIFY			(1U << 13)
+#define CKF_VERIFY_RECOVER		(1U << 14)
+#define CKF_GENERATE			(1U << 15)
+#define CKF_GENERATE_KEY_PAIR		(1U << 16)
+#define CKF_WRAP			(1U << 17)
+#define CKF_UNWRAP			(1U << 18)
+#define CKF_DERIVE			(1U << 19)
+#define CKF_EC_F_P			(1U << 20)
+#define CKF_EC_F_2M			(1U << 21)
+#define CKF_EC_ECPARAMETERS		(1U << 22)
+#define CKF_EC_NAMEDCURVE		(1U << 23)
+#define CKF_EC_UNCOMPRESS		(1U << 24)
+#define CKF_EC_COMPRESS			(1U << 25)
+#define CKF_EXTENSION			(1U << 31)
+
+/*
+ * Mechanism parameter structures
+ *
+ * This does not cover the whole mechanism parameter structures defined by
+ * the PKCS#11. To be updated when needed.
+ */
+
+typedef struct CK_MECHANISM	CK_MECHANISM;
+typedef struct CK_MECHANISM *	CK_MECHANISM_PTR;
+
+struct CK_MECHANISM {
+	CK_MECHANISM_TYPE	mechanism;
+	CK_VOID_PTR		pParameter;
+	CK_ULONG		ulParameterLen;
+};
+
+/* Key diversification identifiers */
+typedef CK_ULONG		CK_EC_KDF_TYPE;
+
+/* Values for type CK_EC_KDF_TYPE */
+#define CKD_NULL			0x0001
+#define CKD_SHA1_KDF			0x0002
+#define CKD_SHA1_KDF_ASN1		0x0003
+#define CKD_SHA1_KDF_CONCATENATE	0x0004
+#define CKD_SHA224_KDF			0x0005
+#define CKD_SHA256_KDF			0x0006
+#define CKD_SHA384_KDF			0x0007
+#define CKD_SHA512_KDF			0x0008
+#define CKD_CPDIVERSIFY_KDF		0x0009
+
+typedef CK_ULONG CK_RSA_PKCS_MGF_TYPE;
+
+/* Values for type CK_RSA_PKCS_MGF_TYPE */
+#define CKG_MGF1_SHA1		0x0001UL
+#define CKG_MGF1_SHA224		0x0005UL
+#define CKG_MGF1_SHA256		0x0002UL
+#define CKG_MGF1_SHA384		0x0003UL
+#define CKG_MGF1_SHA512		0x0004UL
+
+typedef CK_ULONG CK_RSA_PKCS_OAEP_SOURCE_TYPE;
+
+/* Values for type CK_RSA_PKCS_OAEP_SOURCE_TYPE */
+#define CKZ_DATA_SPECIFIED	0x0001UL
+
+/* MAC General parameters */
+typedef CK_ULONG			CK_MAC_GENERAL_PARAMS;
+typedef CK_MAC_GENERAL_PARAMS *		CK_MAC_GENERAL_PARAMS_PTR;
+
+/*
+ * AES derivation by ECB encryption parameters: uses the generic
+ * structure CK_KEY_DERIVATION_STRING_DATA.
+ */
+typedef struct CK_KEY_DERIVATION_STRING_DATA	CK_KEY_DERIVATION_STRING_DATA;
+typedef struct CK_KEY_DERIVATION_STRING_DATA *	\
+					CK_KEY_DERIVATION_STRING_DATA_PTR;
+
+struct CK_KEY_DERIVATION_STRING_DATA {
+	CK_BYTE_PTR		pData;
+	CK_ULONG		ulLen;
+};
+
+/* AES derivation by CBC encryption parameters */
+typedef struct CK_AES_CBC_ENCRYPT_DATA_PARAMS	CK_AES_CBC_ENCRYPT_DATA_PARAMS;
+typedef struct CK_AES_CBC_ENCRYPT_DATA_PARAMS *
+					CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+struct CK_AES_CBC_ENCRYPT_DATA_PARAMS {
+	CK_BYTE			iv[16];
+	CK_BYTE_PTR		pData;
+	CK_ULONG		length;
+};
+
+/* AES CTR parameters */
+typedef struct CK_AES_CTR_PARAMS	CK_AES_CTR_PARAMS;
+typedef struct CK_AES_CTR_PARAMS *	CK_AES_CTR_PARAMS_PTR;
+
+struct CK_AES_CTR_PARAMS {
+	CK_ULONG		ulCounterBits;
+	CK_BYTE			cb[16];
+};
+
+/* AES GCM parameters */
+typedef struct CK_GCM_PARAMS		CK_GCM_PARAMS;
+typedef struct CK_GCM_PARAMS *		CK_GCM_PARAMS_PTR;
+
+struct CK_GCM_PARAMS {
+	CK_BYTE_PTR		pIv;
+	CK_ULONG		ulIvLen;
+	CK_ULONG		ulIvBits;
+	CK_BYTE_PTR		pAAD;
+	CK_ULONG		ulAADLen;
+	CK_ULONG		ulTagBits;
+};
+
+/* AES CCM parameters */
+typedef struct CK_CCM_PARAMS		CK_CCM_PARAMS;
+typedef struct CK_CCM_PARAMS *		CK_CCM_PARAMS_PTR;
+
+struct CK_CCM_PARAMS {
+	CK_ULONG		ulDataLen;
+	CK_BYTE_PTR		pNonce;
+	CK_ULONG		ulNonceLen;
+	CK_BYTE_PTR		pAAD;
+	CK_ULONG		ulAADLen;
+	CK_ULONG		ulMACLen;
+};
+
+/*
+ * Elliptic curve Diffie-Hellman key derivation
+ * Elliptic curve Diffie-Hellman cofactor key derivation parameters
+ */
+typedef struct CK_ECDH1_DERIVE_PARAMS		CK_ECDH1_DERIVE_PARAMS;
+typedef struct CK_ECDH1_DERIVE_PARAMS *		CK_ECDH1_DERIVE_PARAMS_PTR;
+
+struct CK_ECDH1_DERIVE_PARAMS {
+	CK_EC_KDF_TYPE		kdf;
+	CK_ULONG		ulSharedDataLen;
+	CK_BYTE_PTR		pSharedData;
+	CK_ULONG		ulPublicDataLen;
+	CK_BYTE_PTR		pPublicData;
+};
+
+/* Parameters for CKM_ECDH_AES_KEY_WRAP */
+typedef struct CK_ECDH_AES_KEY_WRAP_PARAMS	CK_ECDH_AES_KEY_WRAP_PARAMS;
+typedef struct CK_ECDH_AES_KEY_WRAP_PARAMS *	CK_ECDH_AES_KEY_WRAP_PARAMS_PTR;
+
+struct CK_ECDH_AES_KEY_WRAP_PARAMS {
+	CK_ULONG		ulAESKeyBits;
+	CK_EC_KDF_TYPE		kdf;
+	CK_ULONG		ulSharedDataLen;
+	CK_BYTE_PTR		pSharedData;
+};
+
+/* Parameters for CKM_RSA_PKCS_OAEP */
+typedef struct CK_RSA_PKCS_OAEP_PARAMS		CK_RSA_PKCS_OAEP_PARAMS;
+typedef struct CK_RSA_PKCS_OAEP_PARAMS *	CK_RSA_PKCS_OAEP_PARAMS_PTR;
+
+struct CK_RSA_PKCS_OAEP_PARAMS {
+	CK_MECHANISM_TYPE	hashAlg;
+	CK_RSA_PKCS_MGF_TYPE	mgf;
+	CK_RSA_PKCS_OAEP_SOURCE_TYPE source;
+	CK_VOID_PTR		pSourceData;
+	CK_ULONG		ulSourceDataLen;
+};
+
+/* Parameters for CKM_RSA_PKCS_PSS */
+typedef struct CK_RSA_PKCS_PSS_PARAMS		CK_RSA_PKCS_PSS_PARAMS;
+typedef struct CK_RSA_PKCS_PSS_PARAMS *		CK_RSA_PKCS_PSS_PARAMS_PTR;
+
+struct CK_RSA_PKCS_PSS_PARAMS {
+	CK_MECHANISM_TYPE	hashAlg;
+	CK_RSA_PKCS_MGF_TYPE	mgf;
+	CK_ULONG		sLen;
+};
+
+/* Parameters for CKM_RSA_AES_KEY_WRAP */
+typedef struct CK_RSA_AES_KEY_WRAP_PARAMS	CK_RSA_AES_KEY_WRAP_PARAMS;
+typedef struct CK_RSA_AES_KEY_WRAP_PARAMS *	CK_RSA_AES_KEY_WRAP_PARAMS_PTR;
+
+struct CK_RSA_AES_KEY_WRAP_PARAMS {
+	CK_ULONG		ulAESKeyBits;
+	CK_RSA_PKCS_OAEP_PARAMS_PTR pOAEPParams;
+};
+
+
+/*
+ * PKCS#11 return values
+ */
+typedef CK_ULONG			CK_RV;
+
+/* Values for type CK_RV */
+#define CKR_VENDOR_DEFINED			(1U << 31)
+#define CKR_OK					0x0000
+#define CKR_CANCEL				0x0001
+#define CKR_HOST_MEMORY				0x0002
+#define CKR_SLOT_ID_INVALID			0x0003
+#define CKR_GENERAL_ERROR			0x0005
+#define CKR_FUNCTION_FAILED			0x0006
+#define CKR_ARGUMENTS_BAD			0x0007
+#define CKR_NO_EVENT				0x0008
+#define CKR_NEED_TO_CREATE_THREADS		0x0009
+#define CKR_CANT_LOCK				0x000a
+#define CKR_ATTRIBUTE_READ_ONLY			0x0010
+#define CKR_ATTRIBUTE_SENSITIVE			0x0011
+#define CKR_ATTRIBUTE_TYPE_INVALID		0x0012
+#define CKR_ATTRIBUTE_VALUE_INVALID		0x0013
+#define CKR_ACTION_PROHIBITED			0x001b
+#define CKR_DATA_INVALID			0x0020
+#define CKR_DATA_LEN_RANGE			0x0021
+#define CKR_DEVICE_ERROR			0x0030
+#define CKR_DEVICE_MEMORY			0x0031
+#define CKR_DEVICE_REMOVED			0x0032
+#define CKR_ENCRYPTED_DATA_INVALID		0x0040
+#define CKR_ENCRYPTED_DATA_LEN_RANGE		0x0041
+#define CKR_FUNCTION_CANCELED			0x0050
+#define CKR_FUNCTION_NOT_PARALLEL		0x0051
+#define CKR_FUNCTION_NOT_SUPPORTED		0x0054
+#define CKR_KEY_HANDLE_INVALID			0x0060
+#define CKR_KEY_SIZE_RANGE			0x0062
+#define CKR_KEY_TYPE_INCONSISTENT		0x0063
+#define CKR_KEY_NOT_NEEDED			0x0064
+#define CKR_KEY_CHANGED				0x0065
+#define CKR_KEY_NEEDED				0x0066
+#define CKR_KEY_INDIGESTIBLE			0x0067
+#define CKR_KEY_FUNCTION_NOT_PERMITTED		0x0068
+#define CKR_KEY_NOT_WRAPPABLE			0x0069
+#define CKR_KEY_UNEXTRACTABLE			0x006a
+#define CKR_MECHANISM_INVALID			0x0070
+#define CKR_MECHANISM_PARAM_INVALID		0x0071
+#define CKR_OBJECT_HANDLE_INVALID		0x0082
+#define CKR_OPERATION_ACTIVE			0x0090
+#define CKR_OPERATION_NOT_INITIALIZED		0x0091
+#define CKR_PIN_INCORRECT			0x00a0
+#define CKR_PIN_INVALID				0x00a1
+#define CKR_PIN_LEN_RANGE			0x00a2
+#define CKR_PIN_EXPIRED				0x00a3
+#define CKR_PIN_LOCKED				0x00a4
+#define CKR_SESSION_CLOSED			0x00b0
+#define CKR_SESSION_COUNT			0x00b1
+#define CKR_SESSION_HANDLE_INVALID		0x00b3
+#define CKR_SESSION_PARALLEL_NOT_SUPPORTED	0x00b4
+#define CKR_SESSION_READ_ONLY			0x00b5
+#define CKR_SESSION_EXISTS			0x00b6
+#define CKR_SESSION_READ_ONLY_EXISTS		0x00b7
+#define CKR_SESSION_READ_WRITE_SO_EXISTS	0x00b8
+#define CKR_SIGNATURE_INVALID			0x00c0
+#define CKR_SIGNATURE_LEN_RANGE			0x00c1
+#define CKR_TEMPLATE_INCOMPLETE			0x00d0
+#define CKR_TEMPLATE_INCONSISTENT		0x00d1
+#define CKR_TOKEN_NOT_PRESENT			0x00e0
+#define CKR_TOKEN_NOT_RECOGNIZED		0x00e1
+#define CKR_TOKEN_WRITE_PROTECTED		0x00e2
+#define CKR_UNWRAPPING_KEY_HANDLE_INVALID	0x00f0
+#define CKR_UNWRAPPING_KEY_SIZE_RANGE		0x00f1
+#define CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT	0x00f2
+#define CKR_USER_ALREADY_LOGGED_IN		0x0100
+#define CKR_USER_NOT_LOGGED_IN			0x0101
+#define CKR_USER_PIN_NOT_INITIALIZED		0x0102
+#define CKR_USER_TYPE_INVALID			0x0103
+#define CKR_USER_ANOTHER_ALREADY_LOGGED_IN	0x0104
+#define CKR_USER_TOO_MANY_TYPES			0x0105
+#define CKR_WRAPPED_KEY_INVALID			0x0110
+#define CKR_WRAPPED_KEY_LEN_RANGE		0x0112
+#define CKR_WRAPPING_KEY_HANDLE_INVALID		0x0113
+#define CKR_WRAPPING_KEY_SIZE_RANGE		0x0114
+#define CKR_WRAPPING_KEY_TYPE_INCONSISTENT	0x0115
+#define CKR_RANDOM_SEED_NOT_SUPPORTED		0x0120
+#define CKR_RANDOM_NO_RNG			0x0121
+#define CKR_DOMAIN_PARAMS_INVALID		0x0130
+#define CKR_CURVE_NOT_SUPPORTED			0x0140
+#define CKR_BUFFER_TOO_SMALL			0x0150
+#define CKR_SAVED_STATE_INVALID			0x0160
+#define CKR_INFORMATION_SENSITIVE		0x0170
+#define CKR_STATE_UNSAVEABLE			0x0180
+#define CKR_CRYPTOKI_NOT_INITIALIZED		0x0190
+#define CKR_CRYPTOKI_ALREADY_INITIALIZED	0x0191
+#define CKR_MUTEX_BAD				0x01a0
+#define CKR_MUTEX_NOT_LOCKED			0x01a1
+#define CKR_NEW_PIN_MODE			0x01b0
+#define CKR_NEXT_OTP				0x01b1
+#define CKR_EXCEEDED_MAX_ITERATIONS		0x01b5
+#define CKR_FIPS_SELF_TEST_FAILED		0x01b6
+#define CKR_LIBRARY_LOAD_FAILED			0x01b7
+#define CKR_PIN_TOO_WEAK			0x01b8
+#define CKR_PUBLIC_KEY_INVALID			0x01b9
+#define CKR_FUNCTION_REJECTED			0x0200
+
+/*
+ * PKCS#11 API functions
+ */
+
+/* Argument for C_GetInfo */
+typedef struct CK_INFO		CK_INFO;
+typedef struct CK_INFO *	CK_INFO_PTR;
+
+struct CK_INFO {
+	CK_VERSION	cryptokiVersion;
+	CK_UTF8CHAR	manufacturerID[32];
+	CK_FLAGS	flags;
+	CK_UTF8CHAR	libraryDescription[32];
+	CK_VERSION	libraryVersion;
+};
+
+/* Argument for C_GetSlotInfo */
+typedef struct CK_SLOT_INFO	CK_SLOT_INFO;
+typedef struct CK_SLOT_INFO *	CK_SLOT_INFO_PTR;
+
+struct CK_SLOT_INFO {
+	CK_UTF8CHAR	slotDescription[64];
+	CK_UTF8CHAR	manufacturerID[32];
+	CK_FLAGS	flags;
+	CK_VERSION	hardwareVersion;
+	CK_VERSION	firmwareVersion;
+};
+
+/* Values for field flags of struct ck_slot_info */
+#define CKF_TOKEN_PRESENT	(1U << 0)
+#define CKF_REMOVABLE_DEVICE	(1U << 1)
+#define CKF_HW_SLOT		(1U << 2)
+
+/* Argument for C_GetTokenInfo */
+typedef struct CK_TOKEN_INFO	CK_TOKEN_INFO;
+typedef struct CK_TOKEN_INFO *	CK_TOKEN_INFO_PTR;
+
+struct CK_TOKEN_INFO {
+	CK_UTF8CHAR	label[32];
+	CK_UTF8CHAR	manufacturerID[32];
+	CK_UTF8CHAR	model[16];
+	CK_CHAR		serialNumber[16];
+	CK_FLAGS	flags;
+	CK_ULONG	ulMaxSessionCount;
+	CK_ULONG	ulSessionCount;
+	CK_ULONG	ulMaxRwSessionCount;
+	CK_ULONG	ulRwSessionCount;
+	CK_ULONG	ulMaxPinLen;
+	CK_ULONG	ulMinPinLen;
+	CK_ULONG	ulTotalPublicMemory;
+	CK_ULONG	ulFreePublicMemory;
+	CK_ULONG	ulTotalPrivateMemory;
+	CK_ULONG	ulFreePrivateMemory;
+	CK_VERSION	hardwareVersion;
+	CK_VERSION	firmwareVersion;
+	CK_CHAR		utcTime[16];
+};
+
+/* Values for field flags of struct ck_token_info */
+#define CKF_RNG					(1U << 0)
+#define CKF_WRITE_PROTECTED			(1U << 1)
+#define CKF_LOGIN_REQUIRED			(1U << 2)
+#define CKF_USER_PIN_INITIALIZED		(1U << 3)
+#define CKF_RESTORE_KEY_NOT_NEEDED		(1U << 5)
+#define CKF_CLOCK_ON_TOKEN			(1U << 6)
+#define CKF_PROTECTED_AUTHENTICATION_PATH	(1U << 8)
+#define CKF_DUAL_CRYPTO_OPERATIONS		(1U << 9)
+#define CKF_TOKEN_INITIALIZED			(1U << 10)
+#define CKF_SECONDARY_AUTHENTICATION		(1U << 11)
+#define CKF_USER_PIN_COUNT_LOW			(1U << 16)
+#define CKF_USER_PIN_FINAL_TRY			(1U << 17)
+#define CKF_USER_PIN_LOCKED			(1U << 18)
+#define CKF_USER_PIN_TO_BE_CHANGED		(1U << 19)
+#define CKF_SO_PIN_COUNT_LOW			(1U << 20)
+#define CKF_SO_PIN_FINAL_TRY			(1U << 21)
+#define CKF_SO_PIN_LOCKED			(1U << 22)
+#define CKF_SO_PIN_TO_BE_CHANGED		(1U << 23)
+#define CKF_ERROR_STATE				(1U << 24)
+
+/* Argument for C_GetSessionInfo */
+typedef struct CK_SESSION_INFO		CK_SESSION_INFO;
+typedef struct CK_SESSION_INFO *	CK_SESSION_INFO_PTR;
+
+typedef CK_ULONG			CK_STATE;
+
+/* Values for CK_STATE */
+#define CKS_RO_PUBLIC_SESSION		0
+#define CKS_RO_USER_FUNCTIONS		1
+#define CKS_RW_PUBLIC_SESSION		2
+#define CKS_RW_USER_FUNCTIONS		3
+#define CKS_RW_SO_FUNCTIONS		4
+
+struct CK_SESSION_INFO {
+	CK_SLOT_ID	slotID;
+	CK_STATE	state;
+	CK_FLAGS	flags;
+	CK_ULONG	ulDeviceError;
+};
+
+/* Values for field flags of struct ck_session_info */
+#define CKF_RW_SESSION			(1U << 1)
+#define CKF_SERIAL_SESSION		(1U << 2)
+
+/* Argument for C_Login */
+typedef CK_ULONG		CK_USER_TYPE;
+
+/* Values for CK_USER_TYPE */
+#define CKU_SO				0
+#define CKU_USER			1
+#define CKU_CONTEXT_SPECIFIC		2
+
+/* Values for argument flags of C_WaitForSlotEvent */
+#define CKF_DONT_BLOCK			1
+
+/* Argument for CK_NOTIFY typed callback function */
+typedef CK_ULONG		CK_NOTIFICATION;
+
+/* Values for CK_NOTIFICATION */
+#define CKN_SURRENDER			0
+#define CKN_OTP_CHANGED			1
+
+/* Callback handler types */
+typedef CK_RV (* CK_NOTIFY)(CK_SESSION_HANDLE hSession,
+			    CK_NOTIFICATION event,
+			    CK_VOID_PTR pApplication);
+typedef CK_RV (* CK_CREATEMUTEX)(CK_VOID_PTR_PTR ppMutex);
+typedef CK_RV (* CK_DESTROYMUTEX)(CK_VOID_PTR pMutex);
+typedef CK_RV (* CK_LOCKMUTEX)(CK_VOID_PTR pMutex);
+typedef CK_RV (* CK_UNLOCKMUTEX)(CK_VOID_PTR pMutex);
+
+/* Argument for C_GetFunctionList */
+typedef struct CK_FUNCTION_LIST		CK_FUNCTION_LIST;
+typedef struct CK_FUNCTION_LIST *	CK_FUNCTION_LIST_PTR;
+typedef struct CK_FUNCTION_LIST **	CK_FUNCTION_LIST_PTR_PTR;
+
+struct CK_FUNCTION_LIST {
+	CK_VERSION version;
+	CK_RV (*C_Initialize)(
+			CK_VOID_PTR init_args);
+	CK_RV (*C_Finalize)(
+			CK_VOID_PTR res);
+	CK_RV (*C_GetInfo)(
+			CK_INFO_PTR info);
+	CK_RV (*C_GetFunctionList)(
+			CK_FUNCTION_LIST_PTR_PTR list);
+	CK_RV (*C_GetSlotList)(
+			CK_BBOOL token_present,
+			CK_SLOT_ID_PTR slots,
+			CK_ULONG_PTR count);
+	CK_RV (*C_GetSlotInfo)(
+			CK_SLOT_ID slot,
+			CK_SLOT_INFO_PTR info);
+	CK_RV (*C_GetTokenInfo)(
+			CK_SLOT_ID slot,
+			CK_TOKEN_INFO_PTR info);
+	CK_RV (*C_GetMechanismList)(
+			CK_SLOT_ID slot,
+			CK_MECHANISM_TYPE_PTR mechanisms,
+			CK_ULONG_PTR count);
+	CK_RV (*C_GetMechanismInfo)(
+			CK_SLOT_ID slot,
+			CK_MECHANISM_TYPE type,
+			CK_MECHANISM_INFO_PTR info);
+	CK_RV (*C_InitToken)(
+			CK_SLOT_ID slot,
+			CK_UTF8CHAR_PTR pin,
+			CK_ULONG pin_len,
+			CK_UTF8CHAR_PTR label);
+	CK_RV (*C_InitPIN)(
+			CK_SESSION_HANDLE session,
+			CK_UTF8CHAR_PTR pin,
+			CK_ULONG pin_len);
+	CK_RV (*C_SetPIN)(
+			CK_SESSION_HANDLE session,
+			CK_UTF8CHAR_PTR old,
+			CK_ULONG old_len,
+			CK_UTF8CHAR_PTR new,
+			CK_ULONG new_len);
+	CK_RV (*C_OpenSession)(CK_SLOT_ID slot,
+			CK_FLAGS flags,
+			CK_VOID_PTR cookie,
+			CK_NOTIFY callback,
+			CK_SESSION_HANDLE_PTR session);
+	CK_RV (*C_CloseSession)(
+			CK_SESSION_HANDLE session);
+	CK_RV (*C_CloseAllSessions)(
+			CK_SLOT_ID slot);
+	CK_RV (*C_GetSessionInfo)(
+			CK_SESSION_HANDLE session,
+			CK_SESSION_INFO_PTR info);
+	CK_RV (*C_GetOperationState)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR state,
+			CK_ULONG_PTR state_len);
+	CK_RV (*C_SetOperationState)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR state,
+			CK_ULONG state_len,
+			CK_OBJECT_HANDLE ciph_key,
+			CK_OBJECT_HANDLE auth_key);
+	CK_RV (*C_Login)(
+			CK_SESSION_HANDLE session,
+			CK_USER_TYPE user_type,
+			CK_UTF8CHAR_PTR pin,
+			CK_ULONG pin_len);
+	CK_RV (*C_Logout)(
+			CK_SESSION_HANDLE session);
+	CK_RV (*C_CreateObject)(
+			CK_SESSION_HANDLE session,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count,
+			CK_OBJECT_HANDLE_PTR obj);
+	CK_RV (*C_CopyObject)(
+			CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE obj,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count,
+			CK_OBJECT_HANDLE_PTR new_obj);
+	CK_RV (*C_DestroyObject)(
+			CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE obj);
+	CK_RV (*C_GetObjectSize)(
+			CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE obj,
+			CK_ULONG_PTR out_size);
+	CK_RV (*C_GetAttributeValue)(
+			CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE obj,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count);
+	CK_RV (*C_SetAttributeValue)(
+			CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE obj,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count);
+	CK_RV (*C_FindObjectsInit)(
+			CK_SESSION_HANDLE session,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count);
+	CK_RV (*C_FindObjects)(
+			CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE_PTR obj,
+			CK_ULONG max_count,
+			CK_ULONG_PTR count);
+	CK_RV (*C_FindObjectsFinal)(
+			CK_SESSION_HANDLE session);
+	CK_RV (*C_EncryptInit)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_OBJECT_HANDLE key);
+	CK_RV (*C_Encrypt)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_EncryptUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_EncryptFinal)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_DecryptInit)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR  mechanism,
+			CK_OBJECT_HANDLE  key);
+	CK_RV (*C_Decrypt)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_DecryptUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_DecryptFinal)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_DigestInit)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR  mechanism);
+	CK_RV (*C_Digest)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_DigestUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len);
+	CK_RV (*C_DigestKey)(
+			CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE  key);
+	CK_RV (*C_DigestFinal)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR digest,
+			CK_ULONG_PTR len);
+	CK_RV (*C_SignInit)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_OBJECT_HANDLE key);
+	CK_RV (*C_Sign)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_SignUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len);
+	CK_RV (*C_SignFinal)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_SignRecoverInit)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR  mechanism,
+			CK_OBJECT_HANDLE  key);
+	CK_RV (*C_SignRecover)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_VerifyInit)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_OBJECT_HANDLE key);
+	CK_RV (*C_Verify)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR sign,
+			CK_ULONG sign_len);
+	CK_RV (*C_VerifyUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len);
+	CK_RV (*C_VerifyFinal)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR sign,
+			CK_ULONG sign_len);
+	CK_RV (*C_VerifyRecoverInit)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_OBJECT_HANDLE key);
+	CK_RV (*C_VerifyRecover)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_DigestEncryptUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_DecryptDigestUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_SignEncryptUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_DecryptVerifyUpdate)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR in,
+			CK_ULONG in_len,
+			CK_BYTE_PTR out,
+			CK_ULONG_PTR out_len);
+	CK_RV (*C_GenerateKey)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count,
+			CK_OBJECT_HANDLE_PTR new_key);
+	CK_RV (*C_GenerateKeyPair)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_ATTRIBUTE_PTR pub_attribs,
+			CK_ULONG pub_count,
+			CK_ATTRIBUTE_PTR priv_attribs,
+			CK_ULONG priv_count,
+			CK_OBJECT_HANDLE_PTR pub_key,
+			CK_OBJECT_HANDLE_PTR priv_key);
+	CK_RV (*C_WrapKey)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_OBJECT_HANDLE wrap_key,
+			CK_OBJECT_HANDLE key,
+			CK_BYTE_PTR wrapped_key,
+			CK_ULONG_PTR wrapped_key_len);
+	CK_RV (*C_UnwrapKey)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_OBJECT_HANDLE unwrap_key,
+			CK_BYTE_PTR wrapped_key,
+			CK_ULONG wrapped_key_len,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count,
+			CK_OBJECT_HANDLE_PTR new_key);
+	CK_RV (*C_DeriveKey)(
+			CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_OBJECT_HANDLE derived_key,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count,
+			CK_OBJECT_HANDLE_PTR new_key);
+	CK_RV (*C_SeedRandom)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR seed,
+			CK_ULONG len);
+	CK_RV (*C_GenerateRandom)(
+			CK_SESSION_HANDLE session,
+			CK_BYTE_PTR out,
+			CK_ULONG len);
+	CK_RV (*C_GetFunctionStatus)(
+			CK_SESSION_HANDLE sessin);
+	CK_RV (*C_CancelFunction)(
+			CK_SESSION_HANDLE session);
+	CK_RV (*C_WaitForSlotEvent)(
+			CK_FLAGS flags,
+			CK_SLOT_ID_PTR slot,
+			CK_VOID_PTR rsv);
+};
+
+/* Optional init_args structure for C_Initialize */
+typedef struct CK_C_INITIALIZE_ARGS	CK_C_INITIALIZE_ARGS;
+typedef struct CK_C_INITIALIZE_ARGS *	CK_C_INITIALIZE_ARGS_PTR;
+
+struct CK_C_INITIALIZE_ARGS {
+	CK_CREATEMUTEX		CreateMutex;
+	CK_DESTROYMUTEX		DestroyMutex;
+	CK_LOCKMUTEX		LockMutex;
+	CK_UNLOCKMUTEX		UnlockMutex;
+	CK_FLAGS		flags;
+	CK_VOID_PTR		reserved;
+};
+
+/* Flags for field flags of struct ck_c_initialize_args */
+#define CKF_LIBRARY_CANT_CREATE_OS_THREADS	(1U << 0)
+#define CKF_OS_LOCKING_OK			(1U << 1)
+
+CK_RV C_Initialize(
+		CK_VOID_PTR init_args);
+
+CK_RV C_Finalize(
+		CK_VOID_PTR res);
+
+CK_RV C_GetInfo(
+		CK_INFO_PTR info);
+
+CK_RV C_GetFunctionList(
+		CK_FUNCTION_LIST_PTR_PTR ppFunctionList);
+
+CK_RV C_GetSlotList(
+		CK_BBOOL token_present,
+		CK_SLOT_ID_PTR slots,
+		CK_ULONG_PTR count);
+
+CK_RV C_GetSlotInfo(
+		CK_SLOT_ID slot,
+		CK_SLOT_INFO_PTR info);
+
+CK_RV C_InitToken(
+		CK_SLOT_ID slot,
+		CK_UTF8CHAR_PTR pin,
+		CK_ULONG pin_len,
+		CK_UTF8CHAR_PTR label);
+
+CK_RV C_GetTokenInfo(
+		CK_SLOT_ID slot,
+		CK_TOKEN_INFO_PTR info);
+
+CK_RV C_GetMechanismList(
+		CK_SLOT_ID slot,
+		CK_MECHANISM_TYPE_PTR mechanisms,
+		CK_ULONG_PTR count);
+
+CK_RV C_GetMechanismInfo(
+		CK_SLOT_ID slot,
+		CK_MECHANISM_TYPE type,
+		CK_MECHANISM_INFO_PTR info);
+
+CK_RV C_OpenSession(
+		CK_SLOT_ID slot,
+		CK_FLAGS flags,
+		CK_VOID_PTR cookie,
+		CK_NOTIFY callback,
+		CK_SESSION_HANDLE_PTR session);
+
+CK_RV C_CloseSession(
+		CK_SESSION_HANDLE session);
+
+CK_RV C_CloseAllSessions(
+		CK_SLOT_ID slot);
+
+CK_RV C_GetSessionInfo(
+		CK_SESSION_HANDLE session,
+		CK_SESSION_INFO_PTR info);
+
+CK_RV C_InitPIN(
+		CK_SESSION_HANDLE session,
+		CK_UTF8CHAR_PTR pin,
+		CK_ULONG pin_len);
+
+CK_RV C_SetPIN(
+		CK_SESSION_HANDLE session,
+		CK_UTF8CHAR_PTR old,
+		CK_ULONG old_len,
+		CK_UTF8CHAR_PTR new,
+		CK_ULONG new_len);
+
+CK_RV C_Login(
+		CK_SESSION_HANDLE session,
+		CK_USER_TYPE user_type,
+		CK_UTF8CHAR_PTR pin,
+		CK_ULONG pin_len);
+
+CK_RV C_Logout(
+		CK_SESSION_HANDLE session);
+
+CK_RV C_GetOperationState(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR state,
+		CK_ULONG_PTR state_len);
+
+CK_RV C_SetOperationState(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR state,
+		CK_ULONG state_len,
+		CK_OBJECT_HANDLE ciph_key,
+		CK_OBJECT_HANDLE auth_key);
+
+CK_RV C_CreateObject(
+		CK_SESSION_HANDLE session,
+		CK_ATTRIBUTE_PTR attribs,
+		CK_ULONG count,
+		CK_OBJECT_HANDLE_PTR obj);
+
+CK_RV C_CopyObject(
+		CK_SESSION_HANDLE session,
+		CK_OBJECT_HANDLE obj,
+		CK_ATTRIBUTE_PTR attribs,
+		CK_ULONG count,
+		CK_OBJECT_HANDLE_PTR new_obj);
+
+CK_RV C_DestroyObject(
+		CK_SESSION_HANDLE session,
+		CK_OBJECT_HANDLE obj);
+
+CK_RV C_GetObjectSize(
+		CK_SESSION_HANDLE session,
+		CK_OBJECT_HANDLE obj,
+		CK_ULONG_PTR out_size);
+
+CK_RV C_GetAttributeValue(
+		CK_SESSION_HANDLE session,
+		CK_OBJECT_HANDLE obj,
+		CK_ATTRIBUTE_PTR attribs,
+		CK_ULONG count);
+
+CK_RV C_SetAttributeValue(
+		CK_SESSION_HANDLE session,
+		CK_OBJECT_HANDLE obj,
+		CK_ATTRIBUTE_PTR attribs,
+		CK_ULONG count);
+
+CK_RV C_FindObjectsInit(
+		CK_SESSION_HANDLE session,
+		CK_ATTRIBUTE_PTR attribs,
+		CK_ULONG count);
+
+CK_RV C_FindObjects(
+		CK_SESSION_HANDLE session,
+		CK_OBJECT_HANDLE_PTR obj,
+		CK_ULONG max_count,
+		CK_ULONG_PTR count);
+
+CK_RV C_FindObjectsFinal(
+		CK_SESSION_HANDLE session);
+
+CK_RV C_EncryptInit(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_OBJECT_HANDLE key);
+
+CK_RV C_Encrypt(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_EncryptUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_EncryptFinal(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_DecryptInit(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR  mechanism,
+		CK_OBJECT_HANDLE  key);
+
+CK_RV C_Decrypt(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_DecryptUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_DecryptFinal(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_DigestInit(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR  mechanism);
+
+CK_RV C_Digest(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_DigestUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len);
+
+CK_RV C_DigestKey(
+		CK_SESSION_HANDLE session,
+		CK_OBJECT_HANDLE  key);
+
+CK_RV C_DigestFinal(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR digest,
+		CK_ULONG_PTR len);
+
+CK_RV C_SignInit(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_OBJECT_HANDLE key);
+
+CK_RV C_Sign(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_SignUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len);
+
+CK_RV C_SignFinal(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_SignRecoverInit(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR  mechanism,
+		CK_OBJECT_HANDLE  key);
+
+CK_RV C_SignRecover(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_VerifyInit(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_OBJECT_HANDLE key);
+
+CK_RV C_Verify(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR sign,
+		CK_ULONG sign_len);
+
+CK_RV C_VerifyUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len);
+
+CK_RV C_VerifyFinal(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR sign,
+		CK_ULONG sign_len);
+
+CK_RV C_VerifyRecoverInit(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_OBJECT_HANDLE key);
+
+CK_RV C_VerifyRecover(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_DigestEncryptUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_DecryptDigestUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_SignEncryptUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_DecryptVerifyUpdate(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len);
+
+CK_RV C_GenerateKey(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_ATTRIBUTE_PTR attribs,
+		CK_ULONG count,
+		CK_OBJECT_HANDLE_PTR new_key);
+
+CK_RV C_GenerateKeyPair(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_ATTRIBUTE_PTR pub_attribs,
+		CK_ULONG pub_count,
+		CK_ATTRIBUTE_PTR priv_attribs,
+		CK_ULONG priv_count,
+		CK_OBJECT_HANDLE_PTR pub_key,
+		CK_OBJECT_HANDLE_PTR priv_key);
+
+CK_RV C_WrapKey(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_OBJECT_HANDLE wrap_key,
+		CK_OBJECT_HANDLE key,
+		CK_BYTE_PTR wrapped_key,
+		CK_ULONG_PTR wrapped_key_len);
+
+CK_RV C_UnwrapKey(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_OBJECT_HANDLE unwrap_key,
+		CK_BYTE_PTR wrapped_key,
+		CK_ULONG wrapped_key_len,
+		CK_ATTRIBUTE_PTR attribs,
+		CK_ULONG count,
+		CK_OBJECT_HANDLE_PTR new_key);
+
+CK_RV C_DeriveKey(
+		CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR mechanism,
+		CK_OBJECT_HANDLE derived_key,
+		CK_ATTRIBUTE_PTR attribs,
+		CK_ULONG count,
+		CK_OBJECT_HANDLE_PTR new_key);
+
+CK_RV C_SeedRandom(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR seed,
+		CK_ULONG len);
+
+CK_RV C_GenerateRandom(
+		CK_SESSION_HANDLE session,
+		CK_BYTE_PTR out,
+		CK_ULONG len);
+
+CK_RV C_GetFunctionStatus(
+		CK_SESSION_HANDLE session);
+
+CK_RV C_CancelFunction(
+		CK_SESSION_HANDLE session);
+
+CK_RV C_WaitForSlotEvent(
+		CK_FLAGS flags,
+		CK_SLOT_ID_PTR slot,
+		CK_VOID_PTR rsv);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__PKCS11_H__*/
diff --git a/libsks/include/sks_ck_debug.h b/libsks/include/sks_ck_debug.h
new file mode 100644
index 0000000..68d49c0
--- /dev/null
+++ b/libsks/include/sks_ck_debug.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __SKS_CK_DEBUG_H
+#define __SKS_CK_DEBUG_H
+
+#include <pkcs11.h>
+
+/* Return a pointer to a string buffer of "CKA_xxx\0" attribute ID */
+const char *cka2str(CK_ATTRIBUTE_TYPE id);
+
+/* Return a pointer to a string buffer of "CKR_xxx\0" return value ID */
+const char *ckr2str(CK_RV id);
+
+/* Return a pointer to a string buffer of "CKM_xxx\0" mechanism ID */
+const char *ckm2str(CK_MECHANISM_TYPE id);
+
+/* Allocate and return a string descripbing the enabled flags */
+char *ck_slot_flag2str(CK_ULONG flags);
+char *ck_token_flag2str(CK_ULONG flags);
+char *ck_mecha_flag2str(CK_ULONG flags);
+
+const char *ckclass2str(CK_ULONG id);
+const char *cktype2str(CK_ULONG id, CK_ULONG class);
+
+const char *skscmd2str(unsigned int id);
+
+#endif /*__SKS_CK_DEBUG_H*/
diff --git a/libsks/include/sks_ta.h b/libsks/include/sks_ta.h
new file mode 100644
index 0000000..a11e9f5
--- /dev/null
+++ b/libsks/include/sks_ta.h
@@ -0,0 +1,1080 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#ifndef __SKS_TA_H__
+#define __SKS_TA_H__
+
+#include <sys/types.h>
+#include <stdint.h>
+
+/* SKS trusted application version information */
+#define SKS_VERSION_ID0		0
+#define SKS_VERSION_ID1		0
+
+/* Special values for ulong variables */
+#define SKS_UNAVAILABLE_INFORMATION	UINT32_MAX
+#define SKS_EFFECTIVELY_INFINITE	0
+
+/*
+ * SKS_CMD_PING		Acknowledge TA presence and return TA version info
+ *
+ * Optinal invocation parameter:
+ *
+ * [out]        memref[2] = [
+ *                      32bit version0 value,
+ *                      32bit version1 value
+ *              ]
+ */
+#define SKS_CMD_PING			0x00000000
+
+/*
+ * SKS_CMD_CK_SLOT_LIST - Get the table of the valid slot IDs
+ *
+ * [out]        memref[2] = 32bit array slot_ids[slot counts]
+ *
+ * The TA instance may represent several PKCS#11 slots and associated tokens.
+ * This command relates the PKCS#11 API function C_GetSlotList and return the
+ * valid IDs recognized by the trusted application.
+ */
+#define SKS_CMD_CK_SLOT_LIST		0x00000001
+
+/*
+ * SKS_CMD_CK_SLOT_INFO - Get cryptoki structured slot information
+ *
+ * [in]		memref[0] = 32bit slot ID
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = (struct sks_ck_slot_info)info
+ *
+ * The TA instance may represent several PKCS#11 slots and associated tokens.
+ * This command relates the PKCS#11 API function C_GetSlotInfo and return the
+ * information about the target slot.
+ */
+#define SKS_CMD_CK_SLOT_INFO		0x00000002
+
+#define SKS_SLOT_DESC_SIZE		64
+#define SKS_SLOT_MANUFACTURER_SIZE	32
+#define SKS_SLOT_VERSION_SIZE		2
+
+struct sks_slot_info {
+	uint8_t slotDescription[SKS_SLOT_DESC_SIZE];
+	uint8_t manufacturerID[SKS_SLOT_MANUFACTURER_SIZE];
+	uint32_t flags;
+	uint8_t hardwareVersion[SKS_SLOT_VERSION_SIZE];
+	uint8_t firmwareVersion[SKS_SLOT_VERSION_SIZE];
+};
+
+/*
+ * Values for sks_token_info::flags.
+ * SKS_CKFS_<x> corresponds to cryptoki flag CKF_<x> related to slot flags.
+ */
+#define SKS_CKFS_TOKEN_PRESENT		(1U << 0)
+#define SKS_CKFS_REMOVABLE_DEVICE	(1U << 1)
+#define SKS_CKFS_HW_SLOT		(1U << 2)
+
+/*
+ * SKS_CMD_CK_TOKEN_INFO - Get cryptoki structured token information
+ *
+ * [in]		memref[0] = 32bit slot ID
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = (struct sks_ck_token_info)info
+ *
+ * The TA instance may represent several PKCS#11 slots and associated tokens.
+ * This command relates the PKCS#11 API function C_GetTokenInfo and return the
+ * information about the target represented token.
+ */
+#define SKS_CMD_CK_TOKEN_INFO		0x00000003
+
+#define SKS_TOKEN_LABEL_SIZE		32
+#define SKS_TOKEN_MANUFACTURER_SIZE	32
+#define SKS_TOKEN_MODEL_SIZE		16
+#define SKS_TOKEN_SERIALNUM_SIZE	16
+
+struct sks_token_info {
+	uint8_t label[SKS_TOKEN_LABEL_SIZE];
+	uint8_t manufacturerID[SKS_TOKEN_MANUFACTURER_SIZE];
+	uint8_t model[SKS_TOKEN_MODEL_SIZE];
+	uint8_t serialNumber[SKS_TOKEN_SERIALNUM_SIZE];
+	uint32_t flags;
+	uint32_t ulMaxSessionCount;
+	uint32_t ulSessionCount;
+	uint32_t ulMaxRwSessionCount;
+	uint32_t ulRwSessionCount;
+	uint32_t ulMaxPinLen;
+	uint32_t ulMinPinLen;
+	uint32_t ulTotalPublicMemory;
+	uint32_t ulFreePublicMemory;
+	uint32_t ulTotalPrivateMemory;
+	uint32_t ulFreePrivateMemory;
+	uint8_t hardwareVersion[2];
+	uint8_t firmwareVersion[2];
+	uint8_t utcTime[16];
+};
+
+/*
+ * Values for sks_token_info::flags.
+ * SKS_CKFT_<x> corresponds to cryptoki CKF_<x> related to token flags.
+ */
+#define SKS_CKFT_RNG					(1U << 0)
+#define SKS_CKFT_WRITE_PROTECTED			(1U << 1)
+#define SKS_CKFT_LOGIN_REQUIRED				(1U << 2)
+#define SKS_CKFT_USER_PIN_INITIALIZED			(1U << 3)
+#define SKS_CKFT_RESTORE_KEY_NOT_NEEDED			(1U << 4)
+#define SKS_CKFT_CLOCK_ON_TOKEN				(1U << 5)
+#define SKS_CKFT_PROTECTED_AUTHENTICATION_PATH		(1U << 6)
+#define SKS_CKFT_DUAL_CRYPTO_OPERATIONS			(1U << 7)
+#define SKS_CKFT_TOKEN_INITIALIZED			(1U << 8)
+#define SKS_CKFT_USER_PIN_COUNT_LOW			(1U << 9)
+#define SKS_CKFT_USER_PIN_FINAL_TRY			(1U << 10)
+#define SKS_CKFT_USER_PIN_LOCKED			(1U << 11)
+#define SKS_CKFT_USER_PIN_TO_BE_CHANGED			(1U << 12)
+#define SKS_CKFT_SO_PIN_COUNT_LOW			(1U << 13)
+#define SKS_CKFT_SO_PIN_FINAL_TRY			(1U << 14)
+#define SKS_CKFT_SO_PIN_LOCKED				(1U << 15)
+#define SKS_CKFT_SO_PIN_TO_BE_CHANGED			(1U << 16)
+#define SKS_CKFT_ERROR_STATE				(1U << 17)
+
+/*
+ * SKS_CMD_CK_MECHANISM_IDS - Get list of the supported mechanisms
+ *
+ * [in]		memref[0] = 32bit slot ID
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = 32bit array mechanism IDs
+ *
+ * This commands relates to the PKCS#11 API function C_GetMechanismList.
+ */
+#define SKS_CMD_CK_MECHANISM_IDS	0x00000004
+
+/*
+ * SKS_CMD_CK_MECHANISM_INFO - Get information on a specific mechanism
+ *
+ * [in]		memref[0] = [
+ *			32bit slot ID,
+ *			32bit mechanism ID
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = (struct sks_mecha_info)info
+ *
+ * This commands relates to the PKCS#11 API function C_GetMechanismInfo.
+ */
+#define SKS_CMD_CK_MECHANISM_INFO	0x00000005
+
+struct sks_mechanism_info {
+	uint32_t min_key_size;
+	uint32_t max_key_size;
+	uint32_t flags;
+};
+
+/*
+ * Values for sks_mechanism_info::flags.
+ * SKS_CKFM_<x> strictly matches cryptoki CKF_<x> related to mechanism flags.
+ */
+#define SKS_CKFM_HW			(1U << 0)
+#define SKS_CKFM_ENCRYPT		(1U << 8)
+#define SKS_CKFM_DECRYPT		(1U << 9)
+#define SKS_CKFM_DIGEST			(1U << 10)
+#define SKS_CKFM_SIGN			(1U << 11)
+#define SKS_CKFM_SIGN_RECOVER		(1U << 12)
+#define SKS_CKFM_VERIFY			(1U << 13)
+#define SKS_CKFM_VERIFY_RECOVER		(1U << 14)
+#define SKS_CKFM_GENERATE		(1U << 15)
+#define SKS_CKFM_GENERATE_PAIR		(1U << 16)
+#define SKS_CKFM_WRAP			(1U << 17)
+#define SKS_CKFM_UNWRAP			(1U << 18)
+#define SKS_CKFM_DERIVE			(1U << 19)
+#define SKS_CKFM_EC_F_P			(1U << 20)
+#define SKS_CKFM_EC_F_2M		(1U << 21)
+#define SKS_CKFM_EC_ECPARAMETERS	(1U << 22)
+#define SKS_CKFM_EC_NAMEDCURVE		(1U << 23)
+#define SKS_CKFM_EC_UNCOMPRESS		(1U << 24)
+#define SKS_CKFM_EC_COMPRESS		(1U << 25)
+
+/*
+ * SKS_CMD_CK_INIT_TOKEN - Initialize PKCS#11 token
+ *
+ * [in]		memref[0] = [
+ *			32bit slot ID,
+ *			32bit PIN length,
+ *			8bit array PIN[PIN length],
+ *			8bit array label[32]
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_InitToken().
+ */
+#define SKS_CMD_CK_INIT_TOKEN		0x00000006
+
+/*
+ * SKS_CMD_CK_INIT_PIN - Initialize PKCS#11 token PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit PIN length,
+ *			8bit array PIN[PIN length]
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_InitPIN().
+ */
+#define SKS_CMD_CK_INIT_PIN		0x00000007
+
+/*
+ * SKS_CMD_CK_SET_PIN - Set PKCS#11 token PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit old_pin_length,
+ *			8bit array old_pin[old_pin_length],
+ *			32bit new_pin_length,
+ *			8bit array new_pin[new_pin_length]
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_SetPIN()
+ */
+#define SKS_CMD_CK_SET_PIN		0x00000008
+
+/*
+ * SKS_CMD_CK_OPEN_RO_SESSION - Open read-only session
+ *
+ * [in]		memref[0] = 32bit slot ID
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[0] = 32bit session handle
+ *
+ * This commands relates to the PKCS#11 API function C_OpenSession() for a
+ * read-only session.
+ */
+#define SKS_CMD_CK_OPEN_RO_SESSION	0x00000009
+
+/*
+ * SKS_CMD_CK_OPEN_RW_SESSION - Open read/write session
+ *
+ * [in]		memref[0] = 32bit slot
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[0] = 32bit session handle
+ *
+ * This commands relates to the PKCS#11 API function C_OpenSession() for a
+ * read/Write session.
+ */
+#define SKS_CMD_CK_OPEN_RW_SESSION	0x0000000a
+
+/*
+ * SKS_CMD_CK_CLOSE_SESSION - Close an opened session
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_CloseSession().
+ */
+#define SKS_CMD_CK_CLOSE_SESSION	0x0000000b
+
+/*
+ * SKS_CMD_CK_SESSION_INFO - Get Cryptoki information on a session
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = (struct sks_ck_session_info)info
+ *
+ * This commands relates to the PKCS#11 API function C_GetSessionInfo().
+ */
+#define SKS_CMD_CK_SESSION_INFO		0x0000000c
+
+struct sks_session_info {
+	uint32_t slot_id;
+	uint32_t state;
+	uint32_t flags;
+	uint32_t error_code;
+};
+
+/*
+ * SKS_CMD_CK_CLOSE_ALL_SESSIONS - Close all client sessions on slot/token
+ *
+ * [in]		memref[0] = 32bit slot
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_CloseAllSessions().
+ */
+#define SKS_CMD_CK_CLOSE_ALL_SESSIONS	0x0000000d
+
+/*
+ * SKS_CMD_IMPORT_OBJECT - Import a raw object in the session or token
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit object handle
+ *
+ * This commands relates to the PKCS#11 API function C_CreateObject().
+ */
+#define SKS_CMD_IMPORT_OBJECT		0x0000000e
+
+/**
+ * Serialization of object attributes
+ */
+
+/*
+ * sks_object_head - Header of object whose data are serialized in memory
+ *
+ * An object in made of several attributes. Attributes are store one next to
+ * the other with byte alignment as serialized byte arrays. Appended
+ * attributes byte arrays are prepend with this header structure that
+ * defines the number of attribute items and the overall byte size of the
+ * attrs byte array.
+ *
+ * @attrs_size - byte size of whole byte array attrs[]
+ * @attrs_count - number of attribute items stored in attrs[]
+ * @attrs - then starts the attributes data
+ */
+struct sks_object_head {
+	uint32_t attrs_size;
+	uint32_t attrs_count;
+	uint8_t attrs[];
+};
+
+/*
+ * Attribute reference in the TA ABI. Each attribute start with the header
+ * structure followed by the attribute value, its byte size being defined
+ * in the attribute header.
+ *
+ * @id - the 32bit identificator of the attribute, see SKS_CKA_<x>
+ * @size - the 32bit value attribute byte size
+ * @data - then starts the attribute value
+ */
+struct sks_attribute_head {
+	uint32_t id;
+	uint32_t size;
+	uint8_t data[];
+};
+
+/*
+ * SKS_CMD_DESTROY_OBJECT - Destroy an object
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit object handle
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_DestroyObject().
+ */
+#define SKS_CMD_DESTROY_OBJECT		0x0000000f
+
+/*
+ * SKS_CMD_ENCRYPT_INIT - Initialize enryption processing
+ * SKS_CMD_DECRYPT_INIT - Initialize decryption processing
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * These commands relate to the PKCS#11 API functions C_EncryptInit() and
+ * C_DecryptInit.
+ */
+#define SKS_CMD_ENCRYPT_INIT		0x00000010
+#define SKS_CMD_DECRYPT_INIT		0x00000011
+
+/*
+ * SKS_CMD_ENCRYPT_UPDATE - Update encryption processing
+ * SKS_CMD_DECRYPT_UPDATE - Update decryption processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [in]		memref[1] = input data to be processed
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = output processed data
+ *
+ * These commands relate to the PKCS#11 API functions C_EncryptUpdate() and
+ * C_DecryptUpdate.
+ */
+#define SKS_CMD_ENCRYPT_UPDATE		0x00000012
+#define SKS_CMD_DECRYPT_UPDATE		0x00000013
+
+/*
+ * SKS_CMD_ENCRYPT_FINAL - Finalize encryption processing
+ * SKS_CMD_DECRYPT_FINAL - Finalize decryption processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = output processed data
+ *
+ * These commands relate to the PKCS#11 API functions C_EncryptFinal() and
+ * C_DecryptFinal.
+ */
+#define SKS_CMD_ENCRYPT_FINAL		0x00000014
+#define SKS_CMD_DECRYPT_FINAL		0x00000015
+
+/*
+ * SKS_CMD_GENERATE_SYMM_KEY - Generate a symmetric key
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit key handle
+ *
+ * This command relates to the PKCS#11 API functions C_GenerateKey().
+ */
+#define SKS_CMD_GENERATE_SYMM_KEY	0x00000016
+
+/*
+ * SKS_CMD_SIGN_INIT - Initialize a signature computation processing
+ * SKS_CMD_VERIFY_INIT - Initialize a signature verification processing
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit key handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters,
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * These commands relate to the PKCS#11 API functions C_SignInit() and
+ * C_VerifyInit.
+ */
+#define SKS_CMD_SIGN_INIT		0x00000017
+#define SKS_CMD_VERIFY_INIT		0x00000018
+
+/*
+ * SKS_CMD_SIGN_UPDATE - Update a signature computation processing
+ * SKS_CMD_VERIFY_UPDATE - Update a signature verification processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [in]		memref[1] = input data to be processed
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * These commands relate to the PKCS#11 API functions C_SignUpdate() and
+ * C_VerifyUpdate.
+ */
+#define SKS_CMD_SIGN_UPDATE		0x00000019
+#define SKS_CMD_VERIFY_UPDATE		0x0000001a
+
+/*
+ * SKS_CMD_SIGN_FINAL - Finalize a signature computation processing
+ * SKS_CMD_VERIFY_FINAL - Finalize a signature verification processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = output processed data
+ *
+ * These commands relate to the PKCS#11 API functions C_SignFinal() and
+ * C_VerifyFinal.
+ */
+#define SKS_CMD_SIGN_FINAL		0x0000001b
+#define SKS_CMD_VERIFY_FINAL		0x0000001c
+
+/*
+ * SKS_CMD_FIND_OBJECTS_INIT - Initialize a objects search
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This command relates to the PKCS#11 API function C_FindOjectsInit().
+ */
+#define SKS_CMD_FIND_OBJECTS_INIT	0x0000001d
+
+/*
+ * SKS_CMD_FIND_OBJECTS - Get handles of matching objects
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit array object_handle_array[N]
+ *
+ * This command relates to the PKCS#11 API function C_FindOjects().
+ * The size of object_handle_array depends output buffer size
+ * provided by the client.
+ */
+#define SKS_CMD_FIND_OBJECTS		0x0000001e
+
+/*
+ * SKS_CMD_FIND_OBJECTS_FINAL - Finalize current objects search
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This command relates to the PKCS#11 API function C_FindOjectsFinal().
+ */
+#define SKS_CMD_FIND_OBJECTS_FINAL	0x0000001f
+
+/*
+ * SKS_CMD_GET_OBJECT_SIZE - Get size used by object in the TEE
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit key handle
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit object_byte_size
+ */
+#define SKS_CMD_GET_OBJECT_SIZE		0x00000020
+
+/*
+ * SKS_CMD_GET_ATTRIBUTE_VALUE - Get the value of object attribute(s)
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit object handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = (struct sks_object_head)attribs + attributes data
+ */
+#define SKS_CMD_GET_ATTRIBUTE_VALUE	0x00000021
+
+/*
+ * SKS_CMD_SET_ATTRIBUTE_VALUE - Set the value for object attribute(s)
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit object handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = (struct sks_object_head)attribs + attributes data
+ */
+#define SKS_CMD_SET_ATTRIBUTE_VALUE	0x00000022
+
+/*
+ * SKS_CMD_DERIVE_KEY - Derive a key from already provisioned parent key
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters,
+ *			32bit key handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit object handle
+ */
+#define SKS_CMD_DERIVE_KEY		0x00000023
+
+/*
+ * SKS_CMD_INIT_PIN - Initialize user PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit PIN byte size,
+ *			byte arrays: PIN data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ */
+#define SKS_CMD_INIT_PIN		0x00000024
+
+/*
+ * SKS_CMD_SET_PIN - Change user PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit old PIN byte size,
+ *			byte arrays: PIN data
+ *			32bit new PIN byte size,
+ *			byte arrays: new PIN data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ */
+#define SKS_CMD_SET_PIN			0x00000025
+
+/*
+ * SKS_CMD_LOGIN - Initialize user PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit user identifier,
+ *			32bit PIN byte size,
+ *			byte arrays: PIN data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ */
+#define SKS_CMD_LOGIN			0x00000026
+
+/*
+ * Values for user identifier parameter in SKS_CMD_LOGIN
+ */
+#define SKS_CKU_SO			0x000
+#define SKS_CKU_USER			0x001
+#define SKS_CKU_CONTEXT_SPECIFIC	0x002
+
+/*
+ * SKS_CMD_LOGOUT - Log out from token
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit PIN byte size,
+ *			byte array: PIN data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ */
+#define SKS_CMD_LOGOUT			0x00000027
+
+/*
+ * SKS_CMD_GENERATE_KEY_PAIR - Generate an asymmetric key pair
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters,
+ *			(struct sks_object_head)pubkey_attribs + attributes data
+ *			(struct sks_object_head)privkeyattribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = [
+ *			32bit public key handle,
+ *			32bit prive key handle
+ *		]
+ *
+ * This command relates to the PKCS#11 API functions C_GenerateKeyPair().
+ */
+#define SKS_CMD_GENERATE_KEY_PAIR	0x00000028
+
+/*
+ * SKS_CMD_ENCRYPT_ONESHOT - Update and finalize encryption processing
+ * SKS_CMD_DECRYPT_ONESHOT - Update and finalize decryption processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [in]		memref[1] = input data to be processed
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = output processed data
+ *
+ * These commands relate to the PKCS#11 API functions C_EncryptUpdate() and
+ * C_DecryptUpdate.
+ */
+#define SKS_CMD_ENCRYPT_ONESHOT		0x00000029
+#define SKS_CMD_DECRYPT_ONESHOT		0x0000002a
+
+/*
+ * SKS_CMD_SIGN_ONESHOT - Update and finalize a signature computation
+ * SKS_CMD_VERIFY_ONESHOT - Update and finalize a signature verification
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [in]		memref[1] = input data to be processed
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * These commands relate to the PKCS#11 API functions C_SignUpdate() and
+ * C_VerifyUpdate.
+ */
+#define SKS_CMD_SIGN_ONESHOT		0x0000002b
+#define SKS_CMD_VERIFY_ONESHOT		0x0000002c
+
+/*
+ * Command return codes
+ * SKS_CKR_<x> relates cryptoki CKR_<x> in meaning if not in value.
+ */
+#define SKS_CKR_OK				0x00000000
+#define SKS_CKR_GENERAL_ERROR			0x00000001
+#define SKS_CKR_DEVICE_MEMORY			0x00000002
+#define SKS_CKR_ARGUMENTS_BAD			0x00000003
+#define SKS_CKR_BUFFER_TOO_SMALL		0x00000004
+#define SKS_CKR_FUNCTION_FAILED			0x00000005
+#define SKS_CKR_SIGNATURE_INVALID		0x00000007
+#define SKS_CKR_ATTRIBUTE_TYPE_INVALID		0x00000008
+#define SKS_CKR_ATTRIBUTE_VALUE_INVALID		0x00000009
+#define SKS_CKR_OBJECT_HANDLE_INVALID		0x0000000a
+#define SKS_CKR_KEY_HANDLE_INVALID		0x0000000b
+#define SKS_CKR_MECHANISM_INVALID		0x0000000c
+#define SKS_CKR_SESSION_HANDLE_INVALID		0x0000000d
+#define SKS_CKR_SLOT_ID_INVALID			0x0000000e
+#define SKS_CKR_MECHANISM_PARAM_INVALID		0x0000000f
+#define SKS_CKR_TEMPLATE_INCONSISTENT		0x00000010
+#define SKS_CKR_TEMPLATE_INCOMPLETE		0x00000011
+#define SKS_CKR_PIN_INCORRECT			0x00000012
+#define SKS_CKR_PIN_LOCKED			0x00000013
+#define SKS_CKR_PIN_EXPIRED			0x00000014
+#define SKS_CKR_PIN_INVALID			0x00000015
+#define SKS_CKR_PIN_LEN_RANGE			0x00000016
+#define SKS_CKR_SESSION_EXISTS			0x00000017
+#define SKS_CKR_SESSION_READ_ONLY		0x00000018
+#define SKS_CKR_SESSION_READ_WRITE_SO_EXISTS	0x00000019
+#define SKS_CKR_OPERATION_ACTIVE		0x0000001a
+#define SKS_CKR_KEY_FUNCTION_NOT_PERMITTED	0x0000001b
+#define SKS_CKR_OPERATION_NOT_INITIALIZED	0x0000001c
+#define SKS_CKR_TOKEN_WRITE_PROTECTED		0x0000001d
+#define SKS_CKR_TOKEN_NOT_PRESENT		0x0000001e
+#define SKS_CKR_TOKEN_NOT_RECOGNIZED		0x0000001f
+#define SKS_CKR_ACTION_PROHIBITED		0x00000020
+#define SKS_CKR_ATTRIBUTE_READ_ONLY		0x00000021
+#define SKS_CKR_PIN_TOO_WEAK			0x00000022
+#define SKS_CKR_CURVE_NOT_SUPPORTED		0x00000023
+#define SKS_CKR_DOMAIN_PARAMS_INVALID		0x00000024
+#define SKS_CKR_USER_ALREADY_LOGGED_IN		0x00000025
+#define SKS_CKR_USER_ANOTHER_ALREADY_LOGGED_IN	0x00000026
+#define SKS_CKR_USER_NOT_LOGGED_IN		0x00000027
+#define SKS_CKR_USER_PIN_NOT_INITIALIZED	0x00000028
+#define SKS_CKR_USER_TOO_MANY_TYPES		0x00000029
+#define SKS_CKR_USER_TYPE_INVALID		0x0000002a
+#define SKS_CKR_SESSION_READ_ONLY_EXISTS	0x0000002b
+#define SKS_CKR_KEY_SIZE_RANGE			0x0000002c
+#define SKS_CKR_ATTRIBUTE_SENSITIVE		0x0000002d
+#define SKS_CKR_SIGNATURE_LEN_RANGE		0x0000002e
+#define SKS_CKR_KEY_TYPE_INCONSISTENT		0x0000002f
+#define SKS_CKR_DATA_LEN_RANGE			0x00000030
+#define SKS_CKR_ENCRYPTED_DATA_LEN_RANGE	0x00000031
+
+/* Status without strict equivalence in Cryptoki API */
+#define SKS_NOT_FOUND				0x00001000
+#define SKS_NOT_IMPLEMENTED			0x00001001
+
+/* Attribute specific values */
+#define SKS_CK_UNAVAILABLE_INFORMATION		((uint32_t)0xFFFFFFFF)
+#define SKS_UNDEFINED_ID			SKS_CK_UNAVAILABLE_INFORMATION
+#define SKS_FALSE				0
+#define SKS_TRUE				1
+
+/*
+ * Attribute identificators
+ * Valid values for struct sks_attribute_head::id
+ *
+ * SKS_ATTR_<x> corresponds to cryptoki CKA_<x>.
+ * Value range [0 63] is reserved to boolean value attributes.
+ */
+#define SKS_BOOLPROPS_BASE			0x00000000
+#define SKS_CKA_TOKEN				0x00000000
+#define SKS_CKA_PRIVATE				0x00000001
+#define SKS_CKA_TRUSTED				0x00000002
+#define SKS_CKA_SENSITIVE			0x00000003
+#define SKS_CKA_ENCRYPT				0x00000004
+#define SKS_CKA_DECRYPT				0x00000005
+#define SKS_CKA_WRAP				0x00000006
+#define SKS_CKA_UNWRAP				0x00000007
+#define SKS_CKA_SIGN				0x00000008
+#define SKS_CKA_SIGN_RECOVER			0x00000009
+#define SKS_CKA_VERIFY				0x0000000a
+#define SKS_CKA_VERIFY_RECOVER			0x0000000b
+#define SKS_CKA_DERIVE				0x0000000c
+#define SKS_CKA_EXTRACTABLE			0x0000000d
+#define SKS_CKA_LOCAL				0x0000000e
+#define SKS_CKA_NEVER_EXTRACTABLE		0x0000000f
+#define SKS_CKA_ALWAYS_SENSITIVE		0x00000010
+#define SKS_CKA_MODIFIABLE			0x00000011
+#define SKS_CKA_COPYABLE			0x00000012
+#define SKS_CKA_DESTROYABLE			0x00000013
+#define SKS_CKA_ALWAYS_AUTHENTICATE		0x00000014
+#define SKS_CKA_WRAP_WITH_TRUSTED		0x00000015
+/* Last boolean properity ID (value is 63) is reserved */
+#define SKS_BOOLPROPS_LAST			SKS_CKA_WRAP_WITH_TRUSTED
+#define SKS_BOOLPROPS_END			0x0000003F
+#define SKS_BOOLPROPH_FLAG			BIT(31)
+
+#define SKS_CKA_LABEL				0x00000040
+#define SKS_CKA_VALUE				0x00000041
+#define SKS_CKA_VALUE_LEN			0x00000042
+#define SKS_CKA_WRAP_TEMPLATE			0x00000043
+#define SKS_CKA_UNWRAP_TEMPLATE			0x00000044
+#define SKS_CKA_DERIVE_TEMPLATE			0x00000045
+#define SKS_CKA_START_DATE			0x00000046
+#define SKS_CKA_END_DATE			0x00000047
+#define SKS_CKA_OBJECT_ID			0x00000048
+#define SKS_CKA_APPLICATION			0x00000049
+#define SKS_CKA_MECHANISM_TYPE			0x0000004a
+#define SKS_CKA_ID				0x0000004b
+#define SKS_CKA_ALLOWED_MECHANISMS		0x0000004c
+#define SKS_CKA_CLASS				0x0000004d
+#define SKS_CKA_KEY_TYPE			0x0000004e
+#define SKS_CKA_EC_POINT			0x0000004f
+#define SKS_CKA_EC_PARAMS			0x00000050
+#define SKS_CKA_MODULUS				0x00000051
+#define SKS_CKA_MODULUS_BITS			0x00000052
+#define SKS_CKA_PUBLIC_EXPONENT			0x00000053
+#define SKS_CKA_PRIVATE_EXPONENT		0x00000054
+#define SKS_CKA_PRIME_1				0x00000055
+#define SKS_CKA_PRIME_2				0x00000056
+#define SKS_CKA_EXPONENT_1			0x00000057
+#define SKS_CKA_EXPONENT_2			0x00000058
+#define SKS_CKA_COEFFICIENT			0x00000059
+#define SKS_CKA_SUBJECT				0x0000005a
+#define SKS_CKA_PUBLIC_KEY_INFO			0x0000005b
+#define SKS_CKA_CERTIFICATE_TYPE		0x0000005c
+#define SKS_CKA_CERTIFICATE_CATEGORY		0x0000005d
+#define SKS_CKA_ISSUER				0x0000005e
+#define SKS_CKA_SERIAL_NUMBER			0x0000005f
+#define SKS_CKA_URL				0x00000060
+#define SKS_CKA_HASH_OF_SUBJECT_PUBLIC_KEY	0x00000061
+#define SKS_CKA_HASH_OF_ISSUER_PUBLIC_KEY	0x00000062
+#define SKS_CKA_NAME_HASH_ALGORITHM		0x00000063
+#define SKS_CKA_KEY_GEN_MECHANISM		0x00000064
+
+/*
+ * Valid values for attribute SKS_CKA_CLASS
+ * SKS_CKO_<x> corresponds to cryptoki CKO_<x>.
+ */
+#define SKS_CKO_SECRET_KEY			0x000
+#define SKS_CKO_PUBLIC_KEY			0x001
+#define SKS_CKO_PRIVATE_KEY			0x002
+#define SKS_CKO_OTP_KEY				0x003
+#define SKS_CKO_CERTIFICATE			0x004
+#define SKS_CKO_DATA				0x005
+#define SKS_CKO_DOMAIN_PARAMETERS		0x006
+#define SKS_CKO_HW_FEATURE			0x007
+#define SKS_CKO_MECHANISM			0x008
+
+/*
+ * Valid values for attribute SKS_CKA_KEY_TYPE
+ * SKS_CKK_<x> corresponds to cryptoki CKK_<x> related to symmetric keys
+ */
+#define SKS_CKK_AES				0x000
+#define SKS_CKK_GENERIC_SECRET			0x001
+#define SKS_CKK_MD5_HMAC			0x002
+#define SKS_CKK_SHA_1_HMAC			0x003
+#define SKS_CKK_SHA224_HMAC			0x004
+#define SKS_CKK_SHA256_HMAC			0x005
+#define SKS_CKK_SHA384_HMAC			0x006
+#define SKS_CKK_SHA512_HMAC			0x007
+#define SKS_CKK_EC				0x008
+#define SKS_CKK_RSA				0x009
+#define SKS_CKK_DSA				0x00a
+#define SKS_CKK_DH				0x00b
+#define SKS_CKK_DES				0x00c
+#define SKS_CKK_DES2				0x00d
+#define SKS_CKK_DES3				0x00e
+
+/*
+ * Valid values for attribute SKS_CKA_CERTIFICATE_TYPE
+ * SKS_CKC_<x> corresponds to cryptoki CKC_<x>.
+ */
+#define SKS_CKC_X_509			0x000
+#define SKS_CKC_X_509_ATTR_CER		0x001
+#define SKS_CKC_WTLS			0x002
+
+/*
+ * Valid values for attribute SKS_CKA_MECHANISM_TYPE
+ * SKS_CKM_<x> corresponds to cryptoki CKM_<x>.
+ */
+#define SKS_CKM_AES_ECB				0x000
+#define SKS_CKM_AES_CBC				0x001
+#define SKS_CKM_AES_CBC_PAD			0x002
+#define SKS_CKM_AES_CTS				0x003
+#define SKS_CKM_AES_CTR				0x004
+#define SKS_CKM_AES_GCM				0x005
+#define SKS_CKM_AES_CCM				0x006
+#define SKS_CKM_AES_GMAC			0x007
+#define SKS_CKM_AES_CMAC			0x008
+#define SKS_CKM_AES_CMAC_GENERAL		0x009
+#define SKS_CKM_AES_ECB_ENCRYPT_DATA		0x00a
+#define SKS_CKM_AES_CBC_ENCRYPT_DATA		0x00b
+#define SKS_CKM_AES_KEY_GEN			0x00c
+#define SKS_CKM_GENERIC_SECRET_KEY_GEN		0x00d
+#define SKS_CKM_MD5_HMAC			0x00e
+#define SKS_CKM_SHA_1_HMAC			0x00f
+#define SKS_CKM_SHA224_HMAC			0x010
+#define SKS_CKM_SHA256_HMAC			0x011
+#define SKS_CKM_SHA384_HMAC			0x012
+#define SKS_CKM_SHA512_HMAC			0x013
+#define SKS_CKM_AES_XCBC_MAC			0x014
+#define SKS_CKM_EC_KEY_PAIR_GEN			0x015
+#define SKS_CKM_ECDSA				0x016
+#define SKS_CKM_ECDSA_SHA1			0x017
+#define SKS_CKM_ECDSA_SHA224			0x018	/* /!\ CK !PKCS#11 */
+#define SKS_CKM_ECDSA_SHA256			0x019	/* /!\ CK !PKCS#11 */
+#define SKS_CKM_ECDSA_SHA384			0x01a	/* /!\ CK !PKCS#11 */
+#define SKS_CKM_ECDSA_SHA512			0x01b	/* /!\ CK !PKCS#11 */
+#define SKS_CKM_ECDH1_DERIVE			0x01c
+#define SKS_CKM_ECDH1_COFACTOR_DERIVE		0x01d
+#define SKS_CKM_ECMQV_DERIVE			0x01e
+#define SKS_CKM_ECDH_AES_KEY_WRAP		0x01f
+#define SKS_CKM_RSA_PKCS_KEY_PAIR_GEN		0x020
+#define SKS_CKM_RSA_PKCS			0x021
+#define SKS_CKM_RSA_9796			0x022
+#define SKS_CKM_RSA_X_509			0x023
+#define SKS_CKM_SHA1_RSA_PKCS			0x024
+#define SKS_CKM_RSA_PKCS_OAEP			0x025
+#define SKS_CKM_SHA1_RSA_PKCS_PSS		0x026
+#define SKS_CKM_SHA256_RSA_PKCS			0x027
+#define SKS_CKM_SHA384_RSA_PKCS			0x028
+#define SKS_CKM_SHA512_RSA_PKCS			0x029
+#define SKS_CKM_SHA256_RSA_PKCS_PSS		0x02a
+#define SKS_CKM_SHA384_RSA_PKCS_PSS		0x02b
+#define SKS_CKM_SHA512_RSA_PKCS_PSS		0x02c
+#define SKS_CKM_SHA224_RSA_PKCS			0x02d
+#define SKS_CKM_SHA224_RSA_PKCS_PSS		0x02e
+#define SKS_CKM_RSA_AES_KEY_WRAP		0x02f
+#define SKS_CKM_RSA_PKCS_PSS			0x030
+#define SKS_CKM_MD5				0x031
+#define SKS_CKM_SHA_1				0x032
+#define SKS_CKM_SHA224				0x033
+#define SKS_CKM_SHA256				0x034
+#define SKS_CKM_SHA384				0x035
+#define SKS_CKM_SHA512				0x036
+#define SKS_CKM_DH_PKCS_DERIVE			0x037
+#define SKS_CKM_DES_KEY_GEN			0x038
+#define SKS_CKM_DES_ECB			0x039
+#define SKS_CKM_DES_CBC			0x040
+#define SKS_CKM_DES_MAC			0x041
+#define SKS_CKM_DES_MAC_GENERAL		0x042
+#define SKS_CKM_DES_CBC_PAD			0x043
+
+/* SKS added IDs for operation without cryptoki mechanism ID defined */
+#define SKS_PROCESSING_IMPORT			0x1000
+#define SKS_PROCESSING_COPY			0x1001
+
+/*
+ * Valid values key differentiation function identifiers
+ * SKS_CKD_<x> reltaes to cryptoki CKD_<x>.
+ */
+#define SKS_CKD_NULL				0x0000UL
+#define SKS_CKD_SHA1_KDF			0x0001UL
+#define SKS_CKD_SHA1_KDF_ASN1			0x0002UL
+#define SKS_CKD_SHA1_KDF_CONCATENATE		0x0003UL
+#define SKS_CKD_SHA224_KDF			0x0004UL
+#define SKS_CKD_SHA256_KDF			0x0005UL
+#define SKS_CKD_SHA384_KDF			0x0006UL
+#define SKS_CKD_SHA512_KDF			0x0007UL
+#define SKS_CKD_CPDIVERSIFY_KDF			0x0008UL
+
+/*
+ * Valid values MG function identifiers
+ * SKS_CKG_<x> reltaes to cryptoki CKG_<x>.
+ */
+#define SKS_CKG_MGF1_SHA1			0x0001UL
+#define SKS_CKG_MGF1_SHA224			0x0005UL
+#define SKS_CKG_MGF1_SHA256			0x0002UL
+#define SKS_CKG_MGF1_SHA384			0x0003UL
+#define SKS_CKG_MGF1_SHA512			0x0004UL
+
+/*
+ * Valid values for RSA PKCS/OAEP source type identifier
+ * SKS_CKZ_<x> reltaes to cryptoki CKZ_<x>.
+ */
+#define SKS_CKZ_DATA_SPECIFIED			0x0001UL
+
+/*
+ * Processing parameters
+ *
+ * These can hardly be described by ANSI-C structures since the byte size of
+ * some fields of the structure are specified by a previous field in the
+ * structure. Therefore the format of the parameter binary data for each
+ * supported processing is defined here from this comment rather than using
+ * C structures.
+ *
+ * Processing parameters are used as argument the C_EncryptInit and friends
+ * using the struct sks_attribute_head format where field 'type' is the SKS
+ * processing ID and field 'size' is the parameter byte size. Below is shown
+ * the head structure struct sks_attribute_head fields and the trailling data
+ * that are the effective parameters binary blob for the target
+ * processing/mechanism.
+ *
+ * AES ECB
+ *   head:	32bit: type = SKS_CKM_AES_ECB
+ *		32bit: params byte size = 0
+ *
+ * AES CBC, CBC_NOPAD and CTS
+ *   head:	32bit: type = SKS_CKM_AES_CBC
+ *			  or SKS_CKM_AES_CBC_PAD
+ *			  or SKS_CKM_AES_CTS
+ *		32bit: params byte size = 16
+ *  params:	16byte: IV
+ *
+ * AES CTR, params relates to struct CK_AES_CTR_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_CTR
+ *		32bit: params byte size = 20
+ *  params:	32bit: counter bit increment
+ *		16byte: IV
+ *
+ * AES GCM, params relates to struct CK_AES_GCM_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_GCM
+ *		32bit: params byte size
+ *  params:	32bit: IV_byte_size
+ *		byte array: IV (IV_byte_size bytes)
+ *		32bit: AAD_byte_size
+ *		byte array: AAD data (AAD_byte_size bytes)
+ *		32bit: tag bit size
+ *
+ * AES CCM, params relates to struct CK_AES_CCM_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_CCM
+ *		32bit: params byte size
+ *  params:	32bit: data_byte_size
+ *		32bit: nonce_byte_size
+ *		byte array: nonce data (nonce_byte_size bytes)
+ *		32bit: AAD_byte_size
+ *		byte array: AAD data (AAD_byte_size bytes)
+ *		32bit: MAC byte size
+ *
+ * AES GMAC
+ *   head:	32bit: type = SKS_CKM_AES_GMAC
+ *		32bit: params byte size = 12
+ *  params:	12byte: IV
+ *
+ * AES CMAC with general length, params relates to struct CK_MAC_GENERAL_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_CMAC_GENERAL
+ *		32bit: params byte size = 12
+ *  params:	32bit: byte size of the output CMAC data
+ *
+ * AES CMAC fixed size (16byte CMAC)
+ *   head:	32bit: type = SKS_CKM_AES_CMAC_GENERAL
+ *		32bit: size = 0
+ *
+ * AES derive by ECB, params relates to struct CK_KEY_DERIVATION_STRING_DATA.
+ *   head:	32bit: type = SKS_CKM_AES_ECB_ENCRYPT_DATA
+ *		32bit: params byte size
+ *  params:	32bit: byte size of the data to encrypt
+ *		byte array: data to encrypt
+ *
+ * AES derive by CBC, params relates to struct CK_AES_CBC_ENCRYPT_DATA_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_CBC_ENCRYPT_DATA
+ *		32bit: params byte size
+ *  params:	16byte: IV
+ *		32bit: byte size of the data to encrypt
+ *		byte array: data to encrypt
+ *
+ * AES and generic secret generation
+ *   head:	32bit: type = SKS_CKM_AES_KEY_GEN
+ *			   or SKS_CKM_GENERIC_SECRET_KEY_GEN
+ *		32bit: size = 0
+ *
+ * ECDH, params relates to struct CK_ECDH1_DERIVE_PARAMS.
+ *   head:	32bit: type = SKS_CKM_ECDH1_DERIVE
+ *			   or SKS_CKM_ECDH1_COFACTOR_DERIVE
+ *		32bit: params byte size
+ *  params:	32bit: key derivation function (SKS_CKD_xxx)
+ *		32bit: byte size of the shared data
+ *		byte array: shared data
+ *		32bit: byte: size of the public data
+ *		byte array: public data
+ *
+ * AES key wrap by ECDH, params relates to struct CK_ECDH_AES_KEY_WRAP_PARAMS.
+ *   head:	32bit: type = SKS_CKM_ECDH_AES_KEY_WRAP
+ *		32bit: params byte size
+ *  params:	32bit: bit size of the AES key
+ *		32bit: key derivation function (SKS_CKD_xxx)
+ *		32bit: byte size of the shared data
+ *		byte array: shared data
+ *
+ * RSA_PKCS (pre-hashed payload)
+ *   head:	32bit: type = SKS_CKM_RSA_PKCS
+ *		32bit: size = 0
+ *
+ * RSA PKCS OAEP, params relates to struct CK_RSA_PKCS_OAEP_PARAMS.
+ *   head:	32bit: type = SKS_CKM_RSA_PKCS_OAEP
+ *		32bit: params byte size
+ *  params:	32bit: hash algorithm identifier (SKS_CK_M_xxx)
+ *		32bit: CK_RSA_PKCS_MGF_TYPE
+ *		32bit: CK_RSA_PKCS_OAEP_SOURCE_TYPE
+ *		32bit: byte size of the source data
+ *		byte array: source data
+ *
+ * RSA PKCS PSS, params relates to struct CK_RSA_PKCS_PSS_PARAMS.
+ *   head:	32bit: type = SKS_CKM_RSA_PKCS_PSS
+ *			   or SKS_CKM_SHA256_RSA_PKCS_PSS
+ *			   or SKS_CKM_SHA384_RSA_PKCS_PSS
+ *			   or SKS_CKM_SHA512_RSA_PKCS_PSS
+ *		32bit: params byte size
+ *  params:	32bit: hash algorithm identifier (SKS_CK_M_xxx)
+ *		32bit: CK_RSA_PKCS_MGF_TYPE
+ *		32bit: byte size of the salt in the PSS encoding
+ *
+ * AES key wrapping by RSA, params relates to struct CK_RSA_AES_KEY_WRAP_PARAMS.
+ *   head:	32bit: type = CKM_RSA_AES_KEY_WRAP
+ *		32bit: params byte size
+ *  params:	32bit: bit size of the AES key
+ *		32bit: hash algorithm identifier (SKS_CK_M_xxx)
+ *		32bit: CK_RSA_PKCS_MGF_TYPE
+ *		32bit: CK_RSA_PKCS_OAEP_SOURCE_TYPE
+ *		32bit: byte size of the source data
+ *		byte array: source data
+ */
+
+#endif /*__SKS_TA_H__*/
diff --git a/libsks/src/ck_debug.c b/libsks/src/ck_debug.c
new file mode 100644
index 0000000..0637e12
--- /dev/null
+++ b/libsks/src/ck_debug.c
@@ -0,0 +1,678 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <sks_ta.h>
+#include <sks_ck_debug.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "local_utils.h"
+
+#define CK2STR_ENTRY(label)	{ .id = label, .string = #label }
+
+struct ck2str {
+	CK_ULONG id;
+	const char *string;
+};
+
+/*
+ * Return a pointer to a string buffer of "CKA_xxx\0" attribute ID
+ */
+static struct ck2str cka2str_table[] = {
+	/* OP-TEE SKS ID representing a not-yet defined value */
+	/* Standard CK attributes */
+	CK2STR_ENTRY(CKA_CLASS),
+	CK2STR_ENTRY(CKA_TOKEN),
+	CK2STR_ENTRY(CKA_PRIVATE),
+	CK2STR_ENTRY(CKA_LABEL),
+	CK2STR_ENTRY(CKA_APPLICATION),
+	CK2STR_ENTRY(CKA_VALUE),
+	CK2STR_ENTRY(CKA_OBJECT_ID),
+	CK2STR_ENTRY(CKA_CERTIFICATE_TYPE),
+	CK2STR_ENTRY(CKA_ISSUER),
+	CK2STR_ENTRY(CKA_SERIAL_NUMBER),
+	CK2STR_ENTRY(CKA_AC_ISSUER),
+	CK2STR_ENTRY(CKA_OWNER),
+	CK2STR_ENTRY(CKA_ATTR_TYPES),
+	CK2STR_ENTRY(CKA_TRUSTED),
+	CK2STR_ENTRY(CKA_CERTIFICATE_CATEGORY),
+	CK2STR_ENTRY(CKA_JAVA_MIDP_SECURITY_DOMAIN),
+	CK2STR_ENTRY(CKA_URL),
+	CK2STR_ENTRY(CKA_HASH_OF_SUBJECT_PUBLIC_KEY),
+	CK2STR_ENTRY(CKA_HASH_OF_ISSUER_PUBLIC_KEY),
+	CK2STR_ENTRY(CKA_NAME_HASH_ALGORITHM),
+	CK2STR_ENTRY(CKA_CHECK_VALUE),
+	CK2STR_ENTRY(CKA_KEY_TYPE),
+	CK2STR_ENTRY(CKA_SUBJECT),
+	CK2STR_ENTRY(CKA_ID),
+	CK2STR_ENTRY(CKA_SENSITIVE),
+	CK2STR_ENTRY(CKA_ENCRYPT),
+	CK2STR_ENTRY(CKA_DECRYPT),
+	CK2STR_ENTRY(CKA_WRAP),
+	CK2STR_ENTRY(CKA_UNWRAP),
+	CK2STR_ENTRY(CKA_SIGN),
+	CK2STR_ENTRY(CKA_SIGN_RECOVER),
+	CK2STR_ENTRY(CKA_VERIFY),
+	CK2STR_ENTRY(CKA_VERIFY_RECOVER),
+	CK2STR_ENTRY(CKA_DERIVE),
+	CK2STR_ENTRY(CKA_START_DATE),
+	CK2STR_ENTRY(CKA_END_DATE),
+	CK2STR_ENTRY(CKA_MODULUS),
+	CK2STR_ENTRY(CKA_MODULUS_BITS),
+	CK2STR_ENTRY(CKA_PUBLIC_EXPONENT),
+	CK2STR_ENTRY(CKA_PRIVATE_EXPONENT),
+	CK2STR_ENTRY(CKA_PRIME_1),
+	CK2STR_ENTRY(CKA_PRIME_2),
+	CK2STR_ENTRY(CKA_EXPONENT_1),
+	CK2STR_ENTRY(CKA_EXPONENT_2),
+	CK2STR_ENTRY(CKA_COEFFICIENT),
+	CK2STR_ENTRY(CKA_PUBLIC_KEY_INFO),
+	CK2STR_ENTRY(CKA_PRIME),
+	CK2STR_ENTRY(CKA_SUBPRIME),
+	CK2STR_ENTRY(CKA_BASE),
+	CK2STR_ENTRY(CKA_PRIME_BITS),
+	CK2STR_ENTRY(CKA_SUBPRIME_BITS),
+	CK2STR_ENTRY(CKA_VALUE_BITS),
+	CK2STR_ENTRY(CKA_VALUE_LEN),
+	CK2STR_ENTRY(CKA_EXTRACTABLE),
+	CK2STR_ENTRY(CKA_LOCAL),
+	CK2STR_ENTRY(CKA_NEVER_EXTRACTABLE),
+	CK2STR_ENTRY(CKA_ALWAYS_SENSITIVE),
+	CK2STR_ENTRY(CKA_KEY_GEN_MECHANISM),
+	CK2STR_ENTRY(CKA_MODIFIABLE),
+	CK2STR_ENTRY(CKA_COPYABLE),
+	CK2STR_ENTRY(CKA_DESTROYABLE),
+	CK2STR_ENTRY(CKA_EC_PARAMS),
+	CK2STR_ENTRY(CKA_EC_POINT),
+	CK2STR_ENTRY(CKA_ALWAYS_AUTHENTICATE),
+	CK2STR_ENTRY(CKA_WRAP_WITH_TRUSTED),
+	CK2STR_ENTRY(CKA_WRAP_TEMPLATE),
+	CK2STR_ENTRY(CKA_UNWRAP_TEMPLATE),
+	CK2STR_ENTRY(CKA_DERIVE_TEMPLATE),
+	CK2STR_ENTRY(CKA_OTP_FORMAT),
+	CK2STR_ENTRY(CKA_OTP_LENGTH),
+	CK2STR_ENTRY(CKA_OTP_TIME_INTERVAL),
+	CK2STR_ENTRY(CKA_OTP_USER_FRIENDLY_MODE),
+	CK2STR_ENTRY(CKA_OTP_CHALLENGE_REQUIREMENT),
+	CK2STR_ENTRY(CKA_OTP_TIME_REQUIREMENT),
+	CK2STR_ENTRY(CKA_OTP_COUNTER_REQUIREMENT),
+	CK2STR_ENTRY(CKA_OTP_PIN_REQUIREMENT),
+	CK2STR_ENTRY(CKA_OTP_COUNTER),
+	CK2STR_ENTRY(CKA_OTP_TIME),
+	CK2STR_ENTRY(CKA_OTP_USER_IDENTIFIER),
+	CK2STR_ENTRY(CKA_OTP_SERVICE_IDENTIFIER),
+	CK2STR_ENTRY(CKA_OTP_SERVICE_LOGO),
+	CK2STR_ENTRY(CKA_OTP_SERVICE_LOGO_TYPE),
+	CK2STR_ENTRY(CKA_GOSTR3410_PARAMS),
+	CK2STR_ENTRY(CKA_GOSTR3411_PARAMS),
+	CK2STR_ENTRY(CKA_GOST28147_PARAMS),
+	CK2STR_ENTRY(CKA_HW_FEATURE_TYPE),
+	CK2STR_ENTRY(CKA_RESET_ON_INIT),
+	CK2STR_ENTRY(CKA_HAS_RESET),
+	CK2STR_ENTRY(CKA_PIXEL_X),
+	CK2STR_ENTRY(CKA_PIXEL_Y),
+	CK2STR_ENTRY(CKA_RESOLUTION),
+	CK2STR_ENTRY(CKA_CHAR_ROWS),
+	CK2STR_ENTRY(CKA_CHAR_COLUMNS),
+	CK2STR_ENTRY(CKA_COLOR),
+	CK2STR_ENTRY(CKA_BITS_PER_PIXEL),
+	CK2STR_ENTRY(CKA_CHAR_SETS),
+	CK2STR_ENTRY(CKA_ENCODING_METHODS),
+	CK2STR_ENTRY(CKA_MIME_TYPES),
+	CK2STR_ENTRY(CKA_MECHANISM_TYPE),
+	CK2STR_ENTRY(CKA_REQUIRED_CMS_ATTRIBUTES),
+	CK2STR_ENTRY(CKA_DEFAULT_CMS_ATTRIBUTES),
+	CK2STR_ENTRY(CKA_SUPPORTED_CMS_ATTRIBUTES),
+	CK2STR_ENTRY(CKA_ALLOWED_MECHANISMS),
+	CK2STR_ENTRY(CKA_VENDOR_DEFINED),
+};
+
+const char *cka2str(CK_ATTRIBUTE_TYPE id)
+{
+	static const char vendor_range[] = "<unknwon-vendor-defined>";
+	static const char unknown[] = "<unknown-identifier>";
+	const int count = sizeof(cka2str_table) / sizeof(struct ck2str);
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (id == cka2str_table[n].id)
+			return cka2str_table[n].string;
+	}
+
+	if (id > CKA_VENDOR_DEFINED)
+		return vendor_range;
+
+	return unknown;
+}
+
+/*
+ * ckr2str - Return a pointer to a string buffer of "CKR_xxx\0" return value ID
+ */
+static struct ck2str ckr2str_table[] = {
+	CK2STR_ENTRY(CKR_OK),
+	CK2STR_ENTRY(CKR_CANCEL),
+	CK2STR_ENTRY(CKR_HOST_MEMORY),
+	CK2STR_ENTRY(CKR_SLOT_ID_INVALID),
+	CK2STR_ENTRY(CKR_GENERAL_ERROR),
+	CK2STR_ENTRY(CKR_FUNCTION_FAILED),
+	CK2STR_ENTRY(CKR_ARGUMENTS_BAD),
+	CK2STR_ENTRY(CKR_NO_EVENT),
+	CK2STR_ENTRY(CKR_NEED_TO_CREATE_THREADS),
+	CK2STR_ENTRY(CKR_CANT_LOCK),
+	CK2STR_ENTRY(CKR_ATTRIBUTE_READ_ONLY),
+	CK2STR_ENTRY(CKR_ATTRIBUTE_SENSITIVE),
+	CK2STR_ENTRY(CKR_ATTRIBUTE_TYPE_INVALID),
+	CK2STR_ENTRY(CKR_ATTRIBUTE_VALUE_INVALID),
+	CK2STR_ENTRY(CKR_ACTION_PROHIBITED),
+	CK2STR_ENTRY(CKR_DATA_INVALID),
+	CK2STR_ENTRY(CKR_DATA_LEN_RANGE),
+	CK2STR_ENTRY(CKR_DEVICE_ERROR),
+	CK2STR_ENTRY(CKR_DEVICE_MEMORY),
+	CK2STR_ENTRY(CKR_DEVICE_REMOVED),
+	CK2STR_ENTRY(CKR_ENCRYPTED_DATA_INVALID),
+	CK2STR_ENTRY(CKR_ENCRYPTED_DATA_LEN_RANGE),
+	CK2STR_ENTRY(CKR_FUNCTION_CANCELED),
+	CK2STR_ENTRY(CKR_FUNCTION_NOT_PARALLEL),
+	CK2STR_ENTRY(CKR_FUNCTION_NOT_SUPPORTED),
+	CK2STR_ENTRY(CKR_KEY_HANDLE_INVALID),
+	CK2STR_ENTRY(CKR_KEY_SIZE_RANGE),
+	CK2STR_ENTRY(CKR_KEY_TYPE_INCONSISTENT),
+	CK2STR_ENTRY(CKR_KEY_NOT_NEEDED),
+	CK2STR_ENTRY(CKR_KEY_CHANGED),
+	CK2STR_ENTRY(CKR_KEY_NEEDED),
+	CK2STR_ENTRY(CKR_KEY_INDIGESTIBLE),
+	CK2STR_ENTRY(CKR_KEY_FUNCTION_NOT_PERMITTED),
+	CK2STR_ENTRY(CKR_KEY_NOT_WRAPPABLE),
+	CK2STR_ENTRY(CKR_KEY_UNEXTRACTABLE),
+	CK2STR_ENTRY(CKR_MECHANISM_INVALID),
+	CK2STR_ENTRY(CKR_MECHANISM_PARAM_INVALID),
+	CK2STR_ENTRY(CKR_OBJECT_HANDLE_INVALID),
+	CK2STR_ENTRY(CKR_OPERATION_ACTIVE),
+	CK2STR_ENTRY(CKR_OPERATION_NOT_INITIALIZED),
+	CK2STR_ENTRY(CKR_PIN_INCORRECT),
+	CK2STR_ENTRY(CKR_PIN_INVALID),
+	CK2STR_ENTRY(CKR_PIN_LEN_RANGE),
+	CK2STR_ENTRY(CKR_PIN_EXPIRED),
+	CK2STR_ENTRY(CKR_PIN_LOCKED),
+	CK2STR_ENTRY(CKR_SESSION_CLOSED),
+	CK2STR_ENTRY(CKR_SESSION_COUNT),
+	CK2STR_ENTRY(CKR_SESSION_HANDLE_INVALID),
+	CK2STR_ENTRY(CKR_SESSION_PARALLEL_NOT_SUPPORTED),
+	CK2STR_ENTRY(CKR_SESSION_READ_ONLY),
+	CK2STR_ENTRY(CKR_SESSION_EXISTS),
+	CK2STR_ENTRY(CKR_SESSION_READ_ONLY_EXISTS),
+	CK2STR_ENTRY(CKR_SESSION_READ_WRITE_SO_EXISTS),
+	CK2STR_ENTRY(CKR_SIGNATURE_INVALID),
+	CK2STR_ENTRY(CKR_SIGNATURE_LEN_RANGE),
+	CK2STR_ENTRY(CKR_TEMPLATE_INCOMPLETE),
+	CK2STR_ENTRY(CKR_TEMPLATE_INCONSISTENT),
+	CK2STR_ENTRY(CKR_TOKEN_NOT_PRESENT),
+	CK2STR_ENTRY(CKR_TOKEN_NOT_RECOGNIZED),
+	CK2STR_ENTRY(CKR_TOKEN_WRITE_PROTECTED),
+	CK2STR_ENTRY(CKR_UNWRAPPING_KEY_HANDLE_INVALID),
+	CK2STR_ENTRY(CKR_UNWRAPPING_KEY_SIZE_RANGE),
+	CK2STR_ENTRY(CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT),
+	CK2STR_ENTRY(CKR_USER_ALREADY_LOGGED_IN),
+	CK2STR_ENTRY(CKR_USER_NOT_LOGGED_IN),
+	CK2STR_ENTRY(CKR_USER_PIN_NOT_INITIALIZED),
+	CK2STR_ENTRY(CKR_USER_TYPE_INVALID),
+	CK2STR_ENTRY(CKR_USER_ANOTHER_ALREADY_LOGGED_IN),
+	CK2STR_ENTRY(CKR_USER_TOO_MANY_TYPES),
+	CK2STR_ENTRY(CKR_WRAPPED_KEY_INVALID),
+	CK2STR_ENTRY(CKR_WRAPPED_KEY_LEN_RANGE),
+	CK2STR_ENTRY(CKR_WRAPPING_KEY_HANDLE_INVALID),
+	CK2STR_ENTRY(CKR_WRAPPING_KEY_SIZE_RANGE),
+	CK2STR_ENTRY(CKR_WRAPPING_KEY_TYPE_INCONSISTENT),
+	CK2STR_ENTRY(CKR_RANDOM_SEED_NOT_SUPPORTED),
+	CK2STR_ENTRY(CKR_RANDOM_NO_RNG),
+	CK2STR_ENTRY(CKR_DOMAIN_PARAMS_INVALID),
+	CK2STR_ENTRY(CKR_CURVE_NOT_SUPPORTED),
+	CK2STR_ENTRY(CKR_BUFFER_TOO_SMALL),
+	CK2STR_ENTRY(CKR_SAVED_STATE_INVALID),
+	CK2STR_ENTRY(CKR_INFORMATION_SENSITIVE),
+	CK2STR_ENTRY(CKR_STATE_UNSAVEABLE),
+	CK2STR_ENTRY(CKR_CRYPTOKI_NOT_INITIALIZED),
+	CK2STR_ENTRY(CKR_CRYPTOKI_ALREADY_INITIALIZED),
+	CK2STR_ENTRY(CKR_MUTEX_BAD),
+	CK2STR_ENTRY(CKR_MUTEX_NOT_LOCKED),
+	CK2STR_ENTRY(CKR_NEW_PIN_MODE),
+	CK2STR_ENTRY(CKR_NEXT_OTP),
+	CK2STR_ENTRY(CKR_EXCEEDED_MAX_ITERATIONS),
+	CK2STR_ENTRY(CKR_FIPS_SELF_TEST_FAILED),
+	CK2STR_ENTRY(CKR_LIBRARY_LOAD_FAILED),
+	CK2STR_ENTRY(CKR_PIN_TOO_WEAK),
+	CK2STR_ENTRY(CKR_PUBLIC_KEY_INVALID),
+	CK2STR_ENTRY(CKR_FUNCTION_REJECTED),
+	CK2STR_ENTRY(CKR_VENDOR_DEFINED),
+};
+
+const char *ckr2str(CK_RV id)
+{
+	static const char vendor[] = "(vendor-defined)";
+	static const char unknown[] = "(unknown)";
+	const int count = sizeof(ckr2str_table) / sizeof(struct ck2str);
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (id == ckr2str_table[n].id)
+			return ckr2str_table[n].string;
+	}
+
+	if (id >= CKR_VENDOR_DEFINED)
+		return vendor;
+
+	return unknown;
+}
+
+/*
+ * ckr2str - Return a pointer to a string buffer of "CKM_xxx\0" mechanism ID
+ *
+ * This does not cover the whole IDs defined by the PKCS#11. To be updated
+ * when needed.
+ */
+static struct ck2str ckm2str_table[] = {
+	CK2STR_ENTRY(CKM_RSA_PKCS_KEY_PAIR_GEN),
+	CK2STR_ENTRY(CKM_RSA_PKCS),
+	CK2STR_ENTRY(CKM_RSA_9796),
+	CK2STR_ENTRY(CKM_RSA_X_509),
+	CK2STR_ENTRY(CKM_SHA1_RSA_PKCS),
+	CK2STR_ENTRY(CKM_RSA_PKCS_OAEP),
+	CK2STR_ENTRY(CKM_RSA_PKCS_PSS),
+	CK2STR_ENTRY(CKM_SHA1_RSA_PKCS_PSS),
+	CK2STR_ENTRY(CKM_SHA256_RSA_PKCS),
+	CK2STR_ENTRY(CKM_SHA384_RSA_PKCS),
+	CK2STR_ENTRY(CKM_SHA512_RSA_PKCS),
+	CK2STR_ENTRY(CKM_SHA256_RSA_PKCS_PSS),
+	CK2STR_ENTRY(CKM_SHA384_RSA_PKCS_PSS),
+	CK2STR_ENTRY(CKM_SHA512_RSA_PKCS_PSS),
+	CK2STR_ENTRY(CKM_SHA224_RSA_PKCS),
+	CK2STR_ENTRY(CKM_SHA224_RSA_PKCS_PSS),
+	CK2STR_ENTRY(CKM_SHA512_224),
+	CK2STR_ENTRY(CKM_SHA512_224_HMAC),
+	CK2STR_ENTRY(CKM_SHA512_224_HMAC_GENERAL),
+	CK2STR_ENTRY(CKM_SHA512_224_KEY_DERIVATION),
+	CK2STR_ENTRY(CKM_SHA512_256),
+	CK2STR_ENTRY(CKM_SHA512_256_HMAC),
+	CK2STR_ENTRY(CKM_SHA512_256_HMAC_GENERAL),
+	CK2STR_ENTRY(CKM_SHA512_256_KEY_DERIVATION),
+	CK2STR_ENTRY(CKM_MD5_HMAC),
+	CK2STR_ENTRY(CKM_MD5_HMAC_GENERAL),
+	CK2STR_ENTRY(CKM_SHA_1),
+	CK2STR_ENTRY(CKM_SHA_1_HMAC),
+	CK2STR_ENTRY(CKM_SHA_1_HMAC_GENERAL),
+	CK2STR_ENTRY(CKM_SHA256),
+	CK2STR_ENTRY(CKM_SHA256_HMAC),
+	CK2STR_ENTRY(CKM_SHA256_HMAC_GENERAL),
+	CK2STR_ENTRY(CKM_SHA224),
+	CK2STR_ENTRY(CKM_SHA224_HMAC),
+	CK2STR_ENTRY(CKM_SHA224_HMAC_GENERAL),
+	CK2STR_ENTRY(CKM_SHA384),
+	CK2STR_ENTRY(CKM_SHA384_HMAC),
+	CK2STR_ENTRY(CKM_SHA384_HMAC_GENERAL),
+	CK2STR_ENTRY(CKM_SHA512),
+	CK2STR_ENTRY(CKM_SHA512_HMAC),
+	CK2STR_ENTRY(CKM_SHA512_HMAC_GENERAL),
+	CK2STR_ENTRY(CKM_HOTP_KEY_GEN),
+	CK2STR_ENTRY(CKM_HOTP),
+	CK2STR_ENTRY(CKM_GENERIC_SECRET_KEY_GEN),
+	CK2STR_ENTRY(CKM_SHA1_KEY_DERIVATION),
+	CK2STR_ENTRY(CKM_SHA256_KEY_DERIVATION),
+	CK2STR_ENTRY(CKM_SHA384_KEY_DERIVATION),
+	CK2STR_ENTRY(CKM_SHA512_KEY_DERIVATION),
+	CK2STR_ENTRY(CKM_SHA224_KEY_DERIVATION),
+	CK2STR_ENTRY(CKM_EC_KEY_PAIR_GEN),
+	CK2STR_ENTRY(CKM_ECDSA),
+	CK2STR_ENTRY(CKM_ECDSA_SHA1),
+	CK2STR_ENTRY(CKM_ECDSA_SHA224),
+	CK2STR_ENTRY(CKM_ECDSA_SHA256),
+	CK2STR_ENTRY(CKM_ECDSA_SHA384),
+	CK2STR_ENTRY(CKM_ECDSA_SHA512),
+	CK2STR_ENTRY(CKM_ECDH1_DERIVE),
+	CK2STR_ENTRY(CKM_ECDH1_COFACTOR_DERIVE),
+	CK2STR_ENTRY(CKM_ECMQV_DERIVE),
+	CK2STR_ENTRY(CKM_ECDH_AES_KEY_WRAP),
+	CK2STR_ENTRY(CKM_RSA_AES_KEY_WRAP),
+	CK2STR_ENTRY(CKM_AES_KEY_GEN),
+	CK2STR_ENTRY(CKM_AES_ECB),
+	CK2STR_ENTRY(CKM_AES_CBC),
+	CK2STR_ENTRY(CKM_AES_MAC),
+	CK2STR_ENTRY(CKM_AES_MAC_GENERAL),
+	CK2STR_ENTRY(CKM_AES_CBC_PAD),
+	CK2STR_ENTRY(CKM_AES_CTR),
+	CK2STR_ENTRY(CKM_AES_GCM),
+	CK2STR_ENTRY(CKM_AES_CCM),
+	CK2STR_ENTRY(CKM_AES_CTS),
+	CK2STR_ENTRY(CKM_AES_CMAC),
+	CK2STR_ENTRY(CKM_AES_CMAC_GENERAL),
+	CK2STR_ENTRY(CKM_AES_XCBC_MAC),
+	CK2STR_ENTRY(CKM_AES_XCBC_MAC_96),
+	CK2STR_ENTRY(CKM_AES_GMAC),
+	CK2STR_ENTRY(CKM_DES3_ECB_ENCRYPT_DATA),
+	CK2STR_ENTRY(CKM_DES3_CBC_ENCRYPT_DATA),
+	CK2STR_ENTRY(CKM_AES_ECB_ENCRYPT_DATA),
+	CK2STR_ENTRY(CKM_AES_CBC_ENCRYPT_DATA),
+	CK2STR_ENTRY(CKM_AES_KEY_WRAP),
+	CK2STR_ENTRY(CKM_AES_KEY_WRAP_PAD),
+	CK2STR_ENTRY(CKM_MD5),
+	CK2STR_ENTRY(CKM_SHA_1),
+	CK2STR_ENTRY(CKM_SHA224),
+	CK2STR_ENTRY(CKM_SHA256),
+	CK2STR_ENTRY(CKM_SHA384),
+	CK2STR_ENTRY(CKM_SHA512),
+	CK2STR_ENTRY(CKM_DES_KEY_GEN),
+	CK2STR_ENTRY(CKM_DES_ECB),
+	CK2STR_ENTRY(CKM_DES_CBC),
+	CK2STR_ENTRY(CKM_DES_MAC),
+	CK2STR_ENTRY(CKM_DES_MAC_GENERAL),
+	CK2STR_ENTRY(CKM_DES_CBC_PAD),
+	CK2STR_ENTRY(CKM_VENDOR_DEFINED),
+};
+
+const char *ckm2str(CK_MECHANISM_TYPE id)
+{
+	static const char vendor[] = "(vendor-defined)";
+	static const char unknown[] = "(unknown)";
+	const int count = sizeof(ckm2str_table) / sizeof(struct ck2str);
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (id == ckm2str_table[n].id)
+			return ckm2str_table[n].string;
+	}
+
+	if (id >= CKM_VENDOR_DEFINED)
+		return vendor;
+
+	return unknown;
+}
+
+static struct ck2str skscmd2str_table[] = {
+	CK2STR_ENTRY(SKS_CMD_PING),
+	CK2STR_ENTRY(SKS_CMD_CK_SLOT_LIST),
+	CK2STR_ENTRY(SKS_CMD_CK_SLOT_INFO),
+	CK2STR_ENTRY(SKS_CMD_CK_TOKEN_INFO),
+	CK2STR_ENTRY(SKS_CMD_CK_MECHANISM_IDS),
+	CK2STR_ENTRY(SKS_CMD_CK_MECHANISM_INFO),
+	CK2STR_ENTRY(SKS_CMD_CK_INIT_TOKEN),
+	CK2STR_ENTRY(SKS_CMD_CK_INIT_PIN),
+	CK2STR_ENTRY(SKS_CMD_CK_SET_PIN),
+	CK2STR_ENTRY(SKS_CMD_CK_OPEN_RO_SESSION),
+	CK2STR_ENTRY(SKS_CMD_CK_OPEN_RW_SESSION),
+	CK2STR_ENTRY(SKS_CMD_CK_CLOSE_SESSION),
+	CK2STR_ENTRY(SKS_CMD_CK_SESSION_INFO),
+	CK2STR_ENTRY(SKS_CMD_IMPORT_OBJECT),
+	CK2STR_ENTRY(SKS_CMD_DESTROY_OBJECT),
+	CK2STR_ENTRY(SKS_CMD_ENCRYPT_INIT),
+	CK2STR_ENTRY(SKS_CMD_DECRYPT_INIT),
+	CK2STR_ENTRY(SKS_CMD_ENCRYPT_UPDATE),
+	CK2STR_ENTRY(SKS_CMD_DECRYPT_UPDATE),
+	CK2STR_ENTRY(SKS_CMD_DECRYPT_FINAL),
+	CK2STR_ENTRY(SKS_CMD_ENCRYPT_FINAL),
+};
+
+const char *skscmd2str(unsigned int id)
+{
+	static const char unknown[] = "<invalid-command-id>";
+	const int count = sizeof(skscmd2str_table) / sizeof(struct ck2str);
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (id == skscmd2str_table[n].id)
+			return skscmd2str_table[n].string;
+	}
+
+	return unknown;
+}
+
+static struct ck2str slotflag2str_table[] = {
+	CK2STR_ENTRY(CKF_TOKEN_PRESENT),
+	CK2STR_ENTRY(CKF_REMOVABLE_DEVICE),
+	CK2STR_ENTRY(CKF_HW_SLOT),
+};
+
+static const char *slot_flags2str(CK_ULONG flags)
+{
+	const int count = sizeof(slotflag2str_table) / sizeof(struct ck2str);
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (flags & slotflag2str_table[n].id)
+			return slotflag2str_table[n].string;
+	}
+
+	return NULL;
+}
+
+static struct ck2str tokenflag2str_table[] = {
+	CK2STR_ENTRY(CKF_RNG),
+	CK2STR_ENTRY(CKF_WRITE_PROTECTED),
+	CK2STR_ENTRY(CKF_LOGIN_REQUIRED),
+	CK2STR_ENTRY(CKF_USER_PIN_INITIALIZED),
+	CK2STR_ENTRY(CKF_RESTORE_KEY_NOT_NEEDED),
+	CK2STR_ENTRY(CKF_CLOCK_ON_TOKEN),
+	CK2STR_ENTRY(CKF_PROTECTED_AUTHENTICATION_PATH),
+	CK2STR_ENTRY(CKF_DUAL_CRYPTO_OPERATIONS),
+	CK2STR_ENTRY(CKF_TOKEN_INITIALIZED),
+	CK2STR_ENTRY(CKF_SECONDARY_AUTHENTICATION),
+	CK2STR_ENTRY(CKF_USER_PIN_COUNT_LOW),
+	CK2STR_ENTRY(CKF_USER_PIN_FINAL_TRY),
+	CK2STR_ENTRY(CKF_USER_PIN_LOCKED),
+	CK2STR_ENTRY(CKF_USER_PIN_TO_BE_CHANGED),
+	CK2STR_ENTRY(CKF_SO_PIN_COUNT_LOW),
+	CK2STR_ENTRY(CKF_SO_PIN_FINAL_TRY),
+	CK2STR_ENTRY(CKF_SO_PIN_LOCKED),
+	CK2STR_ENTRY(CKF_SO_PIN_TO_BE_CHANGED),
+	CK2STR_ENTRY(CKF_ERROR_STATE),
+};
+
+static const char *token_flags2str(CK_ULONG flags)
+{
+	const int count = sizeof(tokenflag2str_table) / sizeof(struct ck2str);
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (flags & tokenflag2str_table[n].id)
+			return tokenflag2str_table[n].string;
+	}
+
+	return NULL;
+}
+
+static struct ck2str mechaflag2str_table[] = {
+	CK2STR_ENTRY(CKF_HW),
+	CK2STR_ENTRY(CKF_ENCRYPT),
+	CK2STR_ENTRY(CKF_DECRYPT),
+	CK2STR_ENTRY(CKF_DIGEST),
+	CK2STR_ENTRY(CKF_SIGN),
+	CK2STR_ENTRY(CKF_SIGN_RECOVER),
+	CK2STR_ENTRY(CKF_VERIFY),
+	CK2STR_ENTRY(CKF_VERIFY_RECOVER),
+	CK2STR_ENTRY(CKF_GENERATE),
+	CK2STR_ENTRY(CKF_GENERATE_KEY_PAIR),
+	CK2STR_ENTRY(CKF_WRAP),
+	CK2STR_ENTRY(CKF_UNWRAP),
+	CK2STR_ENTRY(CKF_DERIVE),
+	CK2STR_ENTRY(CKF_EC_F_P),
+	CK2STR_ENTRY(CKF_EC_F_2M),
+	CK2STR_ENTRY(CKF_EC_ECPARAMETERS),
+	CK2STR_ENTRY(CKF_EC_NAMEDCURVE),
+	CK2STR_ENTRY(CKF_EC_UNCOMPRESS),
+	CK2STR_ENTRY(CKF_EC_COMPRESS),
+	CK2STR_ENTRY(CKF_EXTENSION),
+};
+
+static const char *mecha_flags2str(CK_ULONG flags)
+{
+	const int count = sizeof(mechaflag2str_table) / sizeof(struct ck2str);
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (flags & mechaflag2str_table[n].id)
+			return mechaflag2str_table[n].string;
+	}
+
+	return NULL;
+}
+
+enum ck_debug_flag_type {
+	CKDBG_SLOT,
+	CKDBG_TOKEN,
+	CKDBG_KEY,
+	CKDBG_CERTIF,
+	CKDBG_MECHA,
+};
+
+static char *__flag2str(CK_ULONG flags, enum ck_debug_flag_type type)
+{
+	char *str = NULL;
+	size_t size = 0;
+	int mask = 1;
+
+	for (mask = 1; flags && mask; flags &= ~mask, mask = mask << 1) {
+		char const *label = NULL;
+		size_t label_size;
+		char *nstr;
+
+		if (!(flags & mask))
+			continue;
+
+		switch(type) {
+		case CKDBG_SLOT:
+			label = slot_flags2str(mask);
+			break;
+		case CKDBG_TOKEN:
+			label = token_flags2str(mask);
+			break;
+		case CKDBG_MECHA:
+			label = mecha_flags2str(mask);
+			break;
+		default:
+			return NULL;
+		}
+
+		if (!label)
+			continue;
+
+		/* 4 digit prefix "CKF_" is not dumped */
+		if (!memcmp(label, "CKF_", 4))
+			label += 4;
+
+		/* Extra space digit */
+		label_size = strlen(label) + 1;
+
+		/* Always allocate 1 more digit for terminal '\0' */
+		nstr = realloc(str, size + label_size + 1);
+		if (!nstr) {
+			free(str);
+			return NULL;
+		}
+
+		snprintf(nstr + size, label_size + 1, "%s ", label);
+		str = nstr;
+		size += label_size;
+	}
+
+	return str;
+}
+
+char *ck_slot_flag2str(CK_ULONG flags)
+{
+	return __flag2str(flags, CKDBG_SLOT);
+}
+
+char *ck_token_flag2str(CK_ULONG flags)
+{
+	return __flag2str(flags, CKDBG_TOKEN);
+}
+
+char *ck_mecha_flag2str(CK_ULONG flags)
+{
+	return __flag2str(flags, CKDBG_MECHA);
+}
+
+static struct ck2str class2str_table[] = {
+	CK2STR_ENTRY(CKO_DATA),
+	CK2STR_ENTRY(CKO_CERTIFICATE),
+	CK2STR_ENTRY(CKO_PUBLIC_KEY),
+	CK2STR_ENTRY(CKO_PRIVATE_KEY),
+	CK2STR_ENTRY(CKO_SECRET_KEY),
+	CK2STR_ENTRY(CKO_HW_FEATURE),
+	CK2STR_ENTRY(CKO_DOMAIN_PARAMETERS),
+	CK2STR_ENTRY(CKO_MECHANISM),
+	CK2STR_ENTRY(CKO_OTP_KEY),
+	CK2STR_ENTRY(CKO_VENDOR_DEFINED),
+};
+
+const char *ckclass2str(CK_ULONG id)
+{
+	const int count = sizeof(class2str_table) / sizeof(struct ck2str);
+	int n;
+
+	for (n = 0; n < count; n++)
+		if (id == class2str_table[n].id)
+			return class2str_table[n].string;
+
+	return NULL;
+}
+
+static struct ck2str symkey2str_table[] = {
+	CK2STR_ENTRY(CKK_RSA),
+	CK2STR_ENTRY(CKK_DSA),
+	CK2STR_ENTRY(CKK_DH),
+	CK2STR_ENTRY(CKK_ECDSA),
+	CK2STR_ENTRY(CKK_EC),
+	CK2STR_ENTRY(CKK_GENERIC_SECRET),
+	CK2STR_ENTRY(CKK_DES),
+	CK2STR_ENTRY(CKK_DES2),
+	CK2STR_ENTRY(CKK_DES3),
+	CK2STR_ENTRY(CKK_AES),
+	CK2STR_ENTRY(CKK_HOTP),
+	CK2STR_ENTRY(CKK_MD5_HMAC),
+	CK2STR_ENTRY(CKK_SHA_1_HMAC),
+	CK2STR_ENTRY(CKK_SHA256_HMAC),
+	CK2STR_ENTRY(CKK_SHA384_HMAC),
+	CK2STR_ENTRY(CKK_SHA512_HMAC),
+	CK2STR_ENTRY(CKK_SHA224_HMAC),
+	CK2STR_ENTRY(CKK_VENDOR_DEFINED),
+};
+
+const char *cktype2str(CK_ULONG id, CK_ULONG class)
+{
+	int count;
+	struct ck2str *table;
+	int n;
+
+	switch (class) {
+	case CKO_DATA:
+		/* No type for data object */
+		return NULL;
+	case CKO_SECRET_KEY:
+		count = sizeof(symkey2str_table);
+		table = symkey2str_table;
+		break;
+	case CKO_MECHANISM:
+		return ckm2str(id);
+	case CKO_CERTIFICATE:
+	case CKO_DOMAIN_PARAMETERS:
+	case CKO_HW_FEATURE:
+	case CKO_PUBLIC_KEY:
+	case CKO_PRIVATE_KEY:
+	case CKO_OTP_KEY:
+		/* Not supported */
+		return NULL;
+	default:
+		/* Unknwon */
+		return NULL;
+	}
+
+	count /= sizeof(struct ck2str);
+	for (n = 0; n < count; n++)
+		if (id == table[n].id)
+			return table[n].string;
+
+	return NULL;
+}
diff --git a/libsks/src/ck_helpers.c b/libsks/src/ck_helpers.c
new file mode 100644
index 0000000..1f7f48d
--- /dev/null
+++ b/libsks/src/ck_helpers.c
@@ -0,0 +1,820 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "ck_helpers.h"
+#include "local_utils.h"
+
+/*
+ * SKS TA returns Cryptoki like information structure.
+ * These routine convert the SKS format structure and bit flags
+ * from/into Cryptoki format structures and bit flags.
+ */
+#define MEMCPY_FIELD(_dst, _src, _f) \
+	do { \
+		memcpy((_dst)->_f, (_src)->_f, sizeof((_dst)->_f)); \
+		if (sizeof((_dst)->_f) != sizeof((_src)->_f)) \
+			return CKR_GENERAL_ERROR; \
+	} while (0)
+
+#define MEMCPY_VERSION(_dst, _src, _f) \
+	do { \
+		memcpy(&(_dst)->_f, (_src)->_f, sizeof(CK_VERSION)); \
+		if (sizeof(CK_VERSION) != sizeof((_src)->_f)) \
+			return CKR_GENERAL_ERROR; \
+	} while (0)
+
+static CK_RV sks2ck_all_slot_flags(CK_SLOT_INFO_PTR ck_info,
+				   struct sks_slot_info *sks_info)
+{
+	CK_FLAGS ck_flag;
+	uint32_t sks_mask;
+
+	ck_info->flags = 0;
+	for (sks_mask = 1; sks_mask; sks_mask <<= 1) {
+
+		/* Skip sks token flags without a CK equilavent */
+		if (sks2ck_slot_flag(&ck_flag, sks_mask))
+			continue;
+
+		if (sks_info->flags & sks_mask)
+			ck_info->flags |= ck_flag;
+	}
+
+	return CKR_OK;
+}
+
+CK_RV sks2ck_slot_info(CK_SLOT_INFO_PTR ck_info,
+			struct sks_slot_info *sks_info)
+{
+	CK_RV rv;
+
+	MEMCPY_FIELD(ck_info, sks_info, slotDescription);
+	MEMCPY_FIELD(ck_info, sks_info, manufacturerID);
+
+	rv = sks2ck_all_slot_flags(ck_info, sks_info);
+	if (rv)
+		return rv;
+
+	MEMCPY_VERSION(ck_info, sks_info, hardwareVersion);
+	MEMCPY_VERSION(ck_info, sks_info, firmwareVersion);
+
+	return CKR_OK;
+}
+
+static CK_RV sks2ck_all_token_flags(CK_TOKEN_INFO_PTR ck_info,
+				struct sks_token_info *sks_info)
+{
+	CK_FLAGS ck_flag;
+	uint32_t sks_mask;
+
+	ck_info->flags = 0;
+	for (sks_mask = 1; sks_mask; sks_mask <<= 1) {
+
+		/* Skip sks token flags without a CK equilavent */
+		if (sks2ck_token_flag(&ck_flag, sks_mask))
+			continue;
+
+		if (sks_info->flags & sks_mask)
+			ck_info->flags |= ck_flag;
+	}
+
+	return CKR_OK;
+}
+
+CK_RV sks2ck_token_info(CK_TOKEN_INFO_PTR ck_info,
+			struct sks_token_info *sks_info)
+{
+	CK_RV rv;
+
+	MEMCPY_FIELD(ck_info, sks_info, label);
+	MEMCPY_FIELD(ck_info, sks_info, manufacturerID);
+	MEMCPY_FIELD(ck_info, sks_info, model);
+	MEMCPY_FIELD(ck_info, sks_info, serialNumber);
+
+	rv = sks2ck_all_token_flags(ck_info, sks_info);
+	if (rv)
+		return rv;
+
+	ck_info->ulMaxSessionCount = sks_info->ulMaxSessionCount;
+	ck_info->ulSessionCount = sks_info->ulSessionCount;
+	ck_info->ulMaxRwSessionCount = sks_info->ulMaxRwSessionCount;
+	ck_info->ulRwSessionCount = sks_info->ulRwSessionCount;
+	ck_info->ulMaxPinLen = sks_info->ulMaxPinLen;
+	ck_info->ulMinPinLen = sks_info->ulMinPinLen;
+	ck_info->ulTotalPublicMemory = sks_info->ulTotalPublicMemory;
+	ck_info->ulFreePublicMemory = sks_info->ulFreePublicMemory;
+	ck_info->ulTotalPrivateMemory = sks_info->ulTotalPrivateMemory;
+	ck_info->ulFreePrivateMemory = sks_info->ulFreePrivateMemory;
+	MEMCPY_VERSION(ck_info, sks_info, hardwareVersion);
+	MEMCPY_VERSION(ck_info, sks_info, firmwareVersion);
+	MEMCPY_FIELD(ck_info, sks_info, utcTime);
+
+	return CKR_OK;
+}
+
+CK_RV sks2ck_session_info(CK_SESSION_INFO_PTR ck_info,
+			   struct sks_session_info *sks_info)
+{
+	ck_info->slotID = sks_info->slot_id;
+	ck_info->state = sks_info->state;
+	ck_info->flags = sks_info->flags;
+	ck_info->ulDeviceError = sks_info->error_code;
+
+	return CKR_OK;
+}
+
+/*
+ * Helpers for CK/SKS conversions: tables of identifiers
+ *
+ * Define conversion tables between Cryptoki IDs and SKS 32bit IDs.
+ * By convention, Cryptoki variable types CK_<XYZ> (i.e CK_ATTRIBUTE_TYPE)
+ * are registered through DECLARE_CK2SKS_FUNCTIONS(<xyz>); in ck_helpers.h
+ * and locally through DEFINE_CK2SKS_FUNCTIONS(<xyz>) in this source file.
+ *
+ * In the above description, <xyz> is the lower case equivalent of <XYZ>
+ * in Cryptoki variable type definition label. I.e, for type CK_ATTRIBUTE_TYPE:
+ *
+ * In header file:
+ *	DECLARE_CK2SKS_FUNCTIONS(attribute_type);
+ * In source file:
+ *	static const struct ck2sks attribute_type[] = {
+ *		CK2SKS_ID_BRACE(CKA_CLASS, SKS_CKA_CLASS),
+ *		CK2SKS_ID_BRACE(CKA_TOKEN, SKS_CKA_TOKEN),
+ *		...
+ *	};
+ *	DEFINE_CK2SKS_FUNCTIONS(attribute_type, CK_ATTRIBUTE_TYPE)
+ *
+ * The above code snipet declares and defines functions ck2sks_attribute_type()
+ * and sks2ck_attribute_type() using ID conversion array attribute type
+ * defines in the source file.
+ *
+ * Some Cryptoki variables types have mutliple ID enumerations that would
+ * conflict if merged into a single ID valid list. For exmaple the flag type
+ * CK_FLAGS is used by Cryptoki to enumerate mechanism flags, token flags and
+ * more. This implementation defines specific tables per ID scope.
+ * I.e:
+ *	mechanism_flags for CKF_<FOO> related to mechanism flags.
+ *	token_flags for  CKF_<FOO> related to token flags.
+ */
+struct ck2sks {
+	CK_ULONG ck;
+	uint32_t sks;
+	// TODO: string for both IDs
+};
+
+/*
+ * Macros to define the SKS identifier relate to a Cryptoki identifier.
+ * Use CK2SKS_ID() when SKS identifier label is SKS_<CK-label>.
+ * Use CK2SKS_BRACE() when specific SKS identifier regarding Cryptoki CK label.
+ */
+#define CK2SKS_ID(ck_id)		{ .ck = ck_id, .sks = SKS_ ## ck_id }
+#define CK2SKS_ID_BRACE(ck_id, sks_id)	{ .ck = ck_id, .sks = sks_id }
+
+#define SKS2CK(out, in, conv)		sks2ck(out, in, conv, ARRAY_SIZE(conv))
+#define CK2SKS(out, in, conv)		ck2sks(out, in, conv, ARRAY_SIZE(conv))
+
+#define DEFINE_CK2SKS_FUNCTIONS(_conv_table, _ck_typeof)	\
+	uint32_t ck2sks_ ## _conv_table(_ck_typeof ck)		\
+	{							\
+		uint32_t id;					\
+								\
+		if (CK2SKS(&id, ck, _conv_table))		\
+			return SKS_UNDEFINED_ID;		\
+								\
+		return id;					\
+	}							\
+	CK_RV sks2ck_ ## _conv_table(_ck_typeof *ck, uint32_t sks)	\
+	{							\
+		if (SKS2CK(ck, sks, _conv_table))		\
+			return CKR_GENERAL_ERROR;		\
+								\
+		return CKR_OK;					\
+	}
+
+static int sks2ck(CK_ULONG *out, uint32_t id,
+		  const struct ck2sks *conv, size_t count)
+{
+	size_t n;
+
+	for (n = 0; n < count; n++) {
+		if (id == conv[n].sks) {
+			*out = conv[n].ck;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int ck2sks(uint32_t *out, CK_ULONG id,
+		  const struct ck2sks *conv, size_t count)
+{
+	size_t n;
+
+	for (n = 0; n < count; n++) {
+		if (id == conv[n].ck) {
+			*out = conv[n].sks;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+/*
+ * Identifiers conversion tables and related functions definitions.
+ * Generic way goes:
+ *
+ * static const struct ck2sks <foo>[] = {
+ *		CK2SKS_ID_BRACE(CK[<X>]_<Y>),
+ *		CK2SKS_ID_BRACE(CK[<X>]_<Y>, SKS_<Z>),
+ * };
+ *
+ * DEFINE_CK2SKS_FUNCTIONS(<foo>, CK_<related-type-label>)
+ */
+static const struct ck2sks slot_flag[] = {
+	CK2SKS_ID_BRACE(CKF_TOKEN_PRESENT, SKS_CKFS_TOKEN_PRESENT),
+	CK2SKS_ID_BRACE(CKF_REMOVABLE_DEVICE, SKS_CKFS_REMOVABLE_DEVICE),
+	CK2SKS_ID_BRACE(CKF_HW_SLOT, SKS_CKFS_HW_SLOT),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(slot_flag, CK_FLAGS)
+
+static const struct ck2sks token_flag[] = {
+	CK2SKS_ID_BRACE(CKF_RNG,
+			SKS_CKFT_RNG),
+	CK2SKS_ID_BRACE(CKF_WRITE_PROTECTED,
+			SKS_CKFT_WRITE_PROTECTED),
+	CK2SKS_ID_BRACE(CKF_LOGIN_REQUIRED,
+			SKS_CKFT_LOGIN_REQUIRED),
+	CK2SKS_ID_BRACE(CKF_USER_PIN_INITIALIZED,
+			SKS_CKFT_USER_PIN_INITIALIZED),
+	CK2SKS_ID_BRACE(CKF_RESTORE_KEY_NOT_NEEDED,
+			SKS_CKFT_RESTORE_KEY_NOT_NEEDED),
+	CK2SKS_ID_BRACE(CKF_CLOCK_ON_TOKEN,
+			SKS_CKFT_CLOCK_ON_TOKEN),
+	CK2SKS_ID_BRACE(CKF_PROTECTED_AUTHENTICATION_PATH,
+			SKS_CKFT_PROTECTED_AUTHENTICATION_PATH),
+	CK2SKS_ID_BRACE(CKF_DUAL_CRYPTO_OPERATIONS,
+			SKS_CKFT_DUAL_CRYPTO_OPERATIONS),
+	CK2SKS_ID_BRACE(CKF_TOKEN_INITIALIZED,
+			SKS_CKFT_TOKEN_INITIALIZED),
+	CK2SKS_ID_BRACE(CKF_USER_PIN_COUNT_LOW,
+			SKS_CKFT_USER_PIN_COUNT_LOW),
+	CK2SKS_ID_BRACE(CKF_USER_PIN_FINAL_TRY,
+			SKS_CKFT_USER_PIN_FINAL_TRY),
+	CK2SKS_ID_BRACE(CKF_USER_PIN_LOCKED,
+			SKS_CKFT_USER_PIN_LOCKED),
+	CK2SKS_ID_BRACE(CKF_USER_PIN_TO_BE_CHANGED,
+			SKS_CKFT_USER_PIN_TO_BE_CHANGED),
+	CK2SKS_ID_BRACE(CKF_SO_PIN_COUNT_LOW,
+			SKS_CKFT_SO_PIN_COUNT_LOW),
+	CK2SKS_ID_BRACE(CKF_SO_PIN_FINAL_TRY,
+			SKS_CKFT_SO_PIN_FINAL_TRY),
+	CK2SKS_ID_BRACE(CKF_SO_PIN_LOCKED,
+			SKS_CKFT_SO_PIN_LOCKED),
+	CK2SKS_ID_BRACE(CKF_SO_PIN_TO_BE_CHANGED,
+			SKS_CKFT_SO_PIN_TO_BE_CHANGED),
+	CK2SKS_ID_BRACE(CKF_ERROR_STATE,
+			SKS_CKFT_ERROR_STATE),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(token_flag, CK_FLAGS)
+
+static const struct ck2sks attribute_type[] = {
+	CK2SKS_ID(CKA_CLASS),
+	CK2SKS_ID(CKA_KEY_TYPE),
+	CK2SKS_ID(CKA_VALUE),
+	CK2SKS_ID(CKA_VALUE_LEN),
+	CK2SKS_ID(CKA_LABEL),
+	CK2SKS_ID(CKA_WRAP_TEMPLATE),
+	CK2SKS_ID(CKA_UNWRAP_TEMPLATE),
+	CK2SKS_ID(CKA_DERIVE_TEMPLATE),
+	CK2SKS_ID(CKA_START_DATE),
+	CK2SKS_ID(CKA_END_DATE),
+	CK2SKS_ID(CKA_OBJECT_ID),
+	CK2SKS_ID(CKA_APPLICATION),
+	CK2SKS_ID(CKA_MECHANISM_TYPE),
+	CK2SKS_ID(CKA_ID),
+	CK2SKS_ID(CKA_ALLOWED_MECHANISMS),
+	CK2SKS_ID(CKA_EC_PARAMS),
+	CK2SKS_ID(CKA_EC_POINT),
+	CK2SKS_ID(CKA_MODULUS),
+	CK2SKS_ID(CKA_MODULUS_BITS),
+	CK2SKS_ID(CKA_PUBLIC_EXPONENT),
+	CK2SKS_ID(CKA_PRIVATE_EXPONENT),
+	CK2SKS_ID(CKA_PRIME_1),
+	CK2SKS_ID(CKA_PRIME_2),
+	CK2SKS_ID(CKA_EXPONENT_1),
+	CK2SKS_ID(CKA_EXPONENT_2),
+	CK2SKS_ID(CKA_COEFFICIENT),
+	CK2SKS_ID(CKA_SUBJECT),
+	CK2SKS_ID(CKA_PUBLIC_KEY_INFO),
+	CK2SKS_ID(CKA_CERTIFICATE_TYPE),
+	CK2SKS_ID(CKA_CERTIFICATE_CATEGORY),
+	CK2SKS_ID(CKA_ISSUER),
+	CK2SKS_ID(CKA_SERIAL_NUMBER),
+	CK2SKS_ID(CKA_URL),
+	CK2SKS_ID(CKA_HASH_OF_SUBJECT_PUBLIC_KEY),
+	CK2SKS_ID(CKA_HASH_OF_ISSUER_PUBLIC_KEY),
+	CK2SKS_ID(CKA_NAME_HASH_ALGORITHM),
+	CK2SKS_ID(CKA_KEY_GEN_MECHANISM),
+	/* Below are boolean attributes */
+	CK2SKS_ID(CKA_TOKEN),
+	CK2SKS_ID(CKA_PRIVATE),
+	CK2SKS_ID(CKA_TRUSTED),
+	CK2SKS_ID(CKA_SENSITIVE),
+	CK2SKS_ID(CKA_ENCRYPT),
+	CK2SKS_ID(CKA_DECRYPT),
+	CK2SKS_ID(CKA_WRAP),
+	CK2SKS_ID(CKA_UNWRAP),
+	CK2SKS_ID(CKA_SIGN),
+	CK2SKS_ID(CKA_SIGN_RECOVER),
+	CK2SKS_ID(CKA_VERIFY),
+	CK2SKS_ID(CKA_VERIFY_RECOVER),
+	CK2SKS_ID(CKA_DERIVE),
+	CK2SKS_ID(CKA_EXTRACTABLE),
+	CK2SKS_ID(CKA_LOCAL),
+	CK2SKS_ID(CKA_NEVER_EXTRACTABLE),
+	CK2SKS_ID(CKA_ALWAYS_SENSITIVE),
+	CK2SKS_ID(CKA_MODIFIABLE),
+	CK2SKS_ID(CKA_COPYABLE),
+	CK2SKS_ID(CKA_DESTROYABLE),
+	CK2SKS_ID(CKA_ALWAYS_AUTHENTICATE),
+	CK2SKS_ID(CKA_WRAP_WITH_TRUSTED),
+	/* Specifc SKS attribute IDs */
+	CK2SKS_ID_BRACE(CK_VENDOR_INVALID_ID, SKS_UNDEFINED_ID),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(attribute_type, CK_ATTRIBUTE_TYPE)
+
+static const struct ck2sks mechanism_type[] = {
+	CK2SKS_ID(CKM_MD5),
+	CK2SKS_ID(CKM_SHA_1),
+	CK2SKS_ID(CKM_SHA224),
+	CK2SKS_ID(CKM_SHA256),
+	CK2SKS_ID(CKM_SHA384),
+	CK2SKS_ID(CKM_SHA512),
+
+	CK2SKS_ID(CKM_AES_ECB),
+	CK2SKS_ID(CKM_AES_CBC),
+	CK2SKS_ID(CKM_AES_CBC_PAD),
+	CK2SKS_ID(CKM_AES_CTR),
+	CK2SKS_ID(CKM_AES_GCM),
+	CK2SKS_ID(CKM_AES_CCM),
+	CK2SKS_ID(CKM_AES_CTS),
+	CK2SKS_ID(CKM_AES_GMAC),
+	CK2SKS_ID(CKM_AES_CMAC),
+	CK2SKS_ID(CKM_AES_CMAC_GENERAL),
+	CK2SKS_ID(CKM_AES_ECB_ENCRYPT_DATA),
+	CK2SKS_ID(CKM_AES_CBC_ENCRYPT_DATA),
+	CK2SKS_ID(CKM_AES_KEY_GEN),
+	CK2SKS_ID(CKM_AES_XCBC_MAC),
+
+	CK2SKS_ID(CKM_GENERIC_SECRET_KEY_GEN),
+
+	CK2SKS_ID(CKM_MD5_HMAC),
+	CK2SKS_ID(CKM_SHA_1_HMAC),
+	CK2SKS_ID(CKM_SHA224_HMAC),
+	CK2SKS_ID(CKM_SHA256_HMAC),
+	CK2SKS_ID(CKM_SHA384_HMAC),
+	CK2SKS_ID(CKM_SHA512_HMAC),
+
+	CK2SKS_ID(CKM_EC_KEY_PAIR_GEN),
+	CK2SKS_ID(CKM_ECDSA),
+	CK2SKS_ID(CKM_ECDSA_SHA1),
+	CK2SKS_ID(CKM_ECDSA_SHA224),
+	CK2SKS_ID(CKM_ECDSA_SHA256),
+	CK2SKS_ID(CKM_ECDSA_SHA384),
+	CK2SKS_ID(CKM_ECDSA_SHA512),
+	CK2SKS_ID(CKM_ECDH1_DERIVE),
+	CK2SKS_ID(CKM_ECDH1_COFACTOR_DERIVE),
+	CK2SKS_ID(CKM_ECMQV_DERIVE),
+	CK2SKS_ID(CKM_ECDH_AES_KEY_WRAP),
+
+	CK2SKS_ID(CKM_RSA_PKCS_KEY_PAIR_GEN),
+	CK2SKS_ID(CKM_RSA_PKCS),
+	CK2SKS_ID(CKM_RSA_9796),
+	CK2SKS_ID(CKM_RSA_X_509),
+	CK2SKS_ID(CKM_SHA1_RSA_PKCS),
+	CK2SKS_ID(CKM_RSA_PKCS_OAEP),
+	CK2SKS_ID(CKM_RSA_PKCS_PSS),
+	CK2SKS_ID(CKM_SHA1_RSA_PKCS_PSS),
+	CK2SKS_ID(CKM_SHA256_RSA_PKCS),
+	CK2SKS_ID(CKM_SHA384_RSA_PKCS),
+	CK2SKS_ID(CKM_SHA512_RSA_PKCS),
+	CK2SKS_ID(CKM_SHA256_RSA_PKCS_PSS),
+	CK2SKS_ID(CKM_SHA384_RSA_PKCS_PSS),
+	CK2SKS_ID(CKM_SHA512_RSA_PKCS_PSS),
+	CK2SKS_ID(CKM_SHA224_RSA_PKCS),
+	CK2SKS_ID(CKM_SHA224_RSA_PKCS_PSS),
+	CK2SKS_ID(CKM_RSA_AES_KEY_WRAP),
+
+	CK2SKS_ID(CKM_DES_KEY_GEN),
+	CK2SKS_ID(CKM_DES_ECB),
+	CK2SKS_ID(CKM_DES_CBC),
+	CK2SKS_ID(CKM_DES_MAC),
+	CK2SKS_ID(CKM_DES_MAC_GENERAL),
+	CK2SKS_ID(CKM_DES_CBC_PAD),
+
+	CK2SKS_ID_BRACE(CK_VENDOR_INVALID_ID, SKS_UNDEFINED_ID),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(mechanism_type, CK_MECHANISM_TYPE)
+
+static const struct ck2sks mechanism_flag[] = {
+	CK2SKS_ID_BRACE(CKF_HW, SKS_CKFM_HW),
+	CK2SKS_ID_BRACE(CKF_ENCRYPT, SKS_CKFM_ENCRYPT),
+	CK2SKS_ID_BRACE(CKF_DECRYPT, SKS_CKFM_DECRYPT),
+	CK2SKS_ID_BRACE(CKF_DIGEST, SKS_CKFM_DIGEST),
+	CK2SKS_ID_BRACE(CKF_SIGN, SKS_CKFM_SIGN),
+	CK2SKS_ID_BRACE(CKF_SIGN_RECOVER, SKS_CKFM_SIGN_RECOVER),
+	CK2SKS_ID_BRACE(CKF_VERIFY, SKS_CKFM_VERIFY),
+	CK2SKS_ID_BRACE(CKF_VERIFY_RECOVER, SKS_CKFM_VERIFY_RECOVER),
+	CK2SKS_ID_BRACE(CKF_GENERATE, SKS_CKFM_GENERATE),
+	CK2SKS_ID_BRACE(CKF_GENERATE_KEY_PAIR, SKS_CKFM_GENERATE_PAIR),
+	CK2SKS_ID_BRACE(CKF_WRAP, SKS_CKFM_WRAP),
+	CK2SKS_ID_BRACE(CKF_UNWRAP, SKS_CKFM_UNWRAP),
+	CK2SKS_ID_BRACE(CKF_DERIVE, SKS_CKFM_DERIVE),
+	CK2SKS_ID_BRACE(CKF_EC_F_P, SKS_CKFM_EC_F_P),
+	CK2SKS_ID_BRACE(CKF_EC_F_2M, SKS_CKFM_EC_F_2M),
+	CK2SKS_ID_BRACE(CKF_EC_ECPARAMETERS, SKS_CKFM_EC_ECPARAMETERS),
+	CK2SKS_ID_BRACE(CKF_EC_NAMEDCURVE, SKS_CKFM_EC_NAMEDCURVE),
+	CK2SKS_ID_BRACE(CKF_EC_UNCOMPRESS, SKS_CKFM_EC_UNCOMPRESS),
+	CK2SKS_ID_BRACE(CKF_EC_COMPRESS, SKS_CKFM_EC_COMPRESS),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(mechanism_flag, CK_FLAGS)
+
+static const struct ck2sks object_class[] = {
+	CK2SKS_ID(CKO_SECRET_KEY),
+	CK2SKS_ID(CKO_PUBLIC_KEY),
+	CK2SKS_ID(CKO_PRIVATE_KEY),
+	CK2SKS_ID(CKO_OTP_KEY),
+	CK2SKS_ID(CKO_CERTIFICATE),
+	CK2SKS_ID(CKO_DATA),
+	CK2SKS_ID(CKO_DOMAIN_PARAMETERS),
+	CK2SKS_ID(CKO_HW_FEATURE),
+	CK2SKS_ID(CKO_MECHANISM),
+	CK2SKS_ID_BRACE(CK_VENDOR_INVALID_ID, SKS_UNDEFINED_ID),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(object_class, CK_OBJECT_CLASS)
+
+static const struct ck2sks key_type[] = {
+	CK2SKS_ID(CKK_AES),
+	CK2SKS_ID(CKK_GENERIC_SECRET),
+	CK2SKS_ID(CKK_MD5_HMAC),
+	CK2SKS_ID(CKK_SHA_1_HMAC),
+	CK2SKS_ID(CKK_SHA224_HMAC),
+	CK2SKS_ID(CKK_SHA256_HMAC),
+	CK2SKS_ID(CKK_SHA384_HMAC),
+	CK2SKS_ID(CKK_SHA512_HMAC),
+	CK2SKS_ID(CKK_RSA),
+	CK2SKS_ID(CKK_EC),
+	CK2SKS_ID(CKK_DSA),
+	CK2SKS_ID(CKK_DH),
+	CK2SKS_ID(CKK_DES),
+	CK2SKS_ID(CKK_DES2),
+	CK2SKS_ID(CKK_DES3),
+	CK2SKS_ID_BRACE(CK_VENDOR_INVALID_ID, SKS_UNDEFINED_ID),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(key_type, CK_KEY_TYPE)
+
+static const struct ck2sks certificate_type[] = {
+	CK2SKS_ID(CKC_X_509),
+	CK2SKS_ID(CKC_X_509_ATTR_CER),
+	CK2SKS_ID(CKC_WTLS),
+	CK2SKS_ID_BRACE(CK_VENDOR_INVALID_ID, SKS_UNDEFINED_ID),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(certificate_type, CK_CERTIFICATE_TYPE)
+
+static const struct ck2sks ec_kdf_type[] = {
+	CK2SKS_ID(CKD_NULL),
+	CK2SKS_ID(CKD_SHA1_KDF),
+	CK2SKS_ID(CKD_SHA1_KDF_ASN1),
+	CK2SKS_ID(CKD_SHA1_KDF_CONCATENATE),
+	CK2SKS_ID(CKD_SHA224_KDF),
+	CK2SKS_ID(CKD_SHA256_KDF),
+	CK2SKS_ID(CKD_SHA384_KDF),
+	CK2SKS_ID(CKD_SHA512_KDF),
+	CK2SKS_ID(CKD_CPDIVERSIFY_KDF),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(ec_kdf_type, CK_EC_KDF_TYPE)
+
+static const struct ck2sks rsa_pkcs_mgf_type[] = {
+	CK2SKS_ID(CKG_MGF1_SHA1),
+	CK2SKS_ID(CKG_MGF1_SHA224),
+	CK2SKS_ID(CKG_MGF1_SHA256),
+	CK2SKS_ID(CKG_MGF1_SHA384),
+	CK2SKS_ID(CKG_MGF1_SHA512),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(rsa_pkcs_mgf_type, CK_RSA_PKCS_MGF_TYPE)
+
+static const struct ck2sks rsa_pkcs_oaep_source_type[] = {
+	CK2SKS_ID(CKZ_DATA_SPECIFIED),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(rsa_pkcs_oaep_source_type, CK_RSA_PKCS_OAEP_SOURCE_TYPE)
+
+static const struct ck2sks user_type[] = {
+	CK2SKS_ID(CKU_SO),
+	CK2SKS_ID(CKU_USER),
+	CK2SKS_ID(CKU_CONTEXT_SPECIFIC),
+};
+
+DEFINE_CK2SKS_FUNCTIONS(user_type, CK_USER_TYPE)
+
+static const struct ck2sks error_code[] = {
+	CK2SKS_ID(CKR_OK),
+	CK2SKS_ID(CKR_GENERAL_ERROR),
+	CK2SKS_ID(CKR_DEVICE_MEMORY),
+	CK2SKS_ID(CKR_ARGUMENTS_BAD),
+	CK2SKS_ID(CKR_BUFFER_TOO_SMALL),
+	CK2SKS_ID(CKR_FUNCTION_FAILED),
+	CK2SKS_ID(CKR_ATTRIBUTE_TYPE_INVALID),
+	CK2SKS_ID(CKR_ATTRIBUTE_VALUE_INVALID),
+	CK2SKS_ID(CKR_OBJECT_HANDLE_INVALID),
+	CK2SKS_ID(CKR_KEY_HANDLE_INVALID),
+	CK2SKS_ID(CKR_MECHANISM_INVALID),
+	CK2SKS_ID(CKR_SLOT_ID_INVALID),
+	CK2SKS_ID(CKR_SESSION_HANDLE_INVALID),
+	CK2SKS_ID(CKR_PIN_INCORRECT),
+	CK2SKS_ID(CKR_PIN_LOCKED),
+	CK2SKS_ID(CKR_PIN_EXPIRED),
+	CK2SKS_ID(CKR_PIN_INVALID),
+	CK2SKS_ID(CKR_OPERATION_ACTIVE),
+	CK2SKS_ID(CKR_KEY_FUNCTION_NOT_PERMITTED),
+	CK2SKS_ID(CKR_KEY_TYPE_INCONSISTENT),
+	CK2SKS_ID(CKR_OPERATION_NOT_INITIALIZED),
+	CK2SKS_ID(CKR_SESSION_READ_ONLY),
+	CK2SKS_ID(CKR_MECHANISM_PARAM_INVALID),
+	CK2SKS_ID(CKR_TOKEN_WRITE_PROTECTED),
+	CK2SKS_ID(CKR_TOKEN_NOT_PRESENT),
+	CK2SKS_ID(CKR_TOKEN_NOT_RECOGNIZED),
+	CK2SKS_ID(CKR_ACTION_PROHIBITED),
+	CK2SKS_ID(CKR_ATTRIBUTE_READ_ONLY),
+	CK2SKS_ID(CKR_PIN_TOO_WEAK),
+	CK2SKS_ID(CKR_CURVE_NOT_SUPPORTED),
+	CK2SKS_ID(CKR_DOMAIN_PARAMS_INVALID),
+	CK2SKS_ID(CKR_USER_ALREADY_LOGGED_IN),
+	CK2SKS_ID(CKR_USER_ANOTHER_ALREADY_LOGGED_IN),
+	CK2SKS_ID(CKR_USER_NOT_LOGGED_IN),
+	CK2SKS_ID(CKR_USER_PIN_NOT_INITIALIZED),
+	CK2SKS_ID(CKR_USER_TOO_MANY_TYPES),
+	CK2SKS_ID(CKR_USER_TYPE_INVALID),
+	CK2SKS_ID(CKR_SESSION_READ_ONLY_EXISTS),
+	CK2SKS_ID(CKR_SESSION_READ_WRITE_SO_EXISTS),
+	CK2SKS_ID(CKR_SESSION_EXISTS),
+	CK2SKS_ID(CKR_TEMPLATE_INCOMPLETE),
+	CK2SKS_ID(CKR_TEMPLATE_INCONSISTENT),
+	CK2SKS_ID(CKR_SIGNATURE_INVALID),
+	CK2SKS_ID(CKR_ATTRIBUTE_SENSITIVE),
+	CK2SKS_ID(CKR_SIGNATURE_LEN_RANGE),
+	CK2SKS_ID(CKR_DATA_LEN_RANGE),
+	CK2SKS_ID(CKR_ENCRYPTED_DATA_LEN_RANGE),
+	CK2SKS_ID_BRACE(CK_VENDOR_INVALID_ID, SKS_UNDEFINED_ID),
+};
+
+CK_RV sks2ck_rv(uint32_t sks)
+{
+	CK_ULONG rv;
+
+	if (SKS2CK(&rv, sks, error_code))
+		return CKR_GENERAL_ERROR;
+
+	return (CK_RV)rv;
+}
+
+CK_RV teec2ck_rv(TEEC_Result res)
+{
+	switch (res) {
+	case TEEC_SUCCESS:
+		return CKR_OK;
+	case TEEC_ERROR_OUT_OF_MEMORY:
+		return CKR_DEVICE_MEMORY;
+	case TEEC_ERROR_BAD_PARAMETERS:
+		return CKR_ARGUMENTS_BAD;
+	case TEEC_ERROR_SHORT_BUFFER:
+		return CKR_BUFFER_TOO_SMALL;
+	default:
+		return CKR_FUNCTION_FAILED;
+	}
+}
+/* Convert a array of mechanism type from sks into CK_MECHANIMS_TYPE */
+CK_RV sks2ck_mechanism_type_list(CK_MECHANISM_TYPE *dst,
+				 void *src, size_t count)
+{
+	CK_MECHANISM_TYPE *ck = dst;
+	char *sks = src;
+	size_t n;
+	uint32_t proc;
+
+	for (n = 0; n < count; n++, sks += sizeof(uint32_t), ck++) {
+		memcpy(&proc, sks, sizeof(proc));
+		if (sks2ck_mechanism_type(ck, proc))
+			return CKR_MECHANISM_INVALID;
+	}
+
+	return CKR_OK;
+}
+
+/* Convert structure CK_MECHANIMS_INFO from sks to ck (3 ulong fields) */
+CK_RV sks2ck_mechanism_info(CK_MECHANISM_INFO *info, void *src)
+{
+	struct sks_mechanism_info sks;
+	CK_FLAGS ck_flag;
+	uint32_t mask;
+	CK_RV rv;
+
+	memcpy(&sks, src, sizeof(sks));
+
+	info->ulMinKeySize = sks.min_key_size;
+	info->ulMaxKeySize = sks.max_key_size;
+
+	info->flags = 0;
+	for (mask = 1; mask; mask <<= 1) {
+		if (!(sks.flags & mask))
+			continue;
+
+		rv = sks2ck_mechanism_flag(&ck_flag, mask);
+		if (rv)
+			return rv;
+
+		info->flags |= ck_flag;
+	}
+
+	return CKR_OK;
+}
+
+/*
+ * Helper functions to analyse CK fields
+ */
+size_t ck_attr_is_class(uint32_t id)
+{
+	if (id == CKA_CLASS)
+		return sizeof(CK_ULONG);
+	else
+		return 0;
+}
+
+size_t ck_attr_is_type(uint32_t id)
+{
+	switch (id) {
+	case CKA_CERTIFICATE_TYPE:
+	case CKA_KEY_TYPE:
+	case CKA_HW_FEATURE_TYPE:
+	case CKA_MECHANISM_TYPE:
+	case CKA_KEY_GEN_MECHANISM:
+		return sizeof(CK_ULONG);
+	default:
+		return 0;
+	}
+}
+int sks_object_has_boolprop(uint32_t class)
+{
+	switch (class) {
+	case SKS_CKO_DATA:
+	case SKS_CKO_CERTIFICATE:
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_DOMAIN_PARAMETERS:
+		return 1;
+	default:
+		return 0;
+	}
+}
+int sks_class_has_type(uint32_t class)
+{
+	switch (class) {
+	case SKS_CKO_CERTIFICATE:
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_MECHANISM:
+	case SKS_CKO_HW_FEATURE:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+uint32_t ck2sks_type_in_class(CK_ULONG ck, CK_ULONG class)
+{
+	switch (class) {
+	case CKO_DATA:
+		return 0;
+	case CKO_SECRET_KEY:
+	case CKO_PUBLIC_KEY:
+	case CKO_PRIVATE_KEY:
+	case CKO_OTP_KEY:
+		return ck2sks_key_type(ck);
+	case CKO_MECHANISM:
+		return ck2sks_mechanism_type(ck);
+	case CKO_CERTIFICATE:
+		return ck2sks_certificate_type(ck);
+	default:
+		return SKS_UNDEFINED_ID;
+	}
+}
+
+CK_RV sks2ck_type_in_class(CK_ULONG *ck, uint32_t sks, CK_ULONG class)
+{
+	switch (class) {
+	case SKS_CKO_DATA:
+		return CKR_NO_EVENT;
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+	case SKS_CKO_OTP_KEY:
+		return sks2ck_key_type(ck, sks);
+	case SKS_CKO_MECHANISM:
+		return sks2ck_mechanism_type(ck, sks);
+	case SKS_CKO_CERTIFICATE:
+		return sks2ck_certificate_type(ck, sks);
+	default:
+		return CKR_GENERAL_ERROR;
+	}
+}
+
+CK_RV ck_guess_key_type(CK_MECHANISM_PTR mecha,
+			CK_ATTRIBUTE_PTR attrs, CK_ULONG_PTR count,
+			CK_ATTRIBUTE_PTR *attrs_new_p)
+{
+	size_t n;
+	CK_ULONG count_new = *count;
+	CK_ATTRIBUTE_PTR attrs_new = NULL;
+	CK_KEY_TYPE_PTR key_type_p = NULL;
+	int key_type_present = 0;
+	CK_RV rv;
+
+	for (n = 0; n < *count; n++) {
+		if (attrs[n].type == CKA_KEY_TYPE) {
+			key_type_present = 1;
+			break;
+		}
+	}
+	if (!key_type_present)
+		count_new++;
+
+	attrs_new = malloc(count_new * sizeof(CK_ATTRIBUTE));
+	if (attrs_new == NULL)
+		return CKR_HOST_MEMORY;
+
+	memcpy(attrs_new, attrs, (*count) * sizeof(CK_ATTRIBUTE));
+
+	if (key_type_present) {
+		rv = CKR_OK;
+		goto bail;
+	}
+
+	key_type_p = malloc(sizeof(CK_KEY_TYPE));
+	if (key_type_p == NULL) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	switch (mecha->mechanism) {
+	case CKM_RSA_PKCS_KEY_PAIR_GEN:
+		*key_type_p = CKK_RSA;
+		attrs_new[count_new - 1].type = CKA_KEY_TYPE;
+		attrs_new[count_new - 1].pValue = key_type_p;
+		attrs_new[count_new - 1].ulValueLen = sizeof(CK_KEY_TYPE);
+		rv = CKR_OK;
+		break;
+	case CKM_EC_KEY_PAIR_GEN:
+		*key_type_p = CKK_EC;
+		attrs_new[count_new - 1].type = CKA_KEY_TYPE;
+		attrs_new[count_new - 1].pValue = key_type_p;
+		attrs_new[count_new - 1].ulValueLen = sizeof(CK_KEY_TYPE);
+		rv = CKR_OK;
+		break;
+	default:
+		rv = CKR_TEMPLATE_INCOMPLETE;
+		break;
+	}
+
+bail:
+	if (rv == CKR_OK) {
+		*attrs_new_p = attrs_new;
+		*count = count_new;
+	} else {
+		if (attrs_new)
+			free(attrs_new);
+		if (key_type_p)
+			free(key_type_p);
+	}
+
+	return rv;
+}
diff --git a/libsks/src/ck_helpers.h b/libsks/src/ck_helpers.h
new file mode 100644
index 0000000..e8369a1
--- /dev/null
+++ b/libsks/src/ck_helpers.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __HELPERS_CK_H
+#define __HELPERS_CK_H
+
+#include <pkcs11.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <sks_ta.h>
+#include <tee_client_api.h>
+
+/*
+ * SKS reserves vendor ID 0xffffffff to represent an invalid ID
+ * (attribute class, type, ...)
+ */
+#define CK_VENDOR_INVALID_ID		0xffffffffUL
+#define SKS_CK_VENDOR_INVALID_ID	0xffffffffUL
+
+/* Helper for sks2ck_xxx() and ck2sks_xxx() helper declaration */
+#define DECLARE_CK2SKS_FUNCTIONS(_label, _ck_typeof)		\
+	uint32_t ck2sks_ ## _label(_ck_typeof ck);	\
+	CK_RV sks2ck_ ## _label(_ck_typeof *ck, uint32_t sks)
+
+DECLARE_CK2SKS_FUNCTIONS(slot_flag, CK_FLAGS);
+DECLARE_CK2SKS_FUNCTIONS(token_flag, CK_FLAGS);
+DECLARE_CK2SKS_FUNCTIONS(user_type, CK_USER_TYPE);
+DECLARE_CK2SKS_FUNCTIONS(attribute_type, CK_ATTRIBUTE_TYPE);
+DECLARE_CK2SKS_FUNCTIONS(mechanism_type, CK_MECHANISM_TYPE);
+DECLARE_CK2SKS_FUNCTIONS(mechanism_flag, CK_FLAGS);
+DECLARE_CK2SKS_FUNCTIONS(object_class, CK_OBJECT_CLASS);
+DECLARE_CK2SKS_FUNCTIONS(key_type, CK_KEY_TYPE);
+DECLARE_CK2SKS_FUNCTIONS(ec_kdf_type, CK_EC_KDF_TYPE);
+DECLARE_CK2SKS_FUNCTIONS(rsa_pkcs_mgf_type, CK_RSA_PKCS_MGF_TYPE);
+DECLARE_CK2SKS_FUNCTIONS(rsa_pkcs_oaep_source_type,
+			 CK_RSA_PKCS_OAEP_SOURCE_TYPE);
+DECLARE_CK2SKS_FUNCTIONS(certificate_type, CK_CERTIFICATE_TYPE);
+
+/*
+ * Convert structure struct sks_token_info retreived from TA into a
+ * cryptoki API compliant CK_TOKEN_INFO structure.
+ *
+ * struct sks_token_info is defined in the SKS TA API.
+ */
+CK_RV sks2ck_token_info(CK_TOKEN_INFO_PTR ck_info,
+			struct sks_token_info *sks_info);
+CK_RV sks2ck_slot_info(CK_SLOT_INFO_PTR ck_info,
+			struct sks_slot_info *sks_info);
+CK_RV sks2ck_session_info(CK_SESSION_INFO_PTR ck_info,
+			struct sks_session_info *sks_info);
+
+/* Backward compat on deprecated functions */
+static inline CK_RV sks2ck_attribute_id(CK_ATTRIBUTE_TYPE *ck, uint32_t sks)
+{
+	return sks2ck_attribute_type(ck, sks);
+}
+
+static inline uint32_t ck2sks_attribute_id(CK_ATTRIBUTE_TYPE ck)
+{
+	return ck2sks_attribute_type(ck);
+}
+
+static inline CK_RV sks2ck_class(CK_OBJECT_CLASS *ck, uint32_t sks)
+{
+	return sks2ck_object_class(ck, sks);
+}
+
+static inline uint32_t ck2sks_class(CK_OBJECT_CLASS ck)
+{
+	return ck2sks_object_class(ck);
+}
+
+CK_RV sks2ck_mechanism_type_list(CK_MECHANISM_TYPE *dst, void *sks,
+				 size_t count);
+CK_RV sks2ck_mechanism_info(CK_MECHANISM_INFO *info, void *sks);
+
+uint32_t ck2sks_type_in_class(CK_ULONG ck, CK_ULONG class);
+CK_RV sks2ck_type_in_class(CK_ULONG *ck, uint32_t sks, CK_ULONG class);
+
+int sks_attr2boolprop_shift(CK_ULONG attr);
+
+CK_RV sks2ck_rv(uint32_t sks);
+CK_RV teec2ck_rv(TEEC_Result res);
+
+/*
+ * Helper functions to analyse CK fields
+ */
+size_t ck_attr_is_class(uint32_t attribute_id);
+size_t ck_attr_is_type(uint32_t attribute_id);
+int ck_attr2boolprop_shift(CK_ULONG attr);
+
+int sks_object_has_boolprop(uint32_t class);
+int sks_class_has_type(uint32_t class);
+
+/*
+ * Try to guess key type if mechanism is key generation
+ *
+ * @mech: Referecn to mechanism
+ * @attrs; Reference to input object attributes
+ * @count: number of attributes for the object, output value may be incremented
+ * @attrs_new_p: Referenece to output attributes, always defines the key type
+ *
+ * This may be needed because some tools (e.g.: pkcs11-tool) may not specify
+ * some attributes as key type when these can be assumed from the mechanism
+ * type.
+ *
+ * The function allocates memory for a copy of the attributes since it could
+ * be increased when adding the missing attribute. Caller is responsible from
+ * freeing the output attribute references.
+ */
+CK_RV ck_guess_key_type(CK_MECHANISM_PTR mecha,
+		       CK_ATTRIBUTE_PTR attrs, CK_ULONG_PTR count,
+		       CK_ATTRIBUTE_PTR *attrs_new_p);
+
+#endif /*__HELPERS_CK_H*/
diff --git a/libsks/src/invoke_ta.c b/libsks/src/invoke_ta.c
new file mode 100644
index 0000000..3623557
--- /dev/null
+++ b/libsks/src/invoke_ta.c
@@ -0,0 +1,358 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <pkcs11.h>
+#include <sks_ta.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ck_helpers.h"
+#include "invoke_ta.h"
+#include "local_utils.h"
+
+/*
+ * All requests (invocation of the SKS) currently go through a
+ * single GPD TEE session toward the SKS TA.
+ */
+struct sks_primary_context {
+	TEEC_Context context;
+	TEEC_Session session;
+};
+
+static struct sks_primary_context primary_ctx;
+static struct sks_invoke primary_invoke;
+
+static int uuid_from_string(TEEC_UUID *d, const char *s)
+{
+	const char *node;
+	char buf[3];
+	int i = 0;
+
+	/* UUID = 00000000-0000-0000-0000-000000000000 */
+	if (strlen(s) != 36)
+		return -1;
+	if (s[8] != '-' || s[13] != '-' ||
+			s[18] != '-' || s[23] != '-') {
+		LOG_ERROR("Invalid UUID format\n");
+		return -1;
+	}
+
+	memset(d, 0, sizeof(TEEC_UUID));
+
+	d->timeLow = strtoul(s, NULL, 16);
+	d->timeMid = strtoul(s + 9, NULL, 16);
+	d->timeHiAndVersion = strtoul(s + 14, NULL, 16);
+
+	buf[2] = '\0';
+	memcpy(&buf, s + 19, sizeof(uint16_t));
+	d->clockSeqAndNode[0] = strtoul(buf, NULL, 16);
+	memcpy(&buf, s + 21, sizeof(uint16_t));
+	d->clockSeqAndNode[1] = strtoul(buf, NULL, 16);
+
+	node = s + 24;
+	for (i = 2; i < 8; i++) {
+		buf[0] = *node++;
+		buf[1] = *node++;
+		d->clockSeqAndNode[i] = strtoul(buf, NULL, 16);
+	}
+
+	return 0;
+}
+
+static int open_primary_context(void)
+{
+	TEEC_UUID uuid;
+	uint32_t origin;
+	TEEC_Result res;
+
+	/* TODO: mutex */
+	if (primary_invoke.session)
+		return 0;
+
+	res = TEEC_InitializeContext(NULL, &primary_ctx.context);
+	if (res != TEEC_SUCCESS) {
+		LOG_ERROR("TEEC init context failed\n");
+		return -1;
+	}
+
+	if (uuid_from_string(&uuid, (const char*)TA_SKS_UUID)) {
+		LOG_ERROR("Failed to parse TA UUID\n");
+		return -1;
+	}
+
+	/* TODO: application could provide a knwon login ID */
+	res = TEEC_OpenSession(&primary_ctx.context, &primary_ctx.session,
+				&uuid, TEEC_LOGIN_PUBLIC, NULL, NULL, &origin);
+	if (res != TEEC_SUCCESS) {
+		LOG_ERROR("TEEC open session failed %x from %d\n", res, origin);
+		TEEC_FinalizeContext(&primary_ctx.context);
+		return -1;
+	}
+
+	primary_invoke.context = &primary_ctx.context;
+	primary_invoke.session = &primary_ctx.session;
+
+	return 0;
+}
+
+static void close_primary_context(void)
+{
+	/*  TODO: mutex */
+	if (!primary_invoke.session)
+		return;
+
+	TEEC_CloseSession(&primary_ctx.session);
+	TEEC_FinalizeContext(&primary_ctx.context);
+	primary_invoke.context = NULL;
+	primary_invoke.session = NULL;
+}
+
+static struct sks_invoke *get_invoke_context(struct sks_invoke *sks_ctx)
+{
+	struct sks_invoke *ctx = sks_ctx;
+
+	if (open_primary_context())
+		return NULL;
+
+	if (!ctx)
+		return &primary_invoke;
+
+	if (!ctx->context)
+		ctx->context = primary_invoke.context;
+	if (!ctx->session)
+		ctx->session = primary_invoke.session;
+
+	return ctx;
+}
+
+static TEEC_Context *teec_ctx(struct sks_invoke *sks_ctx)
+{
+	return (TEEC_Context *)sks_ctx->context;
+}
+
+static TEEC_Session *teec_sess(struct sks_invoke *sks_ctx)
+{
+	return (TEEC_Session *)sks_ctx->session;
+}
+
+TEEC_SharedMemory *sks_alloc_shm(struct sks_invoke *sks_ctx,
+				 size_t size, int in, int out)
+{
+	struct sks_invoke *ctx = get_invoke_context(sks_ctx);
+	TEEC_SharedMemory *shm;
+
+	if (!ctx || (!in && !out))
+		return NULL;
+
+	shm = calloc(1, sizeof(TEEC_SharedMemory));
+	if (!shm)
+		return NULL;
+
+	shm->size = size;
+
+	if (in)
+		shm->flags |= TEEC_MEM_INPUT;
+	if (out)
+		shm->flags |= TEEC_MEM_OUTPUT;
+
+	if (TEEC_AllocateSharedMemory(teec_ctx(ctx), shm)) {
+		free(shm);
+		return NULL;
+	}
+
+	return shm;
+}
+
+TEEC_SharedMemory *sks_register_shm(struct sks_invoke *sks_ctx,
+				    void *buf, size_t size, int in, int out)
+{
+	struct sks_invoke *ctx = get_invoke_context(sks_ctx);
+	TEEC_SharedMemory *shm;
+
+	if (!ctx || (!in && !out))
+		return NULL;
+
+	shm = calloc(1, sizeof(TEEC_SharedMemory));
+	if (!shm)
+		return NULL;
+
+	shm->buffer = buf;
+	shm->size = size;
+
+	if (in)
+		shm->flags |= TEEC_MEM_INPUT;
+	if (out)
+		shm->flags |= TEEC_MEM_OUTPUT;
+
+	if (TEEC_RegisterSharedMemory(teec_ctx(ctx), shm)) {
+		free(shm);
+		return NULL;
+	}
+
+	return shm;
+}
+
+void sks_free_shm(TEEC_SharedMemory *shm)
+{
+	TEEC_ReleaseSharedMemory(shm);
+	free(shm);
+}
+
+#define DIR_IN			1
+#define DIR_OUT			0
+#define DIR_NONE		-1
+
+static CK_RV invoke_ta(struct sks_invoke *sks_ctx, unsigned long cmd,
+			void *ctrl, size_t ctrl_sz,
+			void *io1, size_t *io1_sz, int io1_dir,
+			void *io2, size_t *io2_sz, int io2_dir)
+{
+	struct sks_invoke *ctx = get_invoke_context(sks_ctx);
+	uint32_t command = (uint32_t)cmd;
+	TEEC_Operation op;
+	uint32_t origin;
+	TEEC_Result res;
+	TEEC_SharedMemory *ctrl_shm = ctrl;
+	TEEC_SharedMemory *io1_shm = io1;
+	TEEC_SharedMemory *io2_shm = io2;
+	uint32_t sks_rc;
+
+	memset(&op, 0, sizeof(op));
+
+	/*
+	 * Command control field: TEE invocation parameter #0
+	 */
+	if (ctrl && ctrl_sz) {
+		op.params[0].tmpref.buffer = ctrl;
+		op.params[0].tmpref.size = ctrl_sz;
+		op.paramTypes |= TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INOUT,
+						  0, 0, 0);
+	}
+	if (ctrl && !ctrl_sz) {
+		op.params[0].memref.parent = ctrl_shm;
+		op.paramTypes |= TEEC_PARAM_TYPES(TEEC_MEMREF_WHOLE, 0, 0, 0);
+	}
+
+	/*
+	 * IO data TEE invocation parameter #1
+	 */
+	if (io1_sz && (io1_dir == DIR_OUT || (io1_dir == DIR_IN && *io1_sz))) {
+		op.params[1].tmpref.buffer = io1;
+		op.params[1].tmpref.size = *io1_sz;
+		op.paramTypes |= TEEC_PARAM_TYPES(0, io1_dir == DIR_IN ?
+						  TEEC_MEMREF_TEMP_INPUT :
+						  TEEC_MEMREF_TEMP_OUTPUT,
+						  0, 0);
+	}
+	if (io1_dir != DIR_NONE && !io1_sz && io1) {
+		op.params[1].memref.parent = io1_shm;
+		op.paramTypes |= TEEC_PARAM_TYPES(0, TEEC_MEMREF_WHOLE, 0, 0);
+	}
+
+	/*
+	 * IO data TEE invocation parameter #2
+	 */
+	if (io2_sz && (io2_dir == DIR_OUT || (io2_dir == DIR_IN && *io2_sz))) {
+		op.params[2].tmpref.buffer = io2;
+		op.params[2].tmpref.size = *io2_sz;
+		op.paramTypes |= TEEC_PARAM_TYPES(0, 0, io2_dir == DIR_IN ?
+						  TEEC_MEMREF_TEMP_INPUT :
+						  TEEC_MEMREF_TEMP_OUTPUT,
+						  0);
+	}
+	if (io2_dir != DIR_NONE && !io2_sz && io2) {
+		op.params[2].memref.parent = io2_shm;
+		op.paramTypes |= TEEC_PARAM_TYPES(0, 0, TEEC_MEMREF_WHOLE, 0);
+	}
+
+#if defined(CFG_SKS_CMD_AS_PARAM)
+	op.params[3].value.a = command;
+	op.paramTypes |= TEEC_PARAM_TYPES(0, 0, 0, TEEC_VALUE_INPUT);
+	command = TEE_SKS_CMD_IDENTIFIER;
+#endif /* CFG_SKS_CMD_AS_PARAM */
+
+	/*
+	 * Invoke the TEE and update output buffer size on exit.
+	 * Too short buffers are treated as positive errors.
+	 */
+	res = TEEC_InvokeCommand(teec_sess(ctx), command, &op, &origin);
+
+	if (res) {
+		if (res == TEEC_ERROR_SHORT_BUFFER) {
+			if (io1_dir == DIR_OUT && io1_sz)
+				*io1_sz = op.params[1].tmpref.size;
+			if (io2_dir == DIR_OUT && io2_sz)
+				*io2_sz = op.params[2].tmpref.size;
+		}
+
+		return teec2ck_rv(res);
+	}
+
+	/* Get SKS return value from ctrl buffer, if none we expect success */
+	if (ctrl &&
+	    ((ctrl_sz && op.params[0].tmpref.size == sizeof(uint32_t)) ||
+	    (!ctrl_sz && op.params[0].memref.size == sizeof(uint32_t)))) {
+		memcpy(&sks_rc, ctrl, sizeof(uint32_t));
+	} else {
+		sks_rc = SKS_CKR_OK;
+	}
+
+	if (sks_rc == SKS_CKR_OK || sks_rc == SKS_CKR_BUFFER_TOO_SMALL) {
+		if (io1_dir == DIR_OUT && io1_sz)
+			*io1_sz = op.params[1].tmpref.size;
+		if (io2_dir == DIR_OUT && io2_sz)
+			*io2_sz = op.params[2].tmpref.size;
+	}
+
+	return sks2ck_rv(sks_rc);
+}
+
+CK_RV ck_invoke_ta(struct sks_invoke *sks_ctx,
+		   unsigned long cmd,
+		   void *ctrl, size_t ctrl_sz)
+{
+	return invoke_ta(sks_ctx, cmd, ctrl, ctrl_sz,
+			 NULL, NULL, DIR_NONE,
+			 NULL, NULL, DIR_NONE);
+}
+
+CK_RV ck_invoke_ta_in(struct sks_invoke *sks_ctx,
+		      unsigned long cmd,
+		      void *ctrl, size_t ctrl_sz,
+		      void *in, size_t in_sz)
+{
+	return invoke_ta(sks_ctx, cmd, ctrl, ctrl_sz,
+			 in, &in_sz, DIR_IN,
+			 NULL, NULL, DIR_NONE);
+}
+
+
+CK_RV ck_invoke_ta_in_out(struct sks_invoke *sks_ctx,
+		   unsigned long cmd,
+		   void *ctrl, size_t ctrl_sz,
+		   void *in, size_t in_sz,
+		   void *out, size_t *out_sz)
+{
+	return invoke_ta(sks_ctx, cmd, ctrl, ctrl_sz,
+			 in, &in_sz, DIR_IN,
+			 out, out_sz, DIR_OUT);
+}
+
+CK_RV ck_invoke_ta_in_in(struct sks_invoke *sks_ctx,
+		   unsigned long cmd,
+		   void *ctrl, size_t ctrl_sz,
+		   void *in, size_t in_sz,
+		   void *in2, size_t in2_sz)
+{
+	return invoke_ta(sks_ctx, cmd, ctrl, ctrl_sz,
+			 in, &in_sz, DIR_IN,
+			 in2, &in2_sz, DIR_IN);
+}
+
+void sks_invoke_terminate(void)
+{
+	close_primary_context();
+}
diff --git a/libsks/src/invoke_ta.h b/libsks/src/invoke_ta.h
new file mode 100644
index 0000000..42d5d88
--- /dev/null
+++ b/libsks/src/invoke_ta.h
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2017, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __INVOKE_TA_H
+#define __INVOKE_TA_H
+
+#include <pkcs11.h>
+#include <tee_client_api.h>
+
+/*
+ * structure stored in CK session so it calls through the right
+ * GPD TEE session. TEEC type as abstract through void pointers
+ * to prevent CK messing with TEEC API.
+ *
+ * The structure must be reset to zero prior being used.
+ */
+struct sks_invoke {
+	void *context;
+	void *session;
+};
+
+/**
+ * alloc_shm - Allocate memory in the TEE SHM (in, out or in/out)
+ *
+ * @owner - Supplied TEE session or NULL
+ * @size - allocated size in byte
+ *
+ * Return a shm reference or NULL on failure.
+ *
+ * Allocate input SHM on behalf of supplied TEE context.
+ * If the supplied context is not initialized, init it through
+ * the primary TEE context.
+ * If there is no supplied context (ctx is NULL), allocate
+ * on behalf of the primary TEE session context.
+ */
+TEEC_SharedMemory *sks_alloc_shm(struct sks_invoke *ctx,
+				 size_t size, int in, int out);
+
+static inline TEEC_SharedMemory *sks_alloc_shm_in(struct sks_invoke *ctx,
+						  size_t size)
+{
+	return sks_alloc_shm(ctx, size, 1, 0);
+}
+static inline TEEC_SharedMemory *sks_alloc_shm_out(struct sks_invoke *ctx,
+						   size_t size)
+{
+	return sks_alloc_shm(ctx, size, 0, 1);
+}
+static inline TEEC_SharedMemory *sks_alloc_shm_inout(struct sks_invoke *ctx,
+						     size_t size)
+{
+	return sks_alloc_shm(ctx, size, 1, 1);
+}
+
+/**
+ * register_shm - Register buffer as TEE SHM memory (in, out or in/out)
+ *
+ * @owner - Supplied TEE session or NULL
+ * @buffer - pointer to the buffer to be registered
+ * @size - allocated size in byte
+ *
+ * Return a shm reference or NULL on failure.
+ *
+ * Allocate input SHM on behalf of supplied TEE context.
+ * If the supplied context is not initialized, init it through
+ * the primary TEE context.
+ * If there is no supplied context (ctx is NULL), allocate
+ * on behalf of the primary TEE session context.
+ */
+TEEC_SharedMemory *sks_register_shm(struct sks_invoke *ctx, void *buf,
+				    size_t size, int in, int out);
+
+static inline TEEC_SharedMemory *sks_register_shm_in(struct sks_invoke *ctx,
+						     void *buf, size_t size)
+{
+	return sks_register_shm(ctx, buf, size, 1, 0);
+}
+static inline TEEC_SharedMemory *sks_register_shm_out(struct sks_invoke *ctx,
+						      void *buf, size_t size)
+{
+	return sks_register_shm(ctx, buf, size, 0, 1);
+}
+static inline TEEC_SharedMemory *sks_register_shm_inout(struct sks_invoke *ctx,
+							void *buf, size_t size)
+{
+	return sks_register_shm(ctx, buf, size, 1, 1);
+}
+
+/**
+ * free_shm - Release allocated or registered emory in the TEE SHM
+ *
+ * @shm - memory reference
+ */
+void sks_free_shm(TEEC_SharedMemory *shm);
+
+/**
+ * ck_invoke_ta*() - Invoke a SKS request to the TEE
+ * ck_invoke_ta_in() - Invoke a SKS request to the TEE
+ * ck_invoke_ta_in_out() - Invoke a SKS request to the TEE
+ * ck_invoke_ta_in_in() - Invoke a SKS request to the TEE
+ *
+ * @ctx - supplied TEE session context
+ * @cmd - SKS TA command ID
+ * @ctrl - command serialized input arguments. Shm, buffer or NULL pointer.
+ * @ctrl_sz - byte size of ctrl if ctrl is a buffer pointer
+ * @in - input to-be-processed data. Shm, buffer or NULL pointer.
+ * @in_sz - byte size of @in if @in is a buffer pointer
+ * @in_in - 1 if input, 0 if output, meaningless if @in is a Shm reference
+ * @out - output data. Shm, buffer or NULL pointer.
+ * @out_sz - byte size of @out if @out is a buffer pointer
+ * @out_in - 1 if input, 0 if output, meaningless if @out is a Shm reference
+ * @in2 - secondary input to-be-processed data. Shm, buffer or NULL pointer.
+ * @in2_sz - byte size of @in2 if @in2 is a buffer pointer
+ * @in2_in - 1 if input, 0 if output, meaningless if @in2 is a Shm reference
+ *
+ * Return a CK_RV return value.
+ *
+ * Allocate input SHM on behalf of supplied TEE context.
+ * If the supplied context is not initialized, init it through
+ * the primary TEE context.
+ * If there is no supplied context (ctx is NULL), allocate
+ * on behalf of the primary TEE session context.
+ *
+ * ctrl, in and out can be NULL pointer (no related data), buffer pointer
+ * (related data are stored in a memory buffer not registered as TEE SHM)
+ * or a SHM reference (related data are stored in a buffer registered as
+ * TEE SHM).
+ * ctrl_sz, in_sz and out_sz are null if the related reference is a SHM buffer
+ * and are not null if the related reference is a non SHM buffer. Note that
+ * out_sz is a pointer.
+ */
+
+CK_RV ck_invoke_ta(struct sks_invoke *sks_ctx,
+		   unsigned long cmd,
+		   void *ctrl, size_t ctrl_sz);
+
+CK_RV ck_invoke_ta_in(struct sks_invoke *sks_ctx,
+		      unsigned long cmd,
+		      void *ctrl, size_t ctrl_sz,
+		      void *in, size_t in_sz);
+
+CK_RV ck_invoke_ta_in_out(struct sks_invoke *sks_ctx,
+		   unsigned long cmd,
+		   void *ctrl, size_t ctrl_sz,
+		   void *in, size_t in_sz,
+		   void *out, size_t *out_sz);
+
+CK_RV ck_invoke_ta_in_in(struct sks_invoke *sks_ctx,
+		   unsigned long cmd,
+		   void *ctrl, size_t ctrl_sz,
+		   void *in, size_t in_sz,
+		   void *in2, size_t in2_sz);
+
+/* sks_invoke_terminate - Release all allocated invocation resources */
+void sks_invoke_terminate(void);
+
+#endif /*__INVOKE_TA_H*/
diff --git a/libsks/src/local_utils.h b/libsks/src/local_utils.h
new file mode 100644
index 0000000..2242959
--- /dev/null
+++ b/libsks/src/local_utils.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#ifndef __LOCAL_UTILS_H
+#define __LOCAL_UTILS_H
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define LOG_ERROR(...)	printf(__VA_ARGS__)
+#define LOG_INFO(...)	printf(__VA_ARGS__)
+#define LOG_DEBUG(...)	printf(__VA_ARGS__)
+
+#define ARRAY_SIZE(array)	(sizeof(array) / sizeof(array[0]))
+
+#endif /*__LOCAL_UTILS_H*/
diff --git a/libsks/src/pkcs11_api.c b/libsks/src/pkcs11_api.c
new file mode 100644
index 0000000..fedd68b
--- /dev/null
+++ b/libsks/src/pkcs11_api.c
@@ -0,0 +1,2020 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <assert.h>
+#include <pkcs11.h>
+#include <stdlib.h>
+
+#include "invoke_ta.h"
+#include "local_utils.h"
+#include "pkcs11_processing.h"
+#include "pkcs11_token.h"
+#include "ck_helpers.h"
+
+static int lib_inited;
+
+#define REGISTER_CK_FUNCTION(_function)		._function = _function
+#define DO_NOT_REGISTER_CK_FUNCTION(_function)	._function = NULL
+
+static const CK_FUNCTION_LIST libsks_function_list = {
+	.version = {
+		.major = 2,
+		.minor = 40,
+	},
+	REGISTER_CK_FUNCTION(C_Initialize),
+	REGISTER_CK_FUNCTION(C_Finalize),
+	REGISTER_CK_FUNCTION(C_GetInfo),
+	REGISTER_CK_FUNCTION(C_GetFunctionList),
+	REGISTER_CK_FUNCTION(C_GetSlotList),
+	REGISTER_CK_FUNCTION(C_GetSlotInfo),
+	REGISTER_CK_FUNCTION(C_GetTokenInfo),
+	REGISTER_CK_FUNCTION(C_GetMechanismList),
+	REGISTER_CK_FUNCTION(C_GetMechanismInfo),
+	REGISTER_CK_FUNCTION(C_InitToken),
+	REGISTER_CK_FUNCTION(C_InitPIN),
+	REGISTER_CK_FUNCTION(C_SetPIN),
+	REGISTER_CK_FUNCTION(C_OpenSession),
+	REGISTER_CK_FUNCTION(C_CloseSession),
+	REGISTER_CK_FUNCTION(C_CloseAllSessions),
+	REGISTER_CK_FUNCTION(C_GetSessionInfo),
+	REGISTER_CK_FUNCTION(C_GetOperationState),
+	REGISTER_CK_FUNCTION(C_SetOperationState),
+	REGISTER_CK_FUNCTION(C_Login),
+	REGISTER_CK_FUNCTION(C_Logout),
+	REGISTER_CK_FUNCTION(C_CreateObject),
+	REGISTER_CK_FUNCTION(C_CopyObject),
+	REGISTER_CK_FUNCTION(C_DestroyObject),
+	REGISTER_CK_FUNCTION(C_GetObjectSize),
+	REGISTER_CK_FUNCTION(C_GetAttributeValue),
+	REGISTER_CK_FUNCTION(C_SetAttributeValue),
+	REGISTER_CK_FUNCTION(C_FindObjectsInit),
+	REGISTER_CK_FUNCTION(C_FindObjects),
+	REGISTER_CK_FUNCTION(C_FindObjectsFinal),
+	REGISTER_CK_FUNCTION(C_EncryptInit),
+	REGISTER_CK_FUNCTION(C_Encrypt),
+	REGISTER_CK_FUNCTION(C_EncryptUpdate),
+	REGISTER_CK_FUNCTION(C_EncryptFinal),
+	REGISTER_CK_FUNCTION(C_DecryptInit),
+	REGISTER_CK_FUNCTION(C_Decrypt),
+	REGISTER_CK_FUNCTION(C_DecryptUpdate),
+	REGISTER_CK_FUNCTION(C_DecryptFinal),
+	REGISTER_CK_FUNCTION(C_DigestInit),
+	REGISTER_CK_FUNCTION(C_Digest),
+	REGISTER_CK_FUNCTION(C_DigestUpdate),
+	REGISTER_CK_FUNCTION(C_DigestKey),
+	REGISTER_CK_FUNCTION(C_DigestFinal),
+	REGISTER_CK_FUNCTION(C_SignInit),
+	REGISTER_CK_FUNCTION(C_Sign),
+	REGISTER_CK_FUNCTION(C_SignUpdate),
+	REGISTER_CK_FUNCTION(C_SignFinal),
+	REGISTER_CK_FUNCTION(C_SignRecoverInit),
+	REGISTER_CK_FUNCTION(C_SignRecover),
+	REGISTER_CK_FUNCTION(C_VerifyInit),
+	REGISTER_CK_FUNCTION(C_Verify),
+	REGISTER_CK_FUNCTION(C_VerifyUpdate),
+	REGISTER_CK_FUNCTION(C_VerifyFinal),
+	REGISTER_CK_FUNCTION(C_VerifyRecoverInit),
+	REGISTER_CK_FUNCTION(C_VerifyRecover),
+	REGISTER_CK_FUNCTION(C_DigestEncryptUpdate),
+	REGISTER_CK_FUNCTION(C_DecryptDigestUpdate),
+	REGISTER_CK_FUNCTION(C_SignEncryptUpdate),
+	REGISTER_CK_FUNCTION(C_DecryptVerifyUpdate),
+	REGISTER_CK_FUNCTION(C_GenerateKey),
+	REGISTER_CK_FUNCTION(C_GenerateKeyPair),
+	REGISTER_CK_FUNCTION(C_WrapKey),
+	REGISTER_CK_FUNCTION(C_UnwrapKey),
+	REGISTER_CK_FUNCTION(C_DeriveKey),
+	REGISTER_CK_FUNCTION(C_SeedRandom),
+	REGISTER_CK_FUNCTION(C_GenerateRandom),
+	REGISTER_CK_FUNCTION(C_GetFunctionStatus),
+	REGISTER_CK_FUNCTION(C_CancelFunction),
+	REGISTER_CK_FUNCTION(C_WaitForSlotEvent),
+};
+
+/*
+ * List of all PKCS#11 cryptoki API functions implemented
+ */
+
+CK_RV C_Initialize(CK_VOID_PTR init_args)
+{
+	(void)init_args;
+	CK_C_INITIALIZE_ARGS_PTR args = NULL;
+
+	if (init_args) {
+		args = (CK_C_INITIALIZE_ARGS_PTR)init_args;
+		/* Reserved must be set to NULL in this version of PKCS#11 */
+		if (args->reserved)
+			return CKR_ARGUMENTS_BAD;
+	}
+
+	if (lib_inited)
+		return CKR_CRYPTOKI_ALREADY_INITIALIZED;
+
+	lib_inited = 1;
+	return CKR_OK;
+}
+
+CK_RV C_Finalize(CK_VOID_PTR res)
+{
+	(void)res;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	/* Reserved must be set to NULL in this version of PKCS#11 */
+	if (res)
+		return CKR_ARGUMENTS_BAD;
+
+	sks_invoke_terminate();
+
+	lib_inited = 0;
+
+	return CKR_OK;
+}
+
+CK_RV C_GetInfo(CK_INFO_PTR info)
+{
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	if (!info)
+		return CKR_ARGUMENTS_BAD;
+
+	return sks_ck_get_info(info);
+}
+
+CK_RV C_GetFunctionList(CK_FUNCTION_LIST_PTR_PTR ppFunctionList)
+{
+	if (!ppFunctionList)
+		return CKR_ARGUMENTS_BAD;
+
+	/* Discard the const attribute when exporting the list address */
+	*ppFunctionList = (void *)&libsks_function_list;
+
+	return CKR_OK;
+}
+
+CK_RV C_GetSlotList(CK_BBOOL token_present,
+		    CK_SLOT_ID_PTR slots,
+		    CK_ULONG_PTR count)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_slot_get_list(token_present, slots, count);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GetSlotInfo(CK_SLOT_ID slot,
+		    CK_SLOT_INFO_PTR info)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_slot_get_info(slot, info);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_SLOT_ID_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_InitToken(CK_SLOT_ID slot,
+		  CK_UTF8CHAR_PTR pin,
+		  CK_ULONG pin_len,
+		  CK_UTF8CHAR_PTR label)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_init_token(slot, pin, pin_len, label);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_PIN_INCORRECT:
+	case CKR_PIN_LOCKED:
+	case CKR_SESSION_EXISTS:
+	case CKR_SLOT_ID_INVALID:
+	case CKR_TOKEN_NOT_PRESENT:
+	case CKR_TOKEN_NOT_RECOGNIZED:
+	case CKR_TOKEN_WRITE_PROTECTED:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GetTokenInfo(CK_SLOT_ID slot,
+		     CK_TOKEN_INFO_PTR info)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_token_get_info(slot, info);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_SLOT_ID_INVALID:
+	case CKR_TOKEN_NOT_PRESENT:
+	case CKR_TOKEN_NOT_RECOGNIZED:
+	case CKR_ARGUMENTS_BAD:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GetMechanismList(CK_SLOT_ID slot,
+			 CK_MECHANISM_TYPE_PTR mechanisms,
+			 CK_ULONG_PTR count)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_token_mechanism_ids(slot, mechanisms, count);
+
+	switch (rv) {
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_SLOT_ID_INVALID:
+	case CKR_TOKEN_NOT_PRESENT:
+	case CKR_TOKEN_NOT_RECOGNIZED:
+	case CKR_ARGUMENTS_BAD:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GetMechanismInfo(CK_SLOT_ID slot,
+			 CK_MECHANISM_TYPE type,
+			 CK_MECHANISM_INFO_PTR info)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_token_mechanism_info(slot, type, info);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_MECHANISM_INVALID:
+	case CKR_OK:
+	case CKR_SLOT_ID_INVALID:
+	case CKR_TOKEN_NOT_PRESENT:
+	case CKR_TOKEN_NOT_RECOGNIZED:
+	case CKR_ARGUMENTS_BAD:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_OpenSession(CK_SLOT_ID slot,
+		    CK_FLAGS flags,
+		    CK_VOID_PTR cookie,
+		    CK_NOTIFY callback,
+		    CK_SESSION_HANDLE_PTR session)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	if (flags & ~(CKF_RW_SESSION | CKF_SERIAL_SESSION))
+		return CKR_ARGUMENTS_BAD;
+
+	/* Specific mandated flag */
+	if (!(flags & CKF_SERIAL_SESSION))
+		return CKR_SESSION_PARALLEL_NOT_SUPPORTED;
+
+	rv = sks_ck_open_session(slot, flags, cookie, callback, session);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_SESSION_COUNT:
+	case CKR_SESSION_PARALLEL_NOT_SUPPORTED:
+	case CKR_SESSION_READ_WRITE_SO_EXISTS:
+	case CKR_SLOT_ID_INVALID:
+	case CKR_TOKEN_NOT_PRESENT:
+	case CKR_TOKEN_NOT_RECOGNIZED:
+	case CKR_TOKEN_WRITE_PROTECTED:
+	case CKR_ARGUMENTS_BAD:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_CloseSession(CK_SESSION_HANDLE session)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_close_session(session);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_CloseAllSessions(CK_SLOT_ID slot)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_close_all_sessions(slot);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_SLOT_ID_INVALID:
+	case CKR_TOKEN_NOT_PRESENT:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GetSessionInfo(CK_SESSION_HANDLE session,
+		       CK_SESSION_INFO_PTR info)
+{
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return sks_ck_get_session_info(session, info);
+}
+
+CK_RV C_InitPIN(CK_SESSION_HANDLE session,
+		CK_UTF8CHAR_PTR pin,
+		CK_ULONG pin_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_init_pin(session, pin, pin_len);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_PIN_INVALID:
+	case CKR_PIN_LEN_RANGE:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_READ_ONLY:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_TOKEN_WRITE_PROTECTED:
+	case CKR_USER_NOT_LOGGED_IN:
+	case CKR_ARGUMENTS_BAD:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_SetPIN(CK_SESSION_HANDLE session,
+	       CK_UTF8CHAR_PTR old,
+	       CK_ULONG old_len,
+	       CK_UTF8CHAR_PTR new,
+	       CK_ULONG new_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_set_pin(session, old, old_len, new, new_len);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_MECHANISM_INVALID:
+	case CKR_OK:
+	case CKR_PIN_INCORRECT:
+	case CKR_PIN_INVALID:
+	case CKR_PIN_LEN_RANGE:
+	case CKR_PIN_LOCKED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SESSION_READ_ONLY:
+	case CKR_TOKEN_WRITE_PROTECTED:
+	case CKR_ARGUMENTS_BAD:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_Login(CK_SESSION_HANDLE session,
+	      CK_USER_TYPE user_type,
+	      CK_UTF8CHAR_PTR pin,
+	      CK_ULONG pin_len)
+
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_login(session, user_type, pin, pin_len);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_PIN_INCORRECT:
+	case CKR_PIN_LOCKED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SESSION_READ_ONLY_EXISTS:
+	case CKR_USER_ALREADY_LOGGED_IN:
+	case CKR_USER_ANOTHER_ALREADY_LOGGED_IN:
+	case CKR_USER_PIN_NOT_INITIALIZED:
+	case CKR_USER_TOO_MANY_TYPES:
+	case CKR_USER_TYPE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_Logout(CK_SESSION_HANDLE session)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = sks_ck_logout(session);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GetOperationState(CK_SESSION_HANDLE session,
+			  CK_BYTE_PTR state,
+			  CK_ULONG_PTR state_len)
+{
+	(void)session;
+	(void)state;
+	(void)state_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_SetOperationState(CK_SESSION_HANDLE session,
+			  CK_BYTE_PTR state,
+			  CK_ULONG state_len,
+			  CK_OBJECT_HANDLE ciph_key,
+			  CK_OBJECT_HANDLE auth_key)
+{
+	(void)session;
+	(void)state;
+	(void)state_len;
+	(void)ciph_key;
+	(void)auth_key;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_CreateObject(CK_SESSION_HANDLE session,
+		     CK_ATTRIBUTE_PTR attribs,
+		     CK_ULONG count,
+		     CK_OBJECT_HANDLE_PTR phObject)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_create_object(session, attribs, count, phObject);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_ATTRIBUTE_READ_ONLY:
+	case CKR_ATTRIBUTE_TYPE_INVALID:
+	case CKR_ATTRIBUTE_VALUE_INVALID:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_CURVE_NOT_SUPPORTED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_DOMAIN_PARAMS_INVALID:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SESSION_READ_ONLY:
+	case CKR_TEMPLATE_INCOMPLETE:
+	case CKR_TEMPLATE_INCONSISTENT:
+	case CKR_TOKEN_WRITE_PROTECTED:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_CopyObject(CK_SESSION_HANDLE session,
+		   CK_OBJECT_HANDLE obj,
+		   CK_ATTRIBUTE_PTR attribs,
+		   CK_ULONG count,
+		   CK_OBJECT_HANDLE_PTR new_obj)
+{
+	(void)session;
+	(void)obj;
+	(void)attribs;
+	(void)count;
+	(void)new_obj;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_DestroyObject(CK_SESSION_HANDLE session,
+		      CK_OBJECT_HANDLE obj)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_destroy_object(session, obj);
+
+	switch (rv) {
+	case CKR_ACTION_PROHIBITED:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OBJECT_HANDLE_INVALID:
+	case CKR_OK:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SESSION_READ_ONLY:
+	case CKR_TOKEN_WRITE_PROTECTED:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GetObjectSize(CK_SESSION_HANDLE session,
+		      CK_OBJECT_HANDLE obj,
+		      CK_ULONG_PTR out_size)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_get_object_size(session, obj, out_size);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_INFORMATION_SENSITIVE:
+	case CKR_OBJECT_HANDLE_INVALID:
+	case CKR_OK:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GetAttributeValue(CK_SESSION_HANDLE session,
+			  CK_OBJECT_HANDLE obj,
+			  CK_ATTRIBUTE_PTR attribs,
+			  CK_ULONG count)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_get_attribute_value(session, obj, attribs, count);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_ATTRIBUTE_SENSITIVE:
+	case CKR_ATTRIBUTE_TYPE_INVALID:
+	case CKR_ATTRIBUTE_VALUE_INVALID:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_OBJECT_HANDLE_INVALID:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_SetAttributeValue(CK_SESSION_HANDLE session,
+			  CK_OBJECT_HANDLE obj,
+			  CK_ATTRIBUTE_PTR attribs,
+			  CK_ULONG count)
+{
+	(void)session;
+	(void)obj;
+	(void)attribs;
+	(void)count;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_FindObjectsInit(CK_SESSION_HANDLE session,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_find_objects_init(session, attribs, count);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_ATTRIBUTE_TYPE_INVALID:
+	case CKR_ATTRIBUTE_VALUE_INVALID:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_FindObjects(CK_SESSION_HANDLE session,
+		    CK_OBJECT_HANDLE_PTR obj,
+		    CK_ULONG max_count,
+		    CK_ULONG_PTR count)
+
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_find_objects(session, obj, max_count, count);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_FindObjectsFinal(CK_SESSION_HANDLE session)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_find_objects_final(session);
+
+	switch (rv) {
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_EncryptInit(CK_SESSION_HANDLE session,
+		    CK_MECHANISM_PTR mechanism,
+		    CK_OBJECT_HANDLE key)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_encdecrypt_init(session, mechanism, key, CK_FALSE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_KEY_FUNCTION_NOT_PERMITTED:
+	case CKR_KEY_HANDLE_INVALID:
+	case CKR_KEY_SIZE_RANGE:
+	case CKR_KEY_TYPE_INCONSISTENT:
+	case CKR_MECHANISM_INVALID:
+	case CKR_MECHANISM_PARAM_INVALID:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_Encrypt(CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_encdecrypt_oneshot(session, in, in_len, out, out_len, CK_FALSE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_EncryptUpdate(CK_SESSION_HANDLE session,
+		      CK_BYTE_PTR in,
+		      CK_ULONG in_len,
+		      CK_BYTE_PTR out,
+		      CK_ULONG_PTR out_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_encdecrypt_update(session, in, in_len, out, out_len, CK_FALSE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_EncryptFinal(CK_SESSION_HANDLE session,
+		     CK_BYTE_PTR out,
+		     CK_ULONG_PTR out_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_encdecrypt_final(session, out, out_len, CK_FALSE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_DecryptInit(CK_SESSION_HANDLE session,
+		    CK_MECHANISM_PTR  mechanism,
+		    CK_OBJECT_HANDLE  key)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_encdecrypt_init(session, mechanism, key, CK_TRUE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_KEY_FUNCTION_NOT_PERMITTED:
+	case CKR_KEY_HANDLE_INVALID:
+	case CKR_KEY_SIZE_RANGE:
+	case CKR_KEY_TYPE_INCONSISTENT:
+	case CKR_MECHANISM_INVALID:
+	case CKR_MECHANISM_PARAM_INVALID:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_Decrypt(CK_SESSION_HANDLE session,
+		CK_BYTE_PTR in,
+		CK_ULONG in_len,
+		CK_BYTE_PTR out,
+		CK_ULONG_PTR out_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_encdecrypt_oneshot(session, in, in_len, out, out_len, CK_TRUE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_ENCRYPTED_DATA_INVALID:
+	case CKR_ENCRYPTED_DATA_LEN_RANGE:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_DecryptUpdate(CK_SESSION_HANDLE session,
+		      CK_BYTE_PTR in,
+		      CK_ULONG in_len,
+		      CK_BYTE_PTR out,
+		      CK_ULONG_PTR out_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_encdecrypt_update(session, in, in_len, out, out_len, CK_TRUE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_ENCRYPTED_DATA_INVALID:
+	case CKR_ENCRYPTED_DATA_LEN_RANGE:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_DecryptFinal(CK_SESSION_HANDLE session,
+		     CK_BYTE_PTR out,
+		     CK_ULONG_PTR out_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_encdecrypt_final(session, out, out_len, CK_TRUE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_ENCRYPTED_DATA_INVALID:
+	case CKR_ENCRYPTED_DATA_LEN_RANGE:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+
+CK_RV C_DigestInit(CK_SESSION_HANDLE session,
+		   CK_MECHANISM_PTR  mechanism)
+{
+	(void)session;
+	(void)mechanism;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_Digest(CK_SESSION_HANDLE session,
+	       CK_BYTE_PTR in,
+	       CK_ULONG in_len,
+	       CK_BYTE_PTR out,
+	       CK_ULONG_PTR out_len)
+{
+	(void)session;
+	(void)in;
+	(void)in_len;
+	(void)out;
+	(void)out_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_DigestUpdate(CK_SESSION_HANDLE session,
+		     CK_BYTE_PTR in,
+		     CK_ULONG in_len)
+{
+	(void)session;
+	(void)in;
+	(void)in_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_DigestKey(CK_SESSION_HANDLE session,
+		  CK_OBJECT_HANDLE  key)
+{
+	(void)session;
+	(void)key;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_DigestFinal(CK_SESSION_HANDLE session,
+		    CK_BYTE_PTR digest,
+		    CK_ULONG_PTR len)
+{
+	(void)session;
+	(void)digest;
+	(void)len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_SignInit(CK_SESSION_HANDLE session,
+		 CK_MECHANISM_PTR mechanism,
+		 CK_OBJECT_HANDLE key)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_signverify_init(session, mechanism, key, CK_TRUE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_KEY_FUNCTION_NOT_PERMITTED:
+	case CKR_KEY_HANDLE_INVALID:
+	case CKR_KEY_SIZE_RANGE:
+	case CKR_KEY_TYPE_INCONSISTENT:
+	case CKR_MECHANISM_INVALID:
+	case CKR_MECHANISM_PARAM_INVALID:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_Sign(CK_SESSION_HANDLE session,
+	     CK_BYTE_PTR       in,
+	     CK_ULONG          in_len,
+	     CK_BYTE_PTR       out,
+	     CK_ULONG_PTR      out_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_signverify_oneshot(session, in, in_len, out, out_len, CK_TRUE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_INVALID:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+	case CKR_FUNCTION_REJECTED:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_SignUpdate(CK_SESSION_HANDLE session,
+		   CK_BYTE_PTR in,
+		   CK_ULONG in_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_signverify_update(session, in, in_len, CK_TRUE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_SignFinal(CK_SESSION_HANDLE session,
+		  CK_BYTE_PTR out,
+		  CK_ULONG_PTR out_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_signverify_final(session, out, out_len, CK_TRUE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_BUFFER_TOO_SMALL:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+	case CKR_FUNCTION_REJECTED:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_SignRecoverInit(CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR  mechanism,
+			CK_OBJECT_HANDLE  key)
+{
+	(void)session;
+	(void)mechanism;
+	(void)key;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_SignRecover(CK_SESSION_HANDLE session,
+		    CK_BYTE_PTR in,
+		    CK_ULONG in_len,
+		    CK_BYTE_PTR out,
+		    CK_ULONG_PTR out_len)
+{
+	(void)session;
+	(void)in;
+	(void)in_len;
+	(void)out;
+	(void)out_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_VerifyInit(CK_SESSION_HANDLE session,
+		   CK_MECHANISM_PTR  mechanism,
+		   CK_OBJECT_HANDLE  key)
+{
+	CK_RV rv;
+
+	rv = ck_signverify_init(session, mechanism, key, CK_FALSE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_KEY_FUNCTION_NOT_PERMITTED:
+	case CKR_KEY_HANDLE_INVALID:
+	case CKR_KEY_SIZE_RANGE:
+	case CKR_KEY_TYPE_INCONSISTENT:
+	case CKR_MECHANISM_INVALID:
+	case CKR_MECHANISM_PARAM_INVALID:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_Verify(CK_SESSION_HANDLE session,
+	       CK_BYTE_PTR in,
+	       CK_ULONG in_len,
+	       CK_BYTE_PTR out,
+	       CK_ULONG out_len)
+{
+	CK_RV rv;
+	CK_ULONG out_size = out_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_signverify_oneshot(session, in, in_len, out, &out_size,
+				   CK_FALSE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_INVALID:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SIGNATURE_INVALID:
+	case CKR_SIGNATURE_LEN_RANGE:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_VerifyUpdate(CK_SESSION_HANDLE session,
+		     CK_BYTE_PTR in,
+		     CK_ULONG in_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_signverify_update(session, in, in_len, CK_FALSE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_VerifyFinal(CK_SESSION_HANDLE session,
+		    CK_BYTE_PTR sign,
+		    CK_ULONG sign_len)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_signverify_final(session, sign, &sign_len, CK_FALSE);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_DATA_LEN_RANGE:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_OK:
+	case CKR_OPERATION_NOT_INITIALIZED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SIGNATURE_INVALID:
+	case CKR_SIGNATURE_LEN_RANGE:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_VerifyRecoverInit(CK_SESSION_HANDLE session,
+			  CK_MECHANISM_PTR mechanism,
+			  CK_OBJECT_HANDLE key)
+{
+	(void)session;
+	(void)mechanism;
+	(void)key;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_VerifyRecover(CK_SESSION_HANDLE session,
+		      CK_BYTE_PTR in,
+		      CK_ULONG in_len,
+		      CK_BYTE_PTR out,
+		      CK_ULONG_PTR out_len)
+{
+	(void)session;
+	(void)in;
+	(void)in_len;
+	(void)out;
+	(void)out_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_DigestEncryptUpdate(CK_SESSION_HANDLE session,
+			    CK_BYTE_PTR in,
+			    CK_ULONG in_len,
+			    CK_BYTE_PTR out,
+			    CK_ULONG_PTR out_len)
+{
+	(void)session;
+	(void)in;
+	(void)in_len;
+	(void)out;
+	(void)out_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_DecryptDigestUpdate(CK_SESSION_HANDLE session,
+			    CK_BYTE_PTR in,
+			    CK_ULONG in_len,
+			    CK_BYTE_PTR out,
+			    CK_ULONG_PTR out_len)
+{
+	(void)session;
+	(void)in;
+	(void)in_len;
+	(void)out;
+	(void)out_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+
+CK_RV C_SignEncryptUpdate(CK_SESSION_HANDLE session,
+			  CK_BYTE_PTR in,
+			  CK_ULONG in_len,
+			  CK_BYTE_PTR out,
+			  CK_ULONG_PTR out_len)
+{
+	(void)session;
+	(void)in;
+	(void)in_len;
+	(void)out;
+	(void)out_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_DecryptVerifyUpdate(CK_SESSION_HANDLE session,
+			    CK_BYTE_PTR in,
+			    CK_ULONG in_len,
+			    CK_BYTE_PTR out,
+			    CK_ULONG_PTR out_len)
+{
+	(void)session;
+	(void)in;
+	(void)in_len;
+	(void)out;
+	(void)out_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_GenerateKey(CK_SESSION_HANDLE session,
+		    CK_MECHANISM_PTR mechanism,
+		    CK_ATTRIBUTE_PTR attribs,
+		    CK_ULONG count,
+		    CK_OBJECT_HANDLE_PTR handle)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_generate_key(session, mechanism, attribs, count, handle);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_ATTRIBUTE_READ_ONLY:
+	case CKR_ATTRIBUTE_TYPE_INVALID:
+	case CKR_ATTRIBUTE_VALUE_INVALID:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_CURVE_NOT_SUPPORTED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_MECHANISM_INVALID:
+	case CKR_MECHANISM_PARAM_INVALID:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SESSION_READ_ONLY:
+	case CKR_TEMPLATE_INCOMPLETE:
+	case CKR_TEMPLATE_INCONSISTENT:
+	case CKR_TOKEN_WRITE_PROTECTED:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_GenerateKeyPair(CK_SESSION_HANDLE session,
+			CK_MECHANISM_PTR mechanism,
+			CK_ATTRIBUTE_PTR pub_attribs,
+			CK_ULONG pub_count,
+			CK_ATTRIBUTE_PTR priv_attribs,
+			CK_ULONG priv_count,
+			CK_OBJECT_HANDLE_PTR pub_key,
+			CK_OBJECT_HANDLE_PTR priv_key)
+{
+	CK_RV rv;
+	CK_ATTRIBUTE_PTR pub_attribs_n = NULL;
+	CK_ATTRIBUTE_PTR priv_attribs_n = NULL;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	if (!mechanism || !pub_key || !priv_key)
+		return CKR_ARGUMENTS_BAD;
+
+	if (pub_count && !pub_attribs)
+		return CKR_ARGUMENTS_BAD;
+
+	if (priv_count && !priv_attribs)
+		return CKR_ARGUMENTS_BAD;
+
+	rv = ck_guess_key_type(mechanism, pub_attribs, &pub_count,
+			       &pub_attribs_n);
+	if (rv != CKR_OK)
+		goto bail;
+
+	rv = ck_guess_key_type(mechanism, priv_attribs, &priv_count,
+			       &priv_attribs_n);
+	if (rv != CKR_OK)
+		goto bail;
+
+	rv = ck_generate_key_pair(session, mechanism, pub_attribs_n, pub_count,
+				  priv_attribs_n, priv_count, pub_key, priv_key);
+
+bail:
+	if (pub_attribs_n)
+		free(pub_attribs_n);
+	if (priv_attribs_n)
+		free(priv_attribs_n);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_ATTRIBUTE_READ_ONLY:
+	case CKR_ATTRIBUTE_TYPE_INVALID:
+	case CKR_ATTRIBUTE_VALUE_INVALID:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_CURVE_NOT_SUPPORTED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_DOMAIN_PARAMS_INVALID:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_MECHANISM_INVALID:
+	case CKR_MECHANISM_PARAM_INVALID:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SESSION_READ_ONLY:
+	case CKR_TEMPLATE_INCOMPLETE:
+	case CKR_TEMPLATE_INCONSISTENT:
+	case CKR_TOKEN_WRITE_PROTECTED:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_WrapKey(CK_SESSION_HANDLE session,
+		CK_MECHANISM_PTR  mechanism,
+		CK_OBJECT_HANDLE wrap_key,
+		CK_OBJECT_HANDLE key,
+		CK_BYTE_PTR wrapped_key,
+		CK_ULONG_PTR wrapped_key_len)
+{
+	(void)session;
+	(void)mechanism;
+	(void)wrap_key;
+	(void)key;
+	(void)wrapped_key;
+	(void)wrapped_key_len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_UnwrapKey(CK_SESSION_HANDLE session,
+		  CK_MECHANISM_PTR mechanism,
+		  CK_OBJECT_HANDLE unwrap_key,
+		  CK_BYTE_PTR wrapped_key,
+		  CK_ULONG wrapped_key_len,
+		  CK_ATTRIBUTE_PTR attribs,
+		  CK_ULONG count,
+		  CK_OBJECT_HANDLE_PTR new_key)
+{
+	(void)session;
+	(void)mechanism;
+	(void)unwrap_key;
+	(void)wrapped_key;
+	(void)wrapped_key_len;
+	(void)attribs;
+	(void)count;
+	(void)new_key;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_DeriveKey(CK_SESSION_HANDLE session,
+		  CK_MECHANISM_PTR mechanism,
+		  CK_OBJECT_HANDLE derived_key,
+		  CK_ATTRIBUTE_PTR attribs,
+		  CK_ULONG count,
+		  CK_OBJECT_HANDLE_PTR key_handle)
+{
+	CK_RV rv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	rv = ck_derive_key(session, mechanism, derived_key, attribs, count,
+			   key_handle);
+
+	switch (rv) {
+	case CKR_ARGUMENTS_BAD:
+	case CKR_ATTRIBUTE_READ_ONLY:
+	case CKR_ATTRIBUTE_TYPE_INVALID:
+	case CKR_ATTRIBUTE_VALUE_INVALID:
+	case CKR_CRYPTOKI_NOT_INITIALIZED:
+	case CKR_CURVE_NOT_SUPPORTED:
+	case CKR_DEVICE_ERROR:
+	case CKR_DEVICE_MEMORY:
+	case CKR_DEVICE_REMOVED:
+	case CKR_DOMAIN_PARAMS_INVALID:
+	case CKR_FUNCTION_CANCELED:
+	case CKR_FUNCTION_FAILED:
+	case CKR_GENERAL_ERROR:
+	case CKR_HOST_MEMORY:
+	case CKR_KEY_HANDLE_INVALID:
+	case CKR_KEY_SIZE_RANGE:
+	case CKR_KEY_TYPE_INCONSISTENT:
+	case CKR_MECHANISM_INVALID:
+	case CKR_MECHANISM_PARAM_INVALID:
+	case CKR_OK:
+	case CKR_OPERATION_ACTIVE:
+	case CKR_PIN_EXPIRED:
+	case CKR_SESSION_CLOSED:
+	case CKR_SESSION_HANDLE_INVALID:
+	case CKR_SESSION_READ_ONLY:
+	case CKR_TEMPLATE_INCOMPLETE:
+	case CKR_TEMPLATE_INCONSISTENT:
+	case CKR_TOKEN_WRITE_PROTECTED:
+	case CKR_USER_NOT_LOGGED_IN:
+		break;
+	default:
+		assert(!rv);
+	}
+
+	return rv;
+}
+
+CK_RV C_SeedRandom(CK_SESSION_HANDLE session,
+		   CK_BYTE_PTR seed,
+		   CK_ULONG len)
+{
+	(void)session;
+	(void)seed;
+	(void)len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_GenerateRandom(CK_SESSION_HANDLE session,
+		       CK_BYTE_PTR out,
+		       CK_ULONG len)
+{
+	(void)session;
+	(void)out;
+	(void)len;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
+
+CK_RV C_GetFunctionStatus(CK_SESSION_HANDLE session)
+{
+	(void)session;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_PARALLEL;
+}
+
+CK_RV C_CancelFunction(CK_SESSION_HANDLE session)
+{
+	(void)session;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_PARALLEL;
+}
+
+
+CK_RV C_WaitForSlotEvent(CK_FLAGS flags,
+			 CK_SLOT_ID_PTR slot,
+			 CK_VOID_PTR rsv)
+{
+	(void)flags;
+	(void)slot;
+	(void)rsv;
+
+	if (!lib_inited)
+		return CKR_CRYPTOKI_NOT_INITIALIZED;
+
+	return CKR_FUNCTION_NOT_SUPPORTED;
+}
diff --git a/libsks/src/pkcs11_processing.c b/libsks/src/pkcs11_processing.c
new file mode 100644
index 0000000..a6adb4d
--- /dev/null
+++ b/libsks/src/pkcs11_processing.c
@@ -0,0 +1,704 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <sks_ta.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <tee_client_api.h>
+
+#include "pkcs11_processing.h"
+#include "invoke_ta.h"
+#include "serializer.h"
+#include "serialize_ck.h"
+
+static struct sks_invoke *ck_session2sks_ctx(CK_SESSION_HANDLE session)
+{
+	(void)session;
+	// TODO: find back the invocation context from the session handle
+	// Until we do that, let's use the default invacation context.
+	return NULL;
+}
+
+CK_RV ck_create_object(CK_SESSION_HANDLE session,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count,
+			CK_OBJECT_HANDLE_PTR handle)
+{
+	CK_RV rv;
+	struct serializer obj;
+	char *ctrl = NULL;
+	size_t ctrl_size;
+	uint32_t key_handle;
+	uint32_t session_handle = session;
+	size_t key_handle_size = sizeof(key_handle);
+
+	if (!attribs || !count || !handle)
+		return CKR_ARGUMENTS_BAD;
+
+	rv = serialize_ck_attributes(&obj, attribs, count);
+	if (rv)
+		goto bail;
+
+	/* ctrl = [session-handle][headed-serialized-attributes] */
+	ctrl_size = sizeof(uint32_t) + obj.size;
+	ctrl = malloc(ctrl_size);
+	if (!ctrl) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	memcpy(ctrl, &session_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), obj.buffer, obj.size);
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+				 SKS_CMD_IMPORT_OBJECT, ctrl, ctrl_size,
+				 NULL, 0, &key_handle, &key_handle_size);
+	if (rv)
+		goto bail;
+
+	*handle = key_handle;
+
+bail:
+	release_serial_object(&obj);
+	free(ctrl);
+	return rv;
+}
+
+CK_RV ck_destroy_object(CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE obj)
+{
+	uint32_t ctrl[2] = { (uint32_t)session, (uint32_t)obj };
+
+	return ck_invoke_ta(ck_session2sks_ctx(session),
+			    SKS_CMD_DESTROY_OBJECT, ctrl, sizeof(ctrl));
+}
+
+CK_RV ck_encdecrypt_init(CK_SESSION_HANDLE session,
+			 CK_MECHANISM_PTR mechanism,
+			 CK_OBJECT_HANDLE key,
+			 int decrypt)
+{
+	CK_RV rv;
+	struct serializer obj;
+	uint32_t session_handle = session;
+	uint32_t key_handle = key;
+	char *ctrl = NULL;
+	size_t ctrl_size;
+
+	if (!mechanism)
+		return CKR_ARGUMENTS_BAD;
+
+	rv = serialize_ck_mecha_params(&obj, mechanism);
+	if (rv)
+		return rv;
+
+	/* params = [session-handle][key-handle][serialized-mechanism-blob] */
+	ctrl_size = 2 * sizeof(uint32_t) + obj.size;
+	ctrl = malloc(ctrl_size);
+	if (!ctrl) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	memcpy(ctrl, &session_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), &key_handle, sizeof(uint32_t));
+	memcpy(ctrl + 2 * sizeof(uint32_t), obj.buffer, obj.size);
+
+	rv = ck_invoke_ta(ck_session2sks_ctx(session), decrypt ?
+			  SKS_CMD_DECRYPT_INIT : SKS_CMD_ENCRYPT_INIT,
+			  ctrl, ctrl_size);
+
+bail:
+	release_serial_object(&obj);
+	free(ctrl);
+	return rv;
+}
+
+CK_RV ck_encdecrypt_update(CK_SESSION_HANDLE session,
+			   CK_BYTE_PTR in,
+			   CK_ULONG in_len,
+			   CK_BYTE_PTR out,
+			   CK_ULONG_PTR out_len,
+			   int decrypt)
+{
+	CK_RV rv;
+	uint32_t ctrl;
+	size_t ctrl_size;
+	void *in_buf = in;
+	size_t in_size = in_len;
+	void *out_buf = out;
+	size_t out_size;
+
+	/* params = [session-handle] */
+	ctrl = session;
+	ctrl_size = sizeof(ctrl);
+
+	if (!out_len)
+		out_size = 0;
+	else
+		out_size = *out_len;
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session), decrypt ?
+				 SKS_CMD_DECRYPT_UPDATE :
+				 SKS_CMD_ENCRYPT_UPDATE,
+				 &ctrl, ctrl_size, in_buf, in_buf ? in_size : 0,
+				 out_buf, out_len ? &out_size : NULL);
+
+	if (out_len && (rv == CKR_OK || rv == CKR_BUFFER_TOO_SMALL))
+		*out_len = out_size;
+
+	return rv;
+}
+
+CK_RV ck_encdecrypt_oneshot(CK_SESSION_HANDLE session,
+			    CK_BYTE_PTR in,
+			    CK_ULONG in_len,
+			    CK_BYTE_PTR out,
+			    CK_ULONG_PTR out_len,
+			    int decrypt)
+{
+	CK_RV rv;
+	uint32_t ctrl;
+	size_t ctrl_size;
+	void *in_buf = in;
+	size_t in_size = in_len;
+	void *out_buf = out;
+	size_t out_size;
+
+	/* params = [session-handle] */
+	ctrl = session;
+	ctrl_size = sizeof(ctrl);
+
+	if (!out_len)
+		out_size = 0;
+	else
+		out_size = *out_len;
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session), decrypt ?
+				 SKS_CMD_DECRYPT_ONESHOT :
+				 SKS_CMD_ENCRYPT_ONESHOT,
+				 &ctrl, ctrl_size, in_buf, in_buf ? in_size : 0,
+				 out_buf, out_len ? &out_size : NULL);
+
+	if (out_len && (rv == CKR_OK || rv == CKR_BUFFER_TOO_SMALL))
+		*out_len = out_size;
+
+	if (out_len && !out_buf && rv == CKR_BUFFER_TOO_SMALL)
+		rv = CKR_OK;
+
+	return rv;
+}
+
+CK_RV ck_encdecrypt_final(CK_SESSION_HANDLE session,
+			  CK_BYTE_PTR out,
+			  CK_ULONG_PTR out_len,
+			  int decrypt)
+{
+	CK_RV rv;
+	uint32_t ctrl;
+	size_t ctrl_size;
+	void *out_buf = out;
+	size_t out_size;
+
+	/* params = [session-handle] */
+	ctrl = session;
+	ctrl_size = sizeof(ctrl);
+
+	if (!out_len)
+		out_size = 0;
+	else
+		out_size = *out_len;
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session), decrypt ?
+				 SKS_CMD_DECRYPT_FINAL : SKS_CMD_ENCRYPT_FINAL,
+				 &ctrl, ctrl_size, NULL, 0,
+				 out_buf, out_len ? &out_size : NULL);
+
+	if (out_len && (rv == CKR_OK || rv == CKR_BUFFER_TOO_SMALL))
+		*out_len = out_size;
+
+	return rv;
+}
+
+CK_RV ck_generate_key(CK_SESSION_HANDLE session,
+		      CK_MECHANISM_PTR mechanism,
+		      CK_ATTRIBUTE_PTR attribs,
+		      CK_ULONG count,
+		      CK_OBJECT_HANDLE_PTR handle)
+{
+	CK_RV rv;
+	struct serializer smecha;
+	struct serializer sattr;
+	uint32_t session_handle = session;
+	char *ctrl = NULL;
+	size_t ctrl_size;
+	uint32_t key_handle;
+	size_t key_handle_size = sizeof(key_handle);
+
+	if (!mechanism || !handle)
+		return CKR_ARGUMENTS_BAD;
+
+	if (count && !attribs)
+		return CKR_ARGUMENTS_BAD;
+
+	rv = serialize_ck_mecha_params(&smecha, mechanism);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_attributes(&sattr, attribs, count);
+	if (rv)
+		goto bail;
+
+	/* ctrl = [session-handle][serialized-mecha][serialized-attributes] */
+	ctrl_size = sizeof(uint32_t) + smecha.size + sattr.size;
+	ctrl = malloc(ctrl_size);
+	if (!ctrl) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	memcpy(ctrl, &session_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), smecha.buffer, smecha.size);
+	memcpy(ctrl + sizeof(uint32_t) + smecha.size, sattr.buffer, sattr.size);
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+				 SKS_CMD_GENERATE_SYMM_KEY, ctrl, ctrl_size,
+				 NULL, 0, &key_handle, &key_handle_size);
+	if (rv)
+		goto bail;
+
+	*handle = key_handle;
+
+bail:
+	free(ctrl);
+	release_serial_object(&smecha);
+	release_serial_object(&sattr);
+	return rv;
+}
+
+CK_RV ck_generate_key_pair(CK_SESSION_HANDLE session,
+			   CK_MECHANISM_PTR mechanism,
+			   CK_ATTRIBUTE_PTR pub_attribs,
+			   CK_ULONG pub_count,
+			   CK_ATTRIBUTE_PTR priv_attribs,
+			   CK_ULONG priv_count,
+			   CK_OBJECT_HANDLE_PTR pub_key,
+			   CK_OBJECT_HANDLE_PTR priv_key)
+{
+	CK_RV rv;
+	struct serializer smecha;
+	struct serializer pub_sattr;
+	struct serializer priv_sattr;
+	uint32_t session_handle = session;
+	char *ctrl = NULL;
+	size_t ctrl_size;
+	uint32_t key_handle[2];
+	size_t key_handle_size = sizeof(key_handle);
+
+	if (!mechanism || !pub_key || !priv_key)
+		return CKR_ARGUMENTS_BAD;
+
+	rv = serialize_ck_mecha_params(&smecha, mechanism);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_attributes(&pub_sattr, pub_attribs, pub_count);
+	if (rv)
+		goto bail;
+
+	rv = serialize_ck_attributes(&priv_sattr, priv_attribs, priv_count);
+	if (rv)
+		goto bail;
+
+	/* ctrl = [session-handle][serial-mecha][serial-pub][serial-priv] */
+	ctrl_size = sizeof(uint32_t) + smecha.size + pub_sattr.size +
+			priv_sattr.size;
+	ctrl = malloc(ctrl_size);
+	if (!ctrl) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	memcpy(ctrl, &session_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t),
+		smecha.buffer, smecha.size);
+	memcpy(ctrl + sizeof(uint32_t) + smecha.size,
+		pub_sattr.buffer, pub_sattr.size);
+	memcpy(ctrl + sizeof(uint32_t) + smecha.size + pub_sattr.size,
+		priv_sattr.buffer, priv_sattr.size);
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+				 SKS_CMD_GENERATE_KEY_PAIR, ctrl, ctrl_size,
+				 NULL, 0, &key_handle[0], &key_handle_size);
+
+	if (key_handle_size != sizeof(key_handle))
+		rv = CKR_GENERAL_ERROR;
+	if (rv)
+		goto bail;
+
+	*pub_key = key_handle[0];
+	*priv_key = key_handle[1];
+
+bail:
+	free(ctrl);
+	release_serial_object(&smecha);
+	release_serial_object(&pub_sattr);
+	release_serial_object(&priv_sattr);
+	return rv;
+}
+
+CK_RV ck_signverify_init(CK_SESSION_HANDLE session,
+			 CK_MECHANISM_PTR mechanism,
+			 CK_OBJECT_HANDLE key,
+			 int sign)
+{
+	CK_RV rv;
+	struct serializer obj;
+	uint32_t session_handle = session;
+	uint32_t key_handle = key;
+	char *ctrl = NULL;
+	size_t ctrl_size;
+
+	rv = serialize_ck_mecha_params(&obj, mechanism);
+	if (rv)
+		return rv;
+
+	/* params = [session-handle][key-handle][serialized-mechanism-blob] */
+	ctrl_size = 2 * sizeof(uint32_t) + obj.size;
+	ctrl = malloc(ctrl_size);
+	if (!ctrl) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	memcpy(ctrl, &session_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), &key_handle, sizeof(uint32_t));
+	memcpy(ctrl + 2 * sizeof(uint32_t), obj.buffer, obj.size);
+
+	rv = ck_invoke_ta(ck_session2sks_ctx(session), sign ?
+			  SKS_CMD_SIGN_INIT : SKS_CMD_VERIFY_INIT,
+			  ctrl, ctrl_size);
+
+bail:
+	free(ctrl);
+	release_serial_object(&obj);
+	return rv;
+}
+
+CK_RV ck_signverify_update(CK_SESSION_HANDLE session,
+			   CK_BYTE_PTR in,
+			   CK_ULONG in_len,
+			   int sign)
+{
+	CK_RV rv;
+	uint32_t ctrl;
+	size_t ctrl_size;
+	void *in_buf = in;
+	size_t in_size = in_len;
+
+	/* params = [session-handle] */
+	ctrl = session;
+	ctrl_size = sizeof(ctrl);
+
+	rv = ck_invoke_ta_in(ck_session2sks_ctx(session), sign ?
+			     SKS_CMD_SIGN_UPDATE : SKS_CMD_VERIFY_UPDATE,
+			     &ctrl, ctrl_size, in_buf, in_size);
+
+	return rv;
+}
+
+CK_RV ck_signverify_oneshot(CK_SESSION_HANDLE session,
+			    CK_BYTE_PTR in,
+			    CK_ULONG in_len,
+			    CK_BYTE_PTR sign_ref,
+			    CK_ULONG_PTR sign_len,
+			    int sign)
+{
+	CK_RV rv;
+	uint32_t ctrl;
+	size_t ctrl_size;
+	void *in_buf = in;
+	size_t in_size = in_len;
+	void *sign_buf = sign_ref;
+	size_t sign_size;
+
+	/* params = [session-handle] */
+	ctrl = session;
+	ctrl_size = sizeof(ctrl);
+
+	if (!sign_len)
+		sign_size = 0;
+	else
+		sign_size = *sign_len;
+
+	if (sign)
+		rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+					 SKS_CMD_SIGN_ONESHOT,
+					 &ctrl, ctrl_size, in_buf, in_size,
+					 sign_buf, &sign_size);
+	else
+		rv = ck_invoke_ta_in_in(ck_session2sks_ctx(session),
+					SKS_CMD_VERIFY_ONESHOT,
+					&ctrl, ctrl_size, in_buf, in_size,
+					sign_buf, sign_size);
+
+	if (sign && sign_len && (rv == CKR_OK || rv == CKR_BUFFER_TOO_SMALL))
+		*sign_len = sign_size;
+
+	return rv;
+}
+
+CK_RV ck_signverify_final(CK_SESSION_HANDLE session,
+			  CK_BYTE_PTR sign_ref,
+			  CK_ULONG_PTR sign_len,
+			  int sign)
+{
+	CK_RV rv;
+	uint32_t ctrl;
+	size_t ctrl_size;
+	void *sign_buf = sign_ref;
+	size_t sign_size = sign_len ? *sign_len : 0;
+
+	/* params = [session-handle] */
+	ctrl = session;
+	ctrl_size = sizeof(ctrl);
+
+	if (sign)
+		rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+					 SKS_CMD_SIGN_FINAL, &ctrl, ctrl_size,
+					 NULL, 0, sign_buf,
+					 sign_buf ? &sign_size : NULL);
+	else
+		rv = ck_invoke_ta_in(ck_session2sks_ctx(session),
+				  SKS_CMD_VERIFY_FINAL,
+				  &ctrl, ctrl_size, sign_buf, sign_size);
+
+	if (sign && sign_len && (rv == CKR_OK || rv == CKR_BUFFER_TOO_SMALL))
+		*sign_len = sign_size;
+
+	return rv;
+}
+
+CK_RV ck_find_objects_init(CK_SESSION_HANDLE session,
+			   CK_ATTRIBUTE_PTR attribs,
+			   CK_ULONG count)
+{
+	CK_RV rv;
+	uint32_t session_handle = session;
+	struct serializer obj;
+	char *ctrl;
+	size_t ctrl_size;
+
+	rv = serialize_ck_attributes(&obj, attribs, count);
+	if (rv)
+		return rv;
+
+	/* ctrl = [session-handle][headed-serialized-attributes] */
+	ctrl_size = sizeof(uint32_t) + obj.size;
+	ctrl = malloc(ctrl_size);
+	if (!ctrl) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	memcpy(ctrl, &session_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), obj.buffer, obj.size);
+
+	rv = ck_invoke_ta(ck_session2sks_ctx(session),
+			  SKS_CMD_FIND_OBJECTS_INIT, ctrl, ctrl_size);
+
+bail:
+	release_serial_object(&obj);
+	free(ctrl);
+	return rv;
+}
+
+CK_RV ck_find_objects(CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE_PTR obj,
+			CK_ULONG max_count,
+			CK_ULONG_PTR count)
+
+{
+	CK_RV rv;
+	uint32_t ctrl[1] = { session };
+	uint32_t *handles;
+	size_t handles_size = max_count * sizeof(uint32_t);
+	CK_ULONG n;
+	CK_ULONG last;
+
+	handles = malloc(handles_size);
+	if (!handles)
+		return CKR_HOST_MEMORY;
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+				 SKS_CMD_FIND_OBJECTS, ctrl, sizeof(ctrl),
+				 NULL, 0, handles, &handles_size);
+
+	if (rv)
+		goto bail;
+
+	last = handles_size / sizeof(uint32_t);
+	*count = last;
+
+	for (n = 0; n < last; n++) {
+		obj[n] = handles[n];
+	}
+
+bail:
+	free(handles);
+	return rv;
+
+}
+
+CK_RV ck_find_objects_final(CK_SESSION_HANDLE session)
+{
+	CK_RV rv;
+	uint32_t ctrl[1] = { session };
+
+	rv = ck_invoke_ta(ck_session2sks_ctx(session),
+			  SKS_CMD_FIND_OBJECTS_FINAL, ctrl, sizeof(ctrl));
+
+	return rv;
+}
+
+CK_RV ck_derive_key(CK_SESSION_HANDLE session,
+		    CK_MECHANISM_PTR mechanism,
+		    CK_OBJECT_HANDLE parent_handle,
+		    CK_ATTRIBUTE_PTR attribs,
+		    CK_ULONG count,
+		    CK_OBJECT_HANDLE_PTR out_handle)
+{
+	CK_RV rv;
+	struct serializer smecha;
+	struct serializer sattr;
+	uint32_t session_handle = session;
+	char *ctrl = NULL;
+	size_t ctrl_size;
+	uint32_t parent_key_handle = parent_handle;
+	uint32_t key_handle;
+	size_t key_handle_size = sizeof(key_handle);
+
+	rv = serialize_ck_mecha_params(&smecha, mechanism);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_attributes(&sattr, attribs, count);
+	if (rv)
+		goto bail;
+
+	/* ctrl = [session][serialized-mecha][parent-key][key-attributes] */
+	ctrl_size = 2 * sizeof(uint32_t) + smecha.size + sattr.size;
+	ctrl = malloc(ctrl_size);
+	if (!ctrl) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	memcpy(ctrl, &session_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), smecha.buffer, smecha.size);
+	memcpy(ctrl + sizeof(uint32_t) + smecha.size,
+			&parent_key_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t) + smecha.size + sizeof(uint32_t),
+			sattr.buffer, sattr.size);
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+				 SKS_CMD_DERIVE_KEY, ctrl, ctrl_size,
+				 NULL, 0, &key_handle, &key_handle_size);
+	if (rv)
+		goto bail;
+
+	*out_handle = key_handle;
+
+bail:
+	free(ctrl);
+	release_serial_object(&smecha);
+	release_serial_object(&sattr);
+	return rv;
+}
+
+CK_RV ck_get_object_size(CK_SESSION_HANDLE session,
+			     CK_OBJECT_HANDLE obj,
+			     CK_ULONG_PTR out_size)
+{
+	CK_RV rv;
+	uint32_t ctrl[2] = { (uint32_t)session, (uint32_t)obj };
+	uint32_t obj_size = 0;
+	size_t size = sizeof(obj_size);
+
+	if (!out_size)
+		return CKR_ARGUMENTS_BAD;
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+				SKS_CMD_GET_OBJECT_SIZE, ctrl,
+				sizeof(ctrl), NULL, 0, &obj_size,
+				&size);
+	if (rv)
+		return rv;
+
+	if (obj_size == SKS_UNAVAILABLE_INFORMATION)
+		*out_size = CK_UNAVAILABLE_INFORMATION;
+	else
+		*out_size = obj_size;
+
+	return rv;
+}
+
+CK_RV ck_get_attribute_value(CK_SESSION_HANDLE session,
+			     CK_OBJECT_HANDLE obj,
+			     CK_ATTRIBUTE_PTR attribs,
+			     CK_ULONG count)
+{
+	CK_RV rv;
+	struct serializer sattr;
+	uint32_t session_handle = session;
+	char *ctrl = NULL;
+	size_t ctrl_size;
+	uint8_t *out = NULL;
+	size_t out_size;
+	uint32_t obj_handle = obj;
+	size_t handle_size = sizeof(obj_handle);
+
+	if (!attribs)
+		return CKR_ARGUMENTS_BAD;
+
+	rv = serialize_ck_attributes(&sattr, attribs, count);
+	if (rv)
+		goto bail;
+
+	/* ctrl = [session][obj-handle][attributes] */
+	ctrl_size = sizeof(uint32_t) + handle_size + sattr.size;
+	ctrl = malloc(ctrl_size);
+	if (!ctrl) {
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+	/* out = [attributes] */
+	out_size = sattr.size;
+	out = malloc(out_size);
+	if (!out){
+		rv = CKR_HOST_MEMORY;
+		goto bail;
+	}
+
+	memcpy(ctrl, &session_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), &obj_handle, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t) + handle_size, sattr.buffer, sattr.size);
+
+	rv = ck_invoke_ta_in_out(ck_session2sks_ctx(session),
+				 SKS_CMD_GET_ATTRIBUTE_VALUE, ctrl, ctrl_size,
+				 NULL, 0, out, &out_size);
+	if (rv != CKR_OK && rv != CKR_BUFFER_TOO_SMALL)
+		goto bail;
+
+	rv = deserialize_ck_attributes(out, attribs, count);
+
+bail:
+	free(ctrl);
+	release_serial_object(&sattr);
+
+	return rv;
+}
diff --git a/libsks/src/pkcs11_processing.h b/libsks/src/pkcs11_processing.h
new file mode 100644
index 0000000..55958c8
--- /dev/null
+++ b/libsks/src/pkcs11_processing.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __PKCS11_PROCESSING_H
+#define __PKCS11_PROCESSING_H
+
+#include <pkcs11.h>
+
+CK_RV ck_create_object(CK_SESSION_HANDLE session,
+			CK_ATTRIBUTE_PTR attribs,
+			CK_ULONG count,
+			CK_OBJECT_HANDLE_PTR phObject);
+
+CK_RV ck_destroy_object(CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE obj);
+
+CK_RV ck_encdecrypt_init(CK_SESSION_HANDLE session,
+			 CK_MECHANISM_PTR mechanism,
+			 CK_OBJECT_HANDLE key,
+			 int decrypt);
+
+CK_RV ck_encdecrypt_update(CK_SESSION_HANDLE session,
+			   CK_BYTE_PTR in,
+			   CK_ULONG in_len,
+			   CK_BYTE_PTR out,
+			   CK_ULONG_PTR out_len,
+			   int decrypt);
+
+CK_RV ck_encdecrypt_oneshot(CK_SESSION_HANDLE session,
+			    CK_BYTE_PTR in,
+			    CK_ULONG in_len,
+			    CK_BYTE_PTR out,
+			    CK_ULONG_PTR out_len,
+			    int decrypt);
+
+CK_RV ck_encdecrypt_final(CK_SESSION_HANDLE session,
+			  CK_BYTE_PTR out,
+			  CK_ULONG_PTR out_len,
+			  int decrypt);
+
+CK_RV ck_generate_key(CK_SESSION_HANDLE session,
+		      CK_MECHANISM_PTR mechanism,
+		      CK_ATTRIBUTE_PTR attribs,
+		      CK_ULONG count,
+		      CK_OBJECT_HANDLE_PTR handle);
+
+CK_RV ck_signverify_init(CK_SESSION_HANDLE session,
+			 CK_MECHANISM_PTR mechanism,
+			 CK_OBJECT_HANDLE key,
+			 int sign);
+
+CK_RV ck_signverify_update(CK_SESSION_HANDLE session,
+			   CK_BYTE_PTR in,
+			   CK_ULONG in_len,
+			   int sign);
+
+CK_RV ck_signverify_oneshot(CK_SESSION_HANDLE session,
+			    CK_BYTE_PTR in,
+			    CK_ULONG in_len,
+			    CK_BYTE_PTR out,
+			    CK_ULONG_PTR out_len,
+			    int sign);
+
+CK_RV ck_signverify_final(CK_SESSION_HANDLE session,
+			  CK_BYTE_PTR out,
+			  CK_ULONG_PTR out_len,
+			  int sign);
+
+CK_RV ck_find_objects_init(CK_SESSION_HANDLE session,
+			   CK_ATTRIBUTE_PTR attribs,
+			   CK_ULONG count);
+
+CK_RV ck_find_objects(CK_SESSION_HANDLE session,
+			CK_OBJECT_HANDLE_PTR obj,
+			CK_ULONG max_count,
+			CK_ULONG_PTR count);
+
+CK_RV ck_find_objects_final(CK_SESSION_HANDLE session);
+
+CK_RV ck_generate_key_pair(CK_SESSION_HANDLE session,
+			   CK_MECHANISM_PTR mechanism,
+			   CK_ATTRIBUTE_PTR pub_attribs,
+			   CK_ULONG pub_count,
+			   CK_ATTRIBUTE_PTR priv_attribs,
+			   CK_ULONG priv_count,
+			   CK_OBJECT_HANDLE_PTR pub_key,
+			   CK_OBJECT_HANDLE_PTR priv_key);
+
+CK_RV ck_derive_key(CK_SESSION_HANDLE session,
+		    CK_MECHANISM_PTR mechanism,
+		    CK_OBJECT_HANDLE parent_handle,
+		    CK_ATTRIBUTE_PTR attribs,
+		    CK_ULONG count,
+		    CK_OBJECT_HANDLE_PTR key_handle);
+
+CK_RV ck_get_object_size(CK_SESSION_HANDLE session,
+			 CK_OBJECT_HANDLE obj,
+			 CK_ULONG_PTR out_size);
+
+CK_RV ck_get_attribute_value(CK_SESSION_HANDLE session,
+			     CK_OBJECT_HANDLE obj,
+			     CK_ATTRIBUTE_PTR attribs,
+			     CK_ULONG count);
+
+#endif /*__PKCS11_PROCESSING_H*/
diff --git a/libsks/src/pkcs11_token.c b/libsks/src/pkcs11_token.c
new file mode 100644
index 0000000..67277e9
--- /dev/null
+++ b/libsks/src/pkcs11_token.c
@@ -0,0 +1,481 @@
+/*
+ * Copyright (c) 2017, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <pkcs11.h>
+#include <sks_ck_debug.h>
+#include <sks_ta.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ck_helpers.h"
+#include "invoke_ta.h"
+#include "local_utils.h"
+#include "pkcs11_token.h"
+
+#define SKS_CRYPTOKI_SLOT_MANUFACTURER		"Linaro"
+
+#define PADDED_STRING_COPY(_dst, _src) \
+	do { \
+		memset((char *)_dst, ' ', sizeof(_dst)); \
+		strncpy((char *)_dst, _src, strlen(_src)); \
+	} while (0)
+
+/**
+ * sks_ck_get_info - implementation of C_GetInfo
+ */
+int sks_ck_get_info(CK_INFO_PTR info)
+{
+	const CK_VERSION ck_version = { 2, 40 };
+	const char manuf_id[] = SKS_CRYPTOKI_SLOT_MANUFACTURER; // TODO slot?
+	const CK_FLAGS flags = 0;	/* must be zero per the PKCS#11 2.40 */
+	const char lib_description[] = "OP-TEE SKS Cryptoki library";
+	const CK_VERSION lib_version = { 0, 0 };
+
+	info->cryptokiVersion = ck_version;
+	PADDED_STRING_COPY(info->manufacturerID, manuf_id);
+	info->flags = flags;
+	PADDED_STRING_COPY(info->libraryDescription, lib_description);
+	info->libraryVersion = lib_version;
+
+	return CKR_OK;
+}
+
+/**
+ * slot_get_info - implementation of C_GetSlotList
+ */
+CK_RV sks_ck_slot_get_list(CK_BBOOL present,
+			   CK_SLOT_ID_PTR slots, CK_ULONG_PTR count)
+{
+	TEEC_SharedMemory *shm;
+	size_t size = 0;
+	CK_RV rv = CKR_GENERAL_ERROR;
+	unsigned int n;
+
+	/* Discard present: all are present */
+	(void)present;
+
+	if (!count)
+		return CKR_ARGUMENTS_BAD;
+
+	if (ck_invoke_ta_in_out(NULL, SKS_CMD_CK_SLOT_LIST, NULL, 0,
+				NULL, 0, NULL, &size) != CKR_BUFFER_TOO_SMALL)
+		return CKR_DEVICE_ERROR;
+
+	if (!slots || *count < (size / sizeof(uint32_t))) {
+		*count = size / sizeof(uint32_t);
+		if (!slots)
+			return CKR_OK;
+
+		return CKR_BUFFER_TOO_SMALL;
+	}
+
+	shm = sks_alloc_shm_out(NULL, size);
+	if (!shm)
+		return CKR_HOST_MEMORY;
+
+	if (ck_invoke_ta_in_out(NULL, SKS_CMD_CK_SLOT_LIST, NULL, 0,
+				NULL, 0, shm, NULL) != CKR_OK) {
+		rv = CKR_DEVICE_ERROR;
+		goto bail;
+	}
+
+	for (n = 0; n < (size / sizeof(uint32_t)); n++)
+		slots[n] = *((uint32_t *)shm->buffer + n);
+
+	*count = size / sizeof(uint32_t);
+	rv = CKR_OK;
+bail:
+	sks_free_shm(shm);
+	return rv;
+
+}
+
+/**
+ * slot_get_info - implementation of C_GetSlotInfo
+ */
+int sks_ck_slot_get_info(CK_SLOT_ID slot, CK_SLOT_INFO_PTR info)
+{
+	uint32_t ctrl[1] = { slot };
+	CK_SLOT_INFO *ck_info = info;
+	struct sks_slot_info sks_info;
+	size_t out_size = sizeof(sks_info);
+	CK_RV rv = CKR_GENERAL_ERROR;
+
+	if (!info)
+		return CKR_ARGUMENTS_BAD;
+
+	rv = ck_invoke_ta_in_out(NULL, SKS_CMD_CK_SLOT_INFO, &ctrl,
+			sizeof(ctrl), NULL, 0, &sks_info, &out_size);
+	if (rv)
+		return rv;
+
+	if (sks2ck_slot_info(ck_info, &sks_info)) {
+		LOG_ERROR("unexpected bad token info structure\n");
+		return CKR_DEVICE_ERROR;
+	}
+
+	return CKR_OK;
+}
+
+/**
+ * slot_get_info - implementation of C_GetTokenInfo
+ */
+CK_RV sks_ck_token_get_info(CK_SLOT_ID slot, CK_TOKEN_INFO_PTR info)
+{
+	uint32_t ctrl[1] = { slot };
+	CK_TOKEN_INFO *ck_info = info;
+	TEEC_SharedMemory *shm;
+	size_t size;
+	CK_RV rv = CKR_GENERAL_ERROR;
+
+	if (!info)
+		return CKR_ARGUMENTS_BAD;
+
+	ctrl[0] = (uint32_t)slot;
+	size = 0;
+	if (ck_invoke_ta_in_out(NULL, SKS_CMD_CK_TOKEN_INFO, ctrl, sizeof(ctrl),
+				NULL, 0, NULL, &size) != CKR_BUFFER_TOO_SMALL)
+		return CKR_DEVICE_ERROR;
+
+	shm = sks_alloc_shm_out(NULL, size);
+	if (!shm)
+		return CKR_HOST_MEMORY;
+
+	ctrl[0] = (uint32_t)slot;
+	rv = ck_invoke_ta_in_out(NULL, SKS_CMD_CK_TOKEN_INFO,
+				 ctrl, sizeof(ctrl), NULL, 0, shm, NULL);
+	if (rv)
+		goto bail;
+
+	if (shm->size < sizeof(struct sks_token_info)) {
+		LOG_ERROR("unexpected bad token info size\n");
+		rv = CKR_DEVICE_ERROR;
+		goto bail;
+	}
+
+	rv = sks2ck_token_info(ck_info, shm->buffer);
+
+bail:
+	sks_free_shm(shm);
+
+	return rv;
+}
+
+/**
+ * sks_ck_init_token - implementation of C_InitToken
+ */
+CK_RV sks_ck_init_token(CK_SLOT_ID slot,
+			CK_UTF8CHAR_PTR pin,
+			CK_ULONG pin_len,
+			CK_UTF8CHAR_PTR label)
+{
+	uint32_t sks_slot = slot;
+	uint32_t sks_pin_len = pin_len;
+	size_t ctrl_size = 2 * sizeof(uint32_t) + sks_pin_len +
+			   32 * sizeof(uint8_t);
+	char *ctrl;
+	size_t offset;
+
+	if (!pin || !label)
+		return CKR_ARGUMENTS_BAD;
+
+	ctrl = malloc(ctrl_size);
+	if (!ctrl)
+		return CKR_HOST_MEMORY;
+
+	memcpy(ctrl, &sks_slot, sizeof(uint32_t));
+	offset = sizeof(uint32_t);
+
+	memcpy(ctrl + offset, &sks_pin_len, sizeof(uint32_t));
+	offset += sizeof(uint32_t);
+
+	memcpy(ctrl + offset, pin, sks_pin_len);
+	offset += sks_pin_len;
+
+	memcpy(ctrl + offset, label, 32 * sizeof(uint8_t));
+
+	return ck_invoke_ta(NULL, SKS_CMD_CK_INIT_TOKEN, ctrl, ctrl_size);
+}
+
+/**
+ * sks_ck_token_mechanism_ids - implementation of C_GetMechanismList
+ */
+CK_RV sks_ck_token_mechanism_ids(CK_SLOT_ID slot,
+				 CK_MECHANISM_TYPE_PTR mechanisms,
+				 CK_ULONG_PTR count)
+{
+	uint32_t ctrl[1] = { slot };
+	size_t outsize = 0;
+	void *outbuf = NULL;
+	CK_RV rv;
+
+	if (!count)
+		return CKR_ARGUMENTS_BAD;
+
+	if (mechanisms) {
+		outsize = *count * sizeof(uint32_t);
+		outbuf = malloc(outsize);
+		if (!outbuf)
+			return CKR_HOST_MEMORY;
+	}
+
+	rv = ck_invoke_ta_in_out(NULL, SKS_CMD_CK_MECHANISM_IDS,
+				 &ctrl, sizeof(ctrl),
+				 NULL, 0, outbuf, &outsize);
+
+	if (rv == CKR_OK || rv == CKR_BUFFER_TOO_SMALL) {
+		*count = outsize / sizeof(uint32_t);
+	}
+	if (!mechanisms && rv == CKR_BUFFER_TOO_SMALL) {
+		rv = CKR_OK;
+		goto bail;
+	}
+	if (rv) {
+		goto bail;
+	}
+
+	if (sks2ck_mechanism_type_list(mechanisms, outbuf, *count)) {
+		LOG_ERROR("unexpected bad mechanism_type list\n");
+		rv = CKR_DEVICE_ERROR;
+	}
+
+bail:
+	free(outbuf);
+
+	return rv;
+}
+
+/**
+ * sks_ck_token_mechanism_info - implementation of C_GetMechanismInfo
+ */
+CK_RV sks_ck_token_mechanism_info(CK_SLOT_ID slot,
+				  CK_MECHANISM_TYPE type,
+				  CK_MECHANISM_INFO_PTR info)
+{
+	CK_RV rv;
+	uint32_t ctrl[2];
+	struct sks_mechanism_info outbuf;
+	size_t outsize = sizeof(outbuf);
+
+	if (!info)
+		return CKR_ARGUMENTS_BAD;
+
+	ctrl[0] = (uint32_t)slot;
+	ctrl[1] = ck2sks_mechanism_type(type);
+	if (ctrl[1] == SKS_UNDEFINED_ID) {
+		LOG_DEBUG("mechanism is not support by this library\n");
+		return CKR_MECHANISM_INVALID;
+	}
+
+	/* info is large enought, for sure */
+	rv = ck_invoke_ta_in_out(NULL, SKS_CMD_CK_MECHANISM_INFO,
+				 &ctrl, sizeof(ctrl),
+				 NULL, 0, &outbuf, &outsize);
+	if (rv)
+		return rv;
+
+	if (sks2ck_mechanism_info(info, &outbuf)) {
+		LOG_ERROR("unexpected bad mechanism info structure\n");
+		rv = CKR_DEVICE_ERROR;
+	}
+	return rv;
+}
+
+/**
+ * sks_ck_open_session - implementation of C_OpenSession
+ */
+CK_RV sks_ck_open_session(CK_SLOT_ID slot,
+		          CK_FLAGS flags,
+		          CK_VOID_PTR cookie,
+		          CK_NOTIFY callback,
+		          CK_SESSION_HANDLE_PTR session)
+{
+	uint32_t ctrl[1] = { slot };
+	unsigned long cmd;
+	uint32_t handle;
+	size_t out_sz = sizeof(handle);
+	CK_RV rv;
+
+	if (!session)
+		return CKR_ARGUMENTS_BAD;
+
+	if (cookie || callback) {
+		LOG_ERROR("C_OpenSession does not handle callback yet\n");
+		return CKR_FUNCTION_NOT_SUPPORTED;
+	}
+
+	if (flags & CKF_RW_SESSION)
+		cmd = SKS_CMD_CK_OPEN_RW_SESSION;
+	else
+		cmd = SKS_CMD_CK_OPEN_RO_SESSION;
+
+	rv = ck_invoke_ta_in_out(NULL, cmd, &ctrl, sizeof(ctrl),
+				 NULL, 0, &handle, &out_sz);
+	if (rv)
+		return rv;
+
+	*session = handle;
+
+	return CKR_OK;
+}
+
+CK_RV sks_ck_close_session(CK_SESSION_HANDLE session)
+{
+	uint32_t ctrl[1] = { (uint32_t)session };
+
+	return ck_invoke_ta(NULL, SKS_CMD_CK_CLOSE_SESSION,
+			    &ctrl, sizeof(ctrl));
+}
+
+/**
+ * sks_ck_close_all_sessions - implementation of C_CloseAllSessions
+ */
+CK_RV sks_ck_close_all_sessions(CK_SLOT_ID slot)
+{
+	uint32_t ctrl[1] = { (uint32_t)slot };
+
+	return ck_invoke_ta(NULL, SKS_CMD_CK_CLOSE_ALL_SESSIONS,
+			    &ctrl, sizeof(ctrl));
+}
+
+/**
+ * sks_ck_get_session_info - implementation of C_GetSessionInfo
+ */
+CK_RV sks_ck_get_session_info(CK_SESSION_HANDLE session,
+			      CK_SESSION_INFO_PTR info)
+{
+	uint32_t ctrl[1] = { (uint32_t)session };
+	CK_SESSION_INFO *s_info = info;
+	TEEC_SharedMemory *shm = NULL;
+	CK_RV rv = CKR_GENERAL_ERROR;
+	size_t info_size = sizeof(struct sks_session_info);
+
+	if (!info)
+		return CKR_ARGUMENTS_BAD;
+
+	shm = sks_alloc_shm_out(NULL, info_size);
+	if (!shm)
+		return CKR_HOST_MEMORY;
+
+	rv = ck_invoke_ta_in_out(NULL, SKS_CMD_CK_SESSION_INFO,
+				   &ctrl, sizeof(ctrl),
+				   NULL, 0, shm, NULL);
+	if (rv)
+		goto bail;
+
+	if (shm->size < info_size) {
+		LOG_ERROR("unexpected bad session info size\n");
+		rv = CKR_DEVICE_ERROR;
+		goto bail;
+	}
+
+	rv = sks2ck_session_info(s_info, shm->buffer);
+
+bail:
+	sks_free_shm(shm);
+
+	return rv;
+}
+
+/**
+ * sks_ck_init_pin - implementation of C_InitPIN
+ */
+CK_RV sks_ck_init_pin(CK_SESSION_HANDLE session,
+		      CK_UTF8CHAR_PTR pin, CK_ULONG pin_len)
+{
+	uint32_t sks_session = session;
+	uint32_t sks_pin_len = pin_len;
+	size_t ctrl_size = 2 * sizeof(uint32_t) + sks_pin_len;
+	char *ctrl;
+
+	ctrl = malloc(ctrl_size);
+	if (!ctrl)
+		return CKR_HOST_MEMORY;
+
+	memcpy(ctrl, &sks_session, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), &sks_pin_len, sizeof(uint32_t));
+	memcpy(ctrl + 2 * sizeof(uint32_t), pin, sks_pin_len);
+
+	return ck_invoke_ta(NULL, SKS_CMD_INIT_PIN, ctrl, ctrl_size);
+}
+
+/**
+ * sks_ck_set_pin - implementation of C_SetPIN
+ */
+CK_RV sks_ck_set_pin(CK_SESSION_HANDLE session,
+		     CK_UTF8CHAR_PTR old, CK_ULONG old_len,
+		     CK_UTF8CHAR_PTR new, CK_ULONG new_len)
+{
+	uint32_t sks_session = session;
+	uint32_t sks_old_len = old_len;
+	uint32_t sks_new_len = new_len;
+	size_t ctrl_size = 3 * sizeof(uint32_t) + sks_old_len + sks_new_len;
+	char *ctrl;
+	size_t offset;
+
+	ctrl = malloc(ctrl_size);
+	if (!ctrl)
+		return CKR_HOST_MEMORY;
+
+	memcpy(ctrl, &sks_session, sizeof(uint32_t));
+	offset = sizeof(uint32_t);
+
+	memcpy(ctrl + offset, &sks_old_len, sizeof(uint32_t));
+	offset += sizeof(uint32_t);
+
+	memcpy(ctrl + offset, old, sks_old_len);
+	offset += sks_old_len;
+
+	memcpy(ctrl + offset, &sks_new_len, sizeof(uint32_t));
+	offset += sizeof(uint32_t);
+
+	memcpy(ctrl + offset, new, sks_new_len);
+
+	return ck_invoke_ta(NULL, SKS_CMD_SET_PIN, ctrl, ctrl_size);
+}
+
+/**
+ * sks_ck_login - implementation of C_Login
+ */
+CK_RV sks_ck_login(CK_SESSION_HANDLE session, CK_USER_TYPE user_type,
+		   CK_UTF8CHAR_PTR pin, CK_ULONG pin_len)
+
+{
+	uint32_t sks_session = session;
+	uint32_t sks_user = ck2sks_user_type(user_type);
+	uint32_t sks_pin_len = pin_len;
+	size_t ctrl_size = 3 * sizeof(uint32_t) + sks_pin_len;
+	char *ctrl;
+
+	ctrl = malloc(ctrl_size);
+	if (!ctrl)
+		return CKR_HOST_MEMORY;
+
+	memcpy(ctrl, &sks_session, sizeof(uint32_t));
+	memcpy(ctrl + sizeof(uint32_t), &sks_user, sizeof(uint32_t));
+	memcpy(ctrl + 2 * sizeof(uint32_t), &sks_pin_len, sizeof(uint32_t));
+	memcpy(ctrl + 3 * sizeof(uint32_t), pin, sks_pin_len);
+
+	return ck_invoke_ta(NULL, SKS_CMD_LOGIN, ctrl, ctrl_size);
+}
+
+/**
+ * sks_ck_logout - implementation of C_Logout
+ */
+CK_RV sks_ck_logout(CK_SESSION_HANDLE session)
+{
+	uint32_t sks_session = session;
+	size_t ctrl_size = sizeof(uint32_t);
+	char *ctrl;
+
+	ctrl = malloc(ctrl_size);
+	if (!ctrl)
+		return CKR_HOST_MEMORY;
+
+	memcpy(ctrl, &sks_session, sizeof(uint32_t));
+
+	return ck_invoke_ta(NULL, SKS_CMD_LOGOUT, ctrl, ctrl_size);
+}
diff --git a/libsks/src/pkcs11_token.h b/libsks/src/pkcs11_token.h
new file mode 100644
index 0000000..56e7a00
--- /dev/null
+++ b/libsks/src/pkcs11_token.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2017, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __PKCS11_TOKEN_H
+#define __PKCS11_TOKEN_H
+
+#include <pkcs11.h>
+
+#include "invoke_ta.h"
+
+int sks_ck_get_info(CK_INFO_PTR info);
+CK_RV sks_ck_slot_get_list(CK_BBOOL present,
+			   CK_SLOT_ID_PTR slots, CK_ULONG_PTR count);
+int sks_ck_slot_get_info(CK_SLOT_ID slot, CK_SLOT_INFO_PTR info);
+CK_RV sks_ck_token_get_info(CK_SLOT_ID slot, CK_TOKEN_INFO_PTR info);
+
+CK_RV sks_ck_token_mechanism_ids(CK_SLOT_ID slot,
+				 CK_MECHANISM_TYPE_PTR mechanisms,
+				 CK_ULONG_PTR count);
+
+CK_RV sks_ck_token_mechanism_info(CK_SLOT_ID slot,
+				  CK_MECHANISM_TYPE type,
+				  CK_MECHANISM_INFO_PTR info);
+
+CK_RV sks_ck_init_token(CK_SLOT_ID slot,
+			CK_UTF8CHAR_PTR pin,
+			CK_ULONG pin_len,
+			CK_UTF8CHAR_PTR label);
+
+CK_RV sks_ck_open_session(CK_SLOT_ID slot,
+		          CK_FLAGS flags,
+		          CK_VOID_PTR cookie,
+		          CK_NOTIFY callback,
+		          CK_SESSION_HANDLE_PTR session);
+CK_RV sks_ck_close_session(CK_SESSION_HANDLE session);
+CK_RV sks_ck_close_all_sessions(CK_SLOT_ID slot);
+CK_RV sks_ck_get_session_info(CK_SESSION_HANDLE session,
+			      CK_SESSION_INFO_PTR info);
+
+CK_RV sks_ck_init_pin(CK_SESSION_HANDLE session,
+		      CK_UTF8CHAR_PTR pin, CK_ULONG pin_len);
+CK_RV sks_ck_set_pin(CK_SESSION_HANDLE session,
+		     CK_UTF8CHAR_PTR old, CK_ULONG old_len,
+		     CK_UTF8CHAR_PTR new, CK_ULONG new_len);
+CK_RV sks_ck_login(CK_SESSION_HANDLE session, CK_USER_TYPE user_type,
+		   CK_UTF8CHAR_PTR pin, CK_ULONG pin_len);
+CK_RV sks_ck_logout(CK_SESSION_HANDLE session);
+
+#endif /*__PKCS11_TOKEN_H*/
diff --git a/libsks/src/serialize_ck.c b/libsks/src/serialize_ck.c
new file mode 100644
index 0000000..7fe12de
--- /dev/null
+++ b/libsks/src/serialize_ck.c
@@ -0,0 +1,1168 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <pkcs11.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+#include <sks_ck_debug.h>
+#include <sks_ta.h>
+
+#include "ck_helpers.h"
+#include "local_utils.h"
+#include "serializer.h"
+#include "serialize_ck.h"
+
+/*
+ * Generic way of serializing CK keys, certif, mechanism parameters, ...
+ * In cryptoki 2.40 parameters are almost all packaged as struture below:
+ */
+struct ck_ref {
+	CK_ULONG id;
+	CK_BYTE_PTR ptr;
+	CK_ULONG len;
+};
+
+#if 0
+/*
+ * Append cryptoki generic buffer reference structure into a sks serial
+ * object.
+ *
+ * ck_ref points to a structure aligned CK reference (attributes or else)
+ */
+static CK_RV serialize_ck_ref(struct serializer *obj, void *ck_ref)
+{
+	struct ck_ref *ref = ck_ref;
+	CK_RV rv;
+
+	rv = serialize_ck_ulong(obj, ref->id);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_ulong(obj, ref->len);
+	if (rv)
+		return rv;
+
+	rv = serialize_buffer(obj, ref->ptr, ref->len);
+	if (rv)
+		return rv;
+
+	obj->item_count++;
+
+	return rv;
+}
+
+/*
+ * ck_ref points to a structure aligned CK reference (attributes or else)
+ *
+ * Same as serialize_ck_ref but reference is a ULONG so the blob size
+ * to be set accoring to the 32bit/64bit configuration of target CK ABI.
+ */
+static CK_RV serialize_ulong_ck_ref(struct serializer *obj, void *ck_ref)
+{
+	struct ck_ref *ref = ck_ref;
+	CK_ULONG ck_value;
+	uint32_t sks_value;
+	CK_RV rv;
+
+	rv = serialize_ck_ulong(obj, ref->id);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_ulong(obj, sizeof(sks_value));
+	if (rv)
+		return rv;
+
+	memcpy(&ck_value, ref->ptr, sizeof(CK_ULONG));
+	sks_value = ck_value;
+
+	rv = serialize_buffer(obj, &sks_value, sizeof(sks_value));
+	if (rv)
+		return rv;
+
+	obj->item_count++;
+
+	return rv;
+}
+#endif
+
+/*
+ * This is for attributes that contains data memory indirections.
+ * In other words, an attributes that defines a list of attributes.
+ * They are identified from the attribute type CKA_...
+ *
+ * @obj - ref used to track the serial object being created
+ * @attribute - pointer to a structure aligned of the CK_ATTRIBUTE struct
+ */
+static CK_RV serialize_indirect_attribute(struct serializer *obj,
+					  CK_ATTRIBUTE_PTR attribute)
+{
+	CK_ATTRIBUTE_PTR attr;
+	CK_ULONG count;
+	CK_RV rv;
+	struct serializer obj2;
+
+	switch (attribute->type) {
+	/* These are serialized each seperately */
+	case CKA_WRAP_TEMPLATE:
+	case CKA_UNWRAP_TEMPLATE:
+		count = attribute->ulValueLen / sizeof(CK_ATTRIBUTE);
+		attr = (CK_ATTRIBUTE_PTR)attribute->pValue;
+		break;
+	default:
+		return CKR_NO_EVENT;
+	}
+
+	/* Create a serialized object for the content */
+	rv = serialize_ck_attributes(&obj2, attr, count);
+	if (rv)
+		return rv;
+
+	/*
+	 * Append the created serialized object into target object:
+	 * [attrib-id][byte-size][attributes-data]
+	 */
+	rv = serialize_32b(obj, ck2sks_attribute_type(attribute->type));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, obj2.size);
+	if (rv)
+		return rv;
+
+	rv = serialize_buffer(obj, obj2.buffer, obj2.size);
+	if (rv)
+		return rv;
+
+	obj->item_count++;
+
+	return rv;
+}
+
+static CK_RV deserialize_indirect_attribute(struct sks_attribute_head *obj,
+					    CK_ATTRIBUTE_PTR attribute)
+{
+	CK_ULONG count;
+	CK_ATTRIBUTE_PTR attr;
+	CK_RV rv;
+
+	switch (attribute->type) {
+	/* These are serialized each seperately */
+	case CKA_WRAP_TEMPLATE:
+	case CKA_UNWRAP_TEMPLATE:
+		count = attribute->ulValueLen / sizeof(CK_ATTRIBUTE);
+		attr = (CK_ATTRIBUTE_PTR)attribute->pValue;
+		break;
+	default:
+		return CKR_GENERAL_ERROR;
+	}
+
+	/*
+	 * deserialize_ck_attributes expects sks_attribute_head,
+	 * not sks_object_head, so we need to correct the pointer
+	 */
+	rv = deserialize_ck_attributes(obj->data, attr, count);
+	return rv;
+}
+
+static int ck_attr_is_ulong(CK_ATTRIBUTE_TYPE attribute_id)
+{
+	return (ck_attr_is_class(attribute_id) ||
+		ck_attr_is_type(attribute_id) ||
+		attribute_id == CKA_VALUE_LEN ||
+		attribute_id == CKA_CERTIFICATE_CATEGORY ||
+		attribute_id == CKA_NAME_HASH_ALGORITHM ||
+		attribute_id == CKA_MODULUS_BITS);
+}
+
+static CK_RV serialize_ck_attribute(struct serializer *obj, CK_ATTRIBUTE *attr)
+{
+	uint32_t sks_id = SKS_UNDEFINED_ID;
+	uint32_t sks_size = 0;
+	uint32_t sks_data32;
+	void *sks_pdata;
+	int sks_pdata_alloced = 0;
+	CK_ULONG ck_ulong = 0;		/* keep compiler happy */
+	CK_RV rv;
+	unsigned int n;
+	unsigned int m;
+
+	/* Expect only those from the identification table */
+	sks_id = ck2sks_attribute_type(attr->type);
+	if (sks_id == SKS_UNDEFINED_ID)
+		return CKR_ATTRIBUTE_TYPE_INVALID;
+
+	if (ck_attr_is_ulong(attr->type)) {
+		/* PKCS#11 CK_ULONG are use */
+		if (attr->ulValueLen != sizeof(CK_ULONG))
+			return CKR_ATTRIBUTE_TYPE_INVALID;
+
+		memcpy(&ck_ulong, attr->pValue, sizeof(ck_ulong));
+	}
+
+	switch (attr->type) {
+	case CKA_CLASS:
+		sks_data32 = ck2sks_object_class(ck_ulong);
+		sks_pdata = &sks_data32;
+		sks_size = sizeof(uint32_t);
+		break;
+
+	case CKA_KEY_TYPE:
+		sks_data32 = ck2sks_key_type(ck_ulong);
+		sks_pdata = &sks_data32;
+		sks_size = sizeof(uint32_t);
+		break;
+
+	case CKA_CERTIFICATE_TYPE:
+		sks_data32 = ck2sks_certificate_type(ck_ulong);
+		sks_pdata = &sks_data32;
+		sks_size = sizeof(uint32_t);
+		break;
+
+	case CKA_WRAP_TEMPLATE:
+	case CKA_UNWRAP_TEMPLATE:
+		return serialize_indirect_attribute(obj, attr);
+
+	case CKA_ALLOWED_MECHANISMS:
+		n = attr->ulValueLen / sizeof(CK_ULONG);
+		sks_size = n * sizeof(uint32_t);
+		sks_pdata = malloc(sks_size);
+		if (!sks_pdata)
+			return CKR_HOST_MEMORY;
+
+		sks_pdata_alloced = 1;
+
+		for (m = 0; m < n; m++) {
+			CK_MECHANISM_TYPE *type = attr->pValue;
+
+			sks_data32 = ck2sks_mechanism_type(type[m]);
+			if (sks_data32 == SKS_UNDEFINED_ID) {
+				free(sks_pdata);
+				return CKR_MECHANISM_INVALID;
+			}
+
+			((uint32_t *)sks_pdata)[m] = sks_data32;
+		}
+		break;
+
+	/* Attributes which data value do not need conversion (aside ulong) */
+	default:
+		if (ck_attr_is_ulong(attr->type)) {
+			sks_data32 = (uint32_t)ck_ulong;
+			sks_pdata = &sks_data32;
+			sks_size = sizeof(uint32_t);
+		} else {
+			sks_pdata = attr->pValue;
+			sks_size = attr->ulValueLen;
+		}
+		break;
+	}
+
+	rv = serialize_32b(obj, sks_id);
+	if (rv)
+		goto bail;
+
+	rv = serialize_32b(obj, sks_size);
+	if (rv)
+		goto bail;
+
+	rv = serialize_buffer(obj, sks_pdata, sks_size);
+	if (rv)
+		goto bail;
+
+	obj->item_count++;
+
+bail:
+	if (sks_pdata_alloced)
+		free(sks_pdata);
+
+	return rv;
+}
+
+#ifdef SKS_WITH_GENERIC_ATTRIBS_IN_HEAD
+static CK_RV get_class(struct serializer *obj, struct ck_ref *ref)
+{
+	CK_ULONG ck_value;
+	uint32_t sks_value;
+
+	if (ref->len != sizeof(ck_value))
+		return CKR_TEMPLATE_INCONSISTENT;
+
+	memcpy(&ck_value, ref->ptr, sizeof(ck_value));
+
+	sks_value = ck2sks_object_class(ck_value);
+
+	if (sks_value == SKS_UNDEFINED_ID)
+		return CKR_TEMPLATE_INCONSISTENT; // TODO: errno
+
+	if (obj->object == SKS_UNDEFINED_ID)
+		obj->object = sks_value;
+
+	if (obj->object != sks_value) {
+		printf("Attribute %s redefined\n", cka2str(ref->id));
+		return CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	return CKR_OK;
+}
+
+static CK_RV get_type(struct serializer *obj, struct ck_ref *ref,
+		      CK_ULONG class)
+{
+	CK_ULONG ck_value;
+	uint32_t sks_value;
+
+	if (ref->len != sizeof(ck_value))
+		return CKR_TEMPLATE_INCONSISTENT;
+
+	memcpy(&ck_value, ref->ptr, sizeof(ck_value));
+
+	sks_value = ck2sks_type_in_class(ck_value, class);
+
+	if (sks_value == SKS_UNDEFINED_ID)
+		return CKR_TEMPLATE_INCONSISTENT; // TODO: errno
+
+	if (obj->type == SKS_UNDEFINED_ID)
+		obj->type = sks_value;
+
+	if (obj->type != sks_value) {
+		printf("Attribute %s redefined\n",
+			cktype2str(ck_value, class));
+		return CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	return CKR_OK;
+}
+
+#ifdef /* SKS_WITH_BOOLPROP_ATTRIBS_IN_HEAD */
+static CK_RV get_boolprop(struct serializer *obj,
+			  struct ck_ref *ref, uint32_t *sanity)
+{
+	int shift;
+	uint32_t mask;
+	uint32_t value;
+	uint32_t *boolprop_ptr;
+	uint32_t *sanity_ptr;
+	CK_BBOOL bbool;
+
+	/* Get the boolean property shift position and value */
+	shift = ck_attr2boolprop_shift(ref->id);
+	if (shift < 0)
+		return CKR_NO_EVENT;
+
+	if (shift >= SKS_MAX_BOOLPROP_SHIFT)
+		return CKR_FUNCTION_FAILED;
+
+	memcpy(&bbool, ref->ptr, sizeof(bbool));
+
+	mask = 1 << (shift % 32);
+	if (bbool == CK_TRUE)
+		value = mask;
+	else
+		value = 0;
+
+	/* Locate the current config value for the boolean property */
+	boolprop_ptr = obj->boolprop + (shift / 32);
+	sanity_ptr = sanity + (shift / 32);
+
+	/* Error if already set to a different boolean value */
+	if ((*sanity_ptr & mask) && value != (*boolprop_ptr & mask)) {
+		printf("Attribute %s redefined\n", cka2str(ref->id));
+		return CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	*sanity_ptr |= mask;
+	if (value)
+		*boolprop_ptr |= mask;
+	else
+		*boolprop_ptr &= ~mask;
+
+	return CKR_OK;
+}
+#endif /* SKS_WITH_BOOLPROP_ATTRIBS_IN_HEAD */
+
+/*
+ * Extract object generic attributes
+ * - all objects must provide at least a class
+ * - some classes expect a type
+ * - some classes can define generic boolean attributes (boolprops)
+ */
+static CK_RV serialize_generic_attributes(struct serializer *obj,
+					  CK_ATTRIBUTE_PTR attributes,
+					  CK_ULONG count)
+{
+	struct ck_ref *ref;
+	size_t n;
+	uint32_t sanity[SKS_MAX_BOOLPROP_ARRAY] = { 0 };
+	CK_RV rv = CKR_OK;
+	CK_ULONG class;
+
+	for (ref = (struct ck_ref *)attributes, n = 0; n < count; n++, ref++) {
+		if (ck_attr_is_class(ref->id))
+			rv = get_class(obj, ref);
+		if (rv)
+			return rv;
+	}
+
+	rv = sks2ck_object_class(&class, obj->object);
+	if (rv)
+		return rv;
+
+	for (ref = (struct ck_ref *)attributes, n = 0; n < count; n++, ref++) {
+		if (ck_attr_is_type(ref->id)) {
+			rv = get_type(obj, ref, class);
+			if (rv)
+				return rv;
+
+			continue;
+		}
+
+#ifdef SKS_WITH_BOOLPROP_ATTRIBS_IN_HEAD
+		if (sks_object_has_boolprop(obj->object) &&
+		    ck_attr2boolprop_shift(ref->id) >= 0) {
+			rv = get_boolprop(obj, ref, sanity);
+			if (rv == CKR_NO_EVENT)
+				rv = CKR_OK;
+
+			if (rv)
+				return rv;
+
+			continue;
+		}
+#endif
+	}
+
+	return rv;
+}
+
+static int ck_attr_is_generic(CK_ULONG attribute_id)
+{
+	return (ck_attr_is_class(attribute_id) ||
+#ifdef SKS_WITH_BOOLPROP_ATTRIBS_IN_HEAD
+		(ck_attr2boolprop_shift(attribute_id) >= 0) ||
+#endif
+		ck_attr_is_type(attribute_id));
+}
+#endif /* SKS_WITH_GENERIC_ATTRIBS_IN_HEAD */
+
+/* CK attribute reference arguments are list of attribute item */
+CK_RV serialize_ck_attributes(struct serializer *obj,
+				CK_ATTRIBUTE_PTR attributes, CK_ULONG count)
+{
+	CK_ATTRIBUTE_PTR cur_attr = attributes;
+	CK_ULONG n = count;
+	CK_RV rv = CKR_OK;
+
+	rv = init_serial_object(obj);
+	if (rv)
+		return rv;
+
+#ifdef SKS_WITH_GENERIC_ATTRIBS_IN_HEAD
+	rv = serialize_generic_attributes(obj, attributes, count);
+	if (rv)
+		goto out;
+#endif
+
+	for (; n; n--, cur_attr++) {
+		CK_ATTRIBUTE attr;
+
+		memcpy(&attr, cur_attr, sizeof(attr));
+
+#ifdef SKS_WITH_GENERIC_ATTRIBS_IN_HEAD
+		if (ck_attr_is_generic(attr.type))
+			continue;
+#endif
+
+		rv = serialize_ck_attribute(obj, &attr);
+		if (rv)
+			goto out;
+	}
+
+out:
+	if (rv)
+		release_serial_object(obj);
+	else
+		finalize_serial_object(obj);
+
+	return rv;
+}
+
+static CK_RV deserialize_ck_attribute(struct sks_attribute_head *in,
+				      CK_ATTRIBUTE_PTR out)
+{
+	CK_ULONG ck_ulong;
+	uint32_t sks_data32 = 0;
+	size_t n;
+	CK_RV rv;
+
+	rv = sks2ck_attribute_type(&(out->type), in->id);
+	if (rv)
+		return rv;
+
+	if (out->ulValueLen < in->size) {
+		out->ulValueLen = in->size;
+		return CKR_OK;
+	}
+
+	if (!out->pValue)
+		return CKR_OK;
+
+	/* Specific ulong encoded as 32bit in SKS TA API */
+	if (ck_attr_is_ulong(out->type)) {
+		if (out->ulValueLen != sizeof(CK_ULONG))
+			return CKR_ATTRIBUTE_TYPE_INVALID;
+
+		memcpy(&sks_data32, in->data, sizeof(uint32_t));
+	}
+
+	switch (out->type) {
+	case CKA_CLASS:
+		rv = sks2ck_object_class(&ck_ulong, sks_data32);
+		if (rv)
+			return rv;
+		memcpy(out->pValue, &ck_ulong, sizeof(CK_ULONG));
+		break;
+
+	case CKA_KEY_TYPE:
+		rv = sks2ck_key_type(&ck_ulong, sks_data32);
+		if (rv)
+			return rv;
+		memcpy(out->pValue, &ck_ulong, sizeof(CK_ULONG));
+		break;
+
+	case CKA_CERTIFICATE_TYPE:
+		rv = sks2ck_certificate_type(&ck_ulong, sks_data32);
+		if (rv)
+			return rv;
+		memcpy(out->pValue, &ck_ulong, sizeof(CK_ULONG));
+		break;
+
+	case CKA_KEY_GEN_MECHANISM:
+		memcpy(&sks_data32, in->data, sizeof(uint32_t));
+		if (sks_data32 == SKS_UNAVAILABLE_INFORMATION)
+			ck_ulong = CK_UNAVAILABLE_INFORMATION;
+		else
+			ck_ulong = sks_data32;
+		memcpy(out->pValue, &ck_ulong, sizeof(CK_ULONG));
+		rv = CKR_OK;
+		break;
+
+	case CKA_WRAP_TEMPLATE:
+	case CKA_UNWRAP_TEMPLATE:
+		rv = deserialize_indirect_attribute(in, out->pValue);
+		break;
+
+	case CKA_ALLOWED_MECHANISMS:
+		n = out->ulValueLen / sizeof(CK_ULONG);
+		rv = sks2ck_mechanism_type_list(out->pValue, in->data, n);
+		break;
+
+	/* Attributes which data value do not need conversion (aside ulong) */
+	default:
+		memcpy(out->pValue, in->data, in->size);
+		rv = CKR_OK;
+		break;
+	}
+
+	return rv;
+}
+
+CK_RV deserialize_ck_attributes(uint8_t *in, CK_ATTRIBUTE_PTR attributes,
+				CK_ULONG count)
+{
+	CK_ATTRIBUTE_PTR cur_attr = attributes;
+	CK_ULONG n;
+	CK_RV rv = CKR_OK;
+	uint8_t *curr_head = in;
+	size_t len;
+
+	curr_head += sizeof(struct sks_object_head);
+
+#ifdef SKS_WITH_GENERIC_ATTRIBS_IN_HEAD
+#error Not supported.
+#endif
+
+	for (n = count; n > 0; n--, cur_attr++, curr_head += len) {
+		struct sks_attribute_head *cli_ref =
+			(struct sks_attribute_head *)(void *)curr_head;
+
+		len = sizeof(*cli_ref);
+		/*
+		 * Can't trust size becuase it was set to reflect
+		 * required buffer.
+		 */
+		if (cur_attr->pValue)
+			len += cli_ref->size;
+
+		rv = deserialize_ck_attribute(cli_ref, cur_attr);
+		if (rv)
+			goto out;
+	}
+
+out:
+	return rv;
+}
+
+/*
+ * Serialization of CK mechanism parameters
+ *
+ * Most mechanism have no parameters.
+ * Some mechanism have a single 32bit parameter.
+ * Some mechanism have a specific parameter structure which may contain
+ * indirected data (data referred by a buffer pointer).
+ *
+ * Below are each structure specific mechanisms parameters.
+ *
+ * Be careful that CK_ULONG based types translate to 32bit sks ulong fields.
+ */
+
+/*
+ * typedef struct CK_AES_CTR_PARAMS {
+ *	CK_ULONG ulCounterBits;
+ *	CK_BYTE cb[16];
+ * } CK_AES_CTR_PARAMS;
+ */
+static CK_RV serialize_mecha_aes_ctr(struct serializer *obj,
+				     CK_MECHANISM_PTR mecha)
+{
+	CK_AES_CTR_PARAMS_PTR param = mecha->pParameter;
+	CK_RV rv;
+	uint32_t size;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	size = sizeof(uint32_t) + sizeof(param->cb);
+	rv = serialize_32b(obj, size);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_ulong(obj, param->ulCounterBits);
+	if (rv)
+		return rv;
+
+	rv = serialize_buffer(obj, param->cb, sizeof(param->cb));
+	if (rv)
+		return rv;
+
+	return rv;
+}
+
+/*
+ * typedef struct CK_GCM_PARAMS {
+ *	CK_BYTE_PTR       pIv;
+ *	CK_ULONG          ulIvLen;
+ *	CK_ULONG          ulIvBits; -> unused (deprecated?)
+ *	CK_BYTE_PTR       pAAD;
+ *	CK_ULONG          ulAADLen;
+ *	CK_ULONG          ulTagBits;
+ * } CK_GCM_PARAMS;
+ *
+ * Serialized:
+ * [uint32_t mechanism_id]
+ * [uint32_t parameters_byte_size = 3 * 8 + IV size + AAD size]
+ * [uint32_t iv_byte_size]
+ * [uint8_t  iv[iv_byte_size]]
+ * [uint32_t aad_byte_size]
+ * [uint8_t  aad[aad_byte_size]]
+ * [uint32_t tag_bit_size]
+ */
+static CK_RV serialize_mecha_aes_gcm(struct serializer *obj,
+				     CK_MECHANISM_PTR mecha)
+{
+	CK_GCM_PARAMS_PTR param = mecha->pParameter;
+	CK_RV rv;
+	CK_ULONG aad_len;
+
+	/* AAD is not manadatory */
+	if (param->pAAD)
+		aad_len = param->ulAADLen;
+	else
+		aad_len = 0;
+
+	if (!param->pIv)
+		return CKR_MECHANISM_PARAM_INVALID;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, 3 * sizeof(uint32_t) +
+				param->ulIvLen + aad_len);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_ulong(obj, param->ulIvLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_buffer(obj, param->pIv, param->ulIvLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_ulong(obj, aad_len);
+	if (rv)
+		return rv;
+
+	rv = serialize_buffer(obj, param->pAAD, aad_len);
+	if (rv)
+		return rv;
+
+	return serialize_ck_ulong(obj, param->ulTagBits);
+}
+
+/*
+ * typedef struct CK_CCM_PARAMS {
+ *	CK_ULONG          ulDataLen;
+ *	CK_BYTE_PTR       pNonce;
+ *	CK_ULONG          ulNonceLen;
+ *	CK_BYTE_PTR       pAAD;
+ *	CK_ULONG          ulAADLen;
+ *	CK_ULONG          ulMACLen;
+ *} CK_CCM_PARAMS;
+ */
+static CK_RV serialize_mecha_aes_ccm(struct serializer *obj,
+				     CK_MECHANISM_PTR mecha)
+{
+	CK_CCM_PARAMS_PTR param = mecha->pParameter;
+	CK_RV rv;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, 4 * sizeof(uint32_t) +
+				param->ulNonceLen + param->ulAADLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_ulong(obj, param->ulDataLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_ulong(obj, param->ulNonceLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_buffer(obj, param->pNonce, param->ulNonceLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_ck_ulong(obj, param->ulAADLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_buffer(obj, param->pAAD, param->ulAADLen);
+	if (rv)
+		return rv;
+
+	return serialize_ck_ulong(obj, param->ulMACLen);
+}
+
+static CK_RV serialize_mecha_aes_iv(struct serializer *obj,
+				    CK_MECHANISM_PTR mecha)
+{
+	uint32_t iv_size = mecha->ulParameterLen;
+	CK_RV rv;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, iv_size);
+	if (rv)
+		return rv;
+
+	return serialize_buffer(obj, mecha->pParameter, mecha->ulParameterLen);
+}
+
+static CK_RV serialize_mecha_ulong_param(struct serializer *obj,
+					 CK_MECHANISM_PTR mecha)
+{
+	CK_RV rv;
+	uint32_t sks_data;
+	CK_ULONG ck_data;
+
+	memcpy(&ck_data, mecha->pParameter, mecha->ulParameterLen);
+	sks_data = ck_data;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	return serialize_32b(obj, sks_data);
+}
+
+static CK_RV serialize_mecha_ecdh1_derive_param(struct serializer *obj,
+						CK_MECHANISM_PTR mecha)
+{
+	CK_ECDH1_DERIVE_PARAMS *params = mecha->pParameter;
+	CK_RV rv;
+	size_t params_size = 3 * sizeof(uint32_t) + params->ulSharedDataLen +
+				params->ulPublicDataLen;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params_size);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, ck2sks_ec_kdf_type(params->kdf));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params->ulSharedDataLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_buffer(obj, params->pSharedData,
+				params->ulSharedDataLen);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params->ulPublicDataLen);
+	if (rv)
+		return rv;
+
+	return serialize_buffer(obj, params->pPublicData,
+				params->ulPublicDataLen);
+}
+
+static CK_RV serialize_mecha_ecdh_aes_key_wrap_param(struct serializer *obj,
+						     CK_MECHANISM_PTR mecha)
+{
+	CK_ECDH_AES_KEY_WRAP_PARAMS *params = mecha->pParameter;
+	CK_RV rv;
+	size_t params_size = 3 * sizeof(uint32_t) + params->ulSharedDataLen;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params_size);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params->ulAESKeyBits);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, ck2sks_ec_kdf_type(params->kdf));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params->ulSharedDataLen);
+	if (rv)
+		return rv;
+
+	return serialize_buffer(obj, params->pSharedData,
+				params->ulSharedDataLen);
+}
+
+static CK_RV serialize_mecha_rsa_oaep_param(struct serializer *obj,
+					    CK_MECHANISM_PTR mecha)
+{
+	CK_RSA_PKCS_OAEP_PARAMS *params = mecha->pParameter;
+	CK_RV rv;
+	size_t params_size = 4 * sizeof(uint32_t) + params->ulSourceDataLen;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params_size);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, ck2sks_mechanism_type(params->hashAlg));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, ck2sks_rsa_pkcs_mgf_type(params->mgf));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj,
+			   ck2sks_rsa_pkcs_oaep_source_type(params->source));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params->ulSourceDataLen);
+	if (rv)
+		return rv;
+
+	return serialize_buffer(obj, params->pSourceData,
+				params->ulSourceDataLen);
+}
+
+static CK_RV serialize_mecha_rsa_pss_param(struct serializer *obj,
+					   CK_MECHANISM_PTR mecha)
+{
+	CK_RSA_PKCS_PSS_PARAMS *params = mecha->pParameter;
+	CK_RV rv;
+	size_t params_size = 3 * sizeof(uint32_t);
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params_size);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, ck2sks_mechanism_type(params->hashAlg));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, ck2sks_rsa_pkcs_mgf_type(params->mgf));
+	if (rv)
+		return rv;
+
+	return serialize_32b(obj, params->sLen);
+}
+
+static CK_RV serialize_mecha_rsa_aes_key_wrap_param(struct serializer *obj,
+						    CK_MECHANISM_PTR mecha)
+{
+	CK_RSA_AES_KEY_WRAP_PARAMS *params = mecha->pParameter;
+	CK_RSA_PKCS_OAEP_PARAMS *oaep_p = params->pOAEPParams;
+	CK_RV rv;
+	size_t params_size = 5 * sizeof(uint32_t) + params->pOAEPParams->ulSourceDataLen;
+
+	rv = serialize_32b(obj, obj->type);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params_size);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, params->ulAESKeyBits);
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, ck2sks_mechanism_type(oaep_p->hashAlg));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, ck2sks_rsa_pkcs_mgf_type(oaep_p->mgf));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj,
+			   ck2sks_rsa_pkcs_oaep_source_type(oaep_p->source));
+	if (rv)
+		return rv;
+
+	rv = serialize_32b(obj, oaep_p->ulSourceDataLen);
+	if (rv)
+		return rv;
+
+	return serialize_buffer(obj, oaep_p->pSourceData,
+				oaep_p->ulSourceDataLen);
+}
+
+/**
+ * serialize_ck_mecha_params - serialize a mechanism type & params
+ *
+ * @obj - serializer used to track the serialization
+ * @mechanism - pointer of the in structure aligned CK_MECHANISM.
+ *
+ * Serialized content:
+ *	[sks-mechanism-type][sks-mechanism-param-blob]
+ *
+ * [sks-mechanism-param-blob] depends on mechanism type ID, see
+ * serialize_mecha_XXX().
+ */
+CK_RV serialize_ck_mecha_params(struct serializer *obj,
+				CK_MECHANISM_PTR mechanism)
+{
+	CK_MECHANISM mecha;
+	CK_RV rv;
+
+	memset(obj, 0, sizeof(*obj));
+
+	obj->object = SKS_CKO_MECHANISM;
+
+	memcpy(&mecha, mechanism, sizeof(mecha));
+	obj->type = ck2sks_mechanism_type(mecha.mechanism);
+	if (obj->type == SKS_UNDEFINED_ID)
+		return CKR_MECHANISM_INVALID;
+
+	switch (mecha.mechanism) {
+	case CKM_GENERIC_SECRET_KEY_GEN:
+	case CKM_AES_KEY_GEN:
+	case CKM_AES_ECB:
+	case CKM_AES_CMAC:
+	case CKM_MD5_HMAC:
+	case CKM_SHA_1_HMAC:
+	case CKM_SHA224_HMAC:
+	case CKM_SHA256_HMAC:
+	case CKM_SHA384_HMAC:
+	case CKM_SHA512_HMAC:
+	case CKM_AES_XCBC_MAC:
+	case CKM_AES_XCBC_MAC_96:
+	case CKM_EC_KEY_PAIR_GEN:
+	case CKM_RSA_PKCS_KEY_PAIR_GEN:
+	case CKM_ECDSA:
+	case CKM_ECDSA_SHA1:
+	case CKM_ECDSA_SHA224:
+	case CKM_ECDSA_SHA256:
+	case CKM_ECDSA_SHA384:
+	case CKM_ECDSA_SHA512:
+	case CKM_RSA_PKCS:
+	case CKM_RSA_9796:
+	case CKM_RSA_X_509:
+	case CKM_SHA1_RSA_PKCS:
+	case CKM_SHA256_RSA_PKCS:
+	case CKM_SHA384_RSA_PKCS:
+	case CKM_SHA512_RSA_PKCS:
+	case CKM_SHA224_RSA_PKCS:
+	case CKM_DES_KEY_GEN:
+		/* No parameter expected, size shall be 0 */
+		if (mechanism->ulParameterLen)
+			return CKR_MECHANISM_PARAM_INVALID;
+
+		rv = serialize_32b(obj, obj->type);
+		if (rv)
+			return rv;
+
+		return serialize_32b(obj, 0);
+
+	case CKM_AES_CMAC_GENERAL:
+		return serialize_mecha_ulong_param(obj, &mecha);
+
+	case CKM_AES_CBC:
+	case CKM_AES_CBC_PAD:
+	case CKM_AES_CTS:
+		return serialize_mecha_aes_iv(obj, &mecha);
+
+	case CKM_AES_CTR:
+		return serialize_mecha_aes_ctr(obj, &mecha);
+	case CKM_AES_CCM:
+		return serialize_mecha_aes_ccm(obj, &mecha);
+	case CKM_AES_GCM:
+		return serialize_mecha_aes_gcm(obj, &mecha);
+
+	case CKM_ECDH1_DERIVE:
+	case CKM_ECDH1_COFACTOR_DERIVE:
+		return serialize_mecha_ecdh1_derive_param(obj, &mecha);
+
+	case CKM_ECDH_AES_KEY_WRAP:
+		return serialize_mecha_ecdh_aes_key_wrap_param(obj, &mecha);
+
+	case CKM_RSA_PKCS_OAEP:
+		return serialize_mecha_rsa_oaep_param(obj, &mecha);
+
+	case CKM_RSA_PKCS_PSS:
+	case CKM_SHA1_RSA_PKCS_PSS:
+	case CKM_SHA256_RSA_PKCS_PSS:
+	case CKM_SHA384_RSA_PKCS_PSS:
+	case CKM_SHA512_RSA_PKCS_PSS:
+	case CKM_SHA224_RSA_PKCS_PSS:
+		return serialize_mecha_rsa_pss_param(obj, &mecha);
+
+	case CKM_RSA_AES_KEY_WRAP:
+		return serialize_mecha_rsa_aes_key_wrap_param(obj, &mecha);
+
+	default:
+		return CKR_MECHANISM_INVALID;
+	}
+}
+
+/*
+ * Debug: dump CK attribute array to output trace
+ */
+
+static CK_RV trace_attributes(char *prefix, void *src, void *end)
+{
+	size_t next = 0;
+	char *prefix2;
+	size_t prefix_len = strlen(prefix);
+	char *cur = src;
+
+	/* append 4 spaces to the prefix */
+	prefix2 = malloc(prefix_len + 1 + 4) ;
+	memcpy(prefix2, prefix, prefix_len + 1);
+	memset(prefix2 + prefix_len, ' ', 4);
+	*(prefix2 + prefix_len + 1 + 4) = '\0';
+
+	for (; cur < (char *)end; cur += next) {
+		struct sks_attribute_head ref;
+
+		memcpy(&ref, cur, sizeof(ref));
+		next = sizeof(ref) + ref.size;
+
+		LOG_DEBUG("%s attr 0x%" PRIx32 " (%" PRIu32" byte) : %02x %02x %02x %02x ...\n",
+			prefix, ref.id, ref.size,
+			*((char *)cur + sizeof(ref) + 0),
+			*((char *)cur + sizeof(ref) + 1),
+			*((char *)cur + sizeof(ref) + 2),
+			*((char *)cur + sizeof(ref) + 3));
+
+		switch (ref.id) {
+		case SKS_CKA_WRAP_TEMPLATE:
+		case SKS_CKA_UNWRAP_TEMPLATE:
+			serial_trace_attributes_from_head(prefix2,
+							  cur + sizeof(ref));
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* sanity */
+	if (cur != (char *)end) {
+		LOG_ERROR("unexpected none alignement\n");
+	}
+
+	free(prefix2);
+	return CKR_OK;
+}
+
+CK_RV serial_trace_attributes_from_head(char *prefix, void *ref)
+{
+	struct sks_object_head head;
+	char *pre;
+	CK_RV rv;
+
+	memcpy(&head, ref, sizeof(head));
+
+	pre = calloc(1, prefix ? strlen(prefix) + 2 : 2) ;
+	if (!pre)
+		return CKR_HOST_MEMORY;
+	if (prefix)
+		memcpy(pre, prefix, strlen(prefix));
+
+	LOG_INFO("%s,--- (serial object) Attributes list --------\n", pre);
+	LOG_INFO("%s| %" PRIu32 " item(s) - %" PRIu32 " bytes\n", pre,
+		 head.attrs_count, head.attrs_size);
+
+	pre[prefix ? strlen(prefix) + 1 : 0] = '|';
+
+	rv = trace_attributes(pre, (char *)ref + sizeof(head),
+			      (char *)ref + sizeof(head) + head.attrs_size);
+	if (rv)
+		goto bail;
+
+	LOG_INFO("%s`-----------------------\n", prefix ? prefix : "");
+
+bail:
+	free(pre);
+	return rv;
+}
+
+CK_RV serial_trace_attributes(char *prefix, struct serializer *obj)
+{
+	return serial_trace_attributes_from_head(prefix, obj->buffer);
+}
diff --git a/libsks/src/serialize_ck.h b/libsks/src/serialize_ck.h
new file mode 100644
index 0000000..09c2b61
--- /dev/null
+++ b/libsks/src/serialize_ck.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __SERIALIZE_CK_H
+#define __SERIALIZE_CK_H
+
+#include <pkcs11.h>
+#include "serializer.h"
+
+/* Create (and allocate) a serial object for CK_ATTRIBUTE array */
+CK_RV serialize_ck_attributes(struct serializer *obj,
+				CK_ATTRIBUTE_PTR attributes, CK_ULONG count);
+
+/* Convert SKS attributes back to CK_ATTRIBUTE array */
+CK_RV deserialize_ck_attributes(uint8_t *in,
+				CK_ATTRIBUTE_PTR attributes, CK_ULONG count);
+
+/* Create (and allocate) a serial object for CK_MECHANISM array */
+CK_RV serialize_ck_mecha_params(struct serializer *obj,
+				CK_MECHANISM_PTR mechanisms);
+
+/* Log content of a serialized object */
+CK_RV serial_trace_attributes(char *prefix, struct serializer *obj);
+CK_RV serial_trace_attributes_from_head(char *prefix, void *ref);
+
+#endif /*__SERIALIZE_CK_H*/
diff --git a/libsks/src/serializer.c b/libsks/src/serializer.c
new file mode 100644
index 0000000..eeaefda
--- /dev/null
+++ b/libsks/src/serializer.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <sks_ta.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ck_helpers.h"
+#include "local_utils.h"
+#include "serializer.h"
+
+CK_RV init_serial_object(struct serializer *obj)
+{
+	struct sks_object_head head;
+
+	memset(obj, 0, sizeof(*obj));
+	obj->object = SKS_UNDEFINED_ID;
+	obj->type = SKS_UNDEFINED_ID;
+
+	/* Init head to all ones, will be set at finalize_serial_object */
+	memset(&head, 0xFF, sizeof(head));
+	return serialize_buffer(obj, &head, sizeof(head));
+}
+
+void finalize_serial_object(struct serializer *obj)
+{
+	struct sks_object_head head;
+
+	memset(&head, 0xFF, sizeof(head));
+
+#ifdef SKS_WITH_GENERIC_ATTRIBS_IN_HEAD
+fsdf fsd fsdf sdf
+	head.object = obj->object;
+	head.type = obj->type;
+#ifdef SKS_WITH_BOOLPROP_ATTRIBS_IN_HEAD
+	head.boolpropl = *((uint32_t *)obj->boolprop);
+	head.boolproph = *((uint32_t *)obj->boolprop + 1);
+#endif
+#endif
+	head.attrs_size = obj->size - sizeof(head);
+	head.attrs_count = obj->item_count;
+	memcpy(obj->buffer, &head, sizeof(head));
+}
+
+void release_serial_object(struct serializer *obj)
+{
+	free(obj->buffer);
+	obj->buffer = NULL;
+}
+
+/**
+ * serialize - append data in a serialized buffer
+ *
+ * Serialize data in provided buffer.
+ * Ensure 64byte alignement of appended data in the buffer.
+ */
+static CK_RV serialize(char **bstart, size_t *blen, void *data, size_t len)
+{
+	char *buf;
+	size_t nlen;
+
+	nlen = *blen + len;
+
+	buf = realloc(*bstart, nlen);
+	if (!buf)
+		return CKR_HOST_MEMORY;
+
+	memcpy(buf + *blen, data, len);
+
+	*blen = nlen;
+	*bstart = buf;
+
+	return CKR_OK;
+}
+
+CK_RV serialize_buffer(struct serializer *obj, void *data, size_t size)
+{
+	return serialize(&obj->buffer, &obj->size, data, size);
+}
+
+CK_RV serialize_32b(struct serializer *obj, uint32_t data)
+{
+	uint32_t data32 = data;
+
+	return serialize_buffer(obj, &data32, sizeof(uint32_t));
+}
+
+CK_RV serialize_ck_ulong(struct serializer *obj, CK_ULONG data)
+{
+	uint32_t data32 = data;
+
+	return serialize_buffer(obj, &data32, sizeof(data32));
+}
diff --git a/libsks/src/serializer.h b/libsks/src/serializer.h
new file mode 100644
index 0000000..2cdd7ce
--- /dev/null
+++ b/libsks/src/serializer.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __SERIALIZER_H
+#define __SERIALIZER_H
+
+#include <pkcs11.h>
+#include <sks_ta.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#define SKS_MAX_BOOLPROP_SHIFT	64
+#define SKS_MAX_BOOLPROP_ARRAY	(SKS_MAX_BOOLPROP_SHIFT / sizeof(uint32_t))
+
+/*
+ * Struct used to create the buffer storing the serialized data.
+ * Contains some fields to help parsing content (type/boolprops).
+ */
+struct serializer {
+	char *buffer;		/* serial buffer base address */
+	size_t size;		/* serial buffer current byte size */
+	size_t item_count;	/* number of items in entry table */
+	uint32_t object;
+	uint32_t type;
+	uint32_t boolprop[SKS_MAX_BOOLPROP_ARRAY];
+};
+
+size_t get_serial_object_size(struct serializer *obj);
+
+/* Init/finalize/release a serializer object */
+CK_RV init_serial_object(struct serializer *obj);
+void finalize_serial_object(struct serializer *obj);
+void release_serial_object(struct serializer *obj);
+
+CK_RV serialize_buffer(struct serializer *obj, void *data, size_t size);
+CK_RV serialize_32b(struct serializer *obj, uint32_t data);
+CK_RV serialize_ck_ulong(struct serializer *obj, CK_ULONG data);
+
+/*
+ * Tools on already serialized object: input referenc is the serial object
+ * head address.
+ */
+
+/* Return the size of the serial blob head or 0 on error */
+size_t sizeof_serial_head(void *ref);
+
+/* Return the size of a serial object (head + attributes size) */
+size_t get_serial_size(void *ref);
+
+/* Return the class of the object or the invalid ID if not found */
+uint32_t serial_get_class(void *ref);
+
+/* Return the type of the object or the invalid ID if not found */
+uint32_t serial_get_type(void *ref);
+
+/* Get the location of target the attribute data and size */
+CK_RV serial_get_attribute_ptr(void *ref, uint32_t attribute,
+			       void **attr, size_t *attr_size);
+
+/* Get target the attribute data content */
+CK_RV serial_get_attribute(void *ref, uint32_t attribute,
+			   void *attr, size_t *attr_size);
+
+/*
+ * Same serial_get_attributes() in case an attribute is defined several
+ * times in the object (i.e several string identifiers for a single object)
+ * TODO.
+ */
+CK_RV serial_get_attribute_multi(void *ref, uint32_t attribute,
+			   void *attr, size_t *attr_size);
+
+#endif /*__SERIALIZER_H*/
+
