diff --git a/core/arch/arm/plat-vexpress/conf.mk b/core/arch/arm/plat-vexpress/conf.mk
index e8a95601..2234e2d0 100644
--- a/core/arch/arm/plat-vexpress/conf.mk
+++ b/core/arch/arm/plat-vexpress/conf.mk
@@ -104,3 +104,8 @@ CFG_TEE_SDP_MEM_SIZE ?= 0x00400000
 $(call force,CFG_DT,y)
 CFG_DTB_MAX_SIZE ?= 0x100000
 endif
+
+# This hack embeds the SKS TA as an early TA which is handy for SKS tests
+ifeq ($(CFG_SECURE_KEY_SERVICES)-$(CFG_IN_TREE_EARLY_TAS),y-)
+CFG_IN_TREE_EARLY_TAS=secure_key_services/fd02c9da-306c-48c7-a49c-bbd827ae86ee
+endif
diff --git a/ta/secure_key_services/Android.mk b/ta/secure_key_services/Android.mk
new file mode 100644
index 00000000..19c60613
--- /dev/null
+++ b/ta/secure_key_services/Android.mk
@@ -0,0 +1,3 @@
+LOCAL_PATH := $(call my-dir)
+local_module := fd02c9da-306c-48c7-a49c-bbd827ae86ee.ta
+include $(BUILD_OPTEE_MK)
diff --git a/ta/secure_key_services/Makefile b/ta/secure_key_services/Makefile
new file mode 100644
index 00000000..8b9c0dc8
--- /dev/null
+++ b/ta/secure_key_services/Makefile
@@ -0,0 +1,18 @@
+# The UUID for the Trusted Application
+BINARY=fd02c9da-306c-48c7-a49c-bbd827ae86ee
+
+ifdef TA_CROSS_COMPILE
+CROSS_COMPILE ?= $(TA_CROSS_COMPILE)
+endif
+export CROSS_COMPILE
+
+CFG_TEE_TA_LOG_LEVEL ?= 2
+CPPFLAGS += -DCFG_TEE_TA_LOG_LEVEL=$(CFG_TEE_TA_LOG_LEVEL)
+
+-include $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk
+
+ifeq ($(wildcard $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk), )
+clean:
+	@echo 'Note: $$(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk not found, cannot clean TA'
+	@echo 'Note: TA_DEV_KIT_DIR=$(TA_DEV_KIT_DIR)'
+endif
diff --git a/ta/secure_key_services/include/sks_internal_abi.h b/ta/secure_key_services/include/sks_internal_abi.h
new file mode 100644
index 00000000..4a7ef30a
--- /dev/null
+++ b/ta/secure_key_services/include/sks_internal_abi.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __SKS_INTERNAL_ABI_H
+#define __SKS_INTERNAL_ABI_H
+
+/* Internal format is based on the API IDs */
+#include <sks_ta.h>
+#include <stddef.h>
+
+
+/**
+ * Serialization of object attributes
+ *
+ * An object is defined by the list of its attributes among which identifiers
+ * for the type of the object (symmetric key, asymmetric key, ...) and the
+ * object value (i.e the AES key value). In the end, an object is a list of
+ * attributes.
+ *
+ * SKS uses a serialized format for defining the attributes of an object. The
+ * attributes content starts with a header structure header followed by each
+ * attributes, stored in serialized fields:
+ * - the 32bit identificator of the attribute
+ * - the 32bit value attribute byte size
+ * - the effective value of the attribute (variable size)
+ */
+struct sks_ref {
+	uint32_t id;
+	uint32_t size;
+	uint8_t data[];
+};
+
+/*
+ * Header of a serialised memory object inside SKS TA.
+ *
+ * @attrs_size; byte size of the serialized data
+ * @attrs_count; number of items in the blob
+ * @class - object class id (from CK litterature): key, certif, etc...
+ * @type - object type id, per class, i.e aes or des3 in the key class.
+ * @boolpropl - 32bit bitmask storing boolean properties #0 to #31.
+ * @boolproph - 32bit bitmask storing boolean properties #32 to #64.
+ * @attrs - then starts the blob binary data
+ */
+struct sks_attrs_head {
+	uint32_t attrs_size;
+	uint32_t attrs_count;
+#ifdef SKS_SHEAD_WITH_TYPE
+	uint32_t class;
+	uint32_t type;
+#endif
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	uint32_t boolpropl;
+	uint32_t boolproph;
+#endif
+	uint8_t attrs[];
+};
+
+#endif /*__SKS_INTERNAL_ABI_H*/
diff --git a/ta/secure_key_services/include/sks_ta.h b/ta/secure_key_services/include/sks_ta.h
new file mode 100644
index 00000000..4bf0c3ad
--- /dev/null
+++ b/ta/secure_key_services/include/sks_ta.h
@@ -0,0 +1,1101 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#ifndef __SKS_TA_H__
+#define __SKS_TA_H__
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <util.h>
+
+#define TA_SKS_UUID { 0xfd02c9da, 0x306c, 0x48c7, \
+			{ 0xa4, 0x9c, 0xbb, 0xd8, 0x27, 0xae, 0x86, 0xee } }
+
+/* SKS trusted application version information */
+#define SKS_VERSION_ID0		0
+#define SKS_VERSION_ID1		0
+
+/* Special values for ulong variables */
+#define SKS_UNAVAILABLE_INFORMATION	UINT32_MAX
+#define SKS_EFFECTIVELY_INFINITE	0
+
+/*
+ * SKS_CMD_PING		Acknowledge TA presence and return TA version info
+ *
+ * Optinal invocation parameter:
+ *
+ * [out]        memref[2] = [
+ *                      32bit version0 value,
+ *                      32bit version1 value
+ *              ]
+ */
+#define SKS_CMD_PING			0x00000000
+
+/*
+ * SKS_CMD_CK_SLOT_LIST - Get the table of the valid slot IDs
+ *
+ * [out]        memref[2] = 32bit array slot_ids[slot counts]
+ *
+ * The TA instance may represent several PKCS#11 slots and associated tokens.
+ * This command relates the PKCS#11 API function C_GetSlotList and return the
+ * valid IDs recognized by the trusted application.
+ */
+#define SKS_CMD_CK_SLOT_LIST		0x00000001
+
+/*
+ * SKS_CMD_CK_SLOT_INFO - Get cryptoki structured slot information
+ *
+ * [in]		memref[0] = 32bit slot ID
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = (struct sks_ck_slot_info)info
+ *
+ * The TA instance may represent several PKCS#11 slots and associated tokens.
+ * This command relates the PKCS#11 API function C_GetSlotInfo and return the
+ * information about the target slot.
+ */
+#define SKS_CMD_CK_SLOT_INFO		0x00000002
+
+#define SKS_SLOT_DESC_SIZE		64
+#define SKS_SLOT_MANUFACTURER_SIZE	32
+#define SKS_SLOT_VERSION_SIZE		2
+
+struct sks_slot_info {
+	uint8_t slotDescription[SKS_SLOT_DESC_SIZE];
+	uint8_t manufacturerID[SKS_SLOT_MANUFACTURER_SIZE];
+	uint32_t flags;
+	uint8_t hardwareVersion[SKS_SLOT_VERSION_SIZE];
+	uint8_t firmwareVersion[SKS_SLOT_VERSION_SIZE];
+};
+
+/*
+ * Values for sks_token_info::flags.
+ * SKS_CKFS_<x> corresponds to cryptoki flag CKF_<x> related to slot flags.
+ */
+#define SKS_CKFS_TOKEN_PRESENT		(1U << 0)
+#define SKS_CKFS_REMOVABLE_DEVICE	(1U << 1)
+#define SKS_CKFS_HW_SLOT		(1U << 2)
+
+/*
+ * SKS_CMD_CK_TOKEN_INFO - Get cryptoki structured token information
+ *
+ * [in]		memref[0] = 32bit slot ID
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = (struct sks_ck_token_info)info
+ *
+ * The TA instance may represent several PKCS#11 slots and associated tokens.
+ * This command relates the PKCS#11 API function C_GetTokenInfo and return the
+ * information about the target represented token.
+ */
+#define SKS_CMD_CK_TOKEN_INFO		0x00000003
+
+#define SKS_TOKEN_LABEL_SIZE		32
+#define SKS_TOKEN_MANUFACTURER_SIZE	32
+#define SKS_TOKEN_MODEL_SIZE		16
+#define SKS_TOKEN_SERIALNUM_SIZE	16
+
+struct sks_token_info {
+	uint8_t label[SKS_TOKEN_LABEL_SIZE];
+	uint8_t manufacturerID[SKS_TOKEN_MANUFACTURER_SIZE];
+	uint8_t model[SKS_TOKEN_MODEL_SIZE];
+	uint8_t serialNumber[SKS_TOKEN_SERIALNUM_SIZE];
+	uint32_t flags;
+	uint32_t ulMaxSessionCount;
+	uint32_t ulSessionCount;
+	uint32_t ulMaxRwSessionCount;
+	uint32_t ulRwSessionCount;
+	uint32_t ulMaxPinLen;
+	uint32_t ulMinPinLen;
+	uint32_t ulTotalPublicMemory;
+	uint32_t ulFreePublicMemory;
+	uint32_t ulTotalPrivateMemory;
+	uint32_t ulFreePrivateMemory;
+	uint8_t hardwareVersion[2];
+	uint8_t firmwareVersion[2];
+	uint8_t utcTime[16];
+};
+
+/*
+ * Values for sks_token_info::flags.
+ * SKS_CKFT_<x> corresponds to cryptoki CKF_<x> related to token flags.
+ */
+#define SKS_CKFT_RNG					(1U << 0)
+#define SKS_CKFT_WRITE_PROTECTED			(1U << 1)
+#define SKS_CKFT_LOGIN_REQUIRED				(1U << 2)
+#define SKS_CKFT_USER_PIN_INITIALIZED			(1U << 3)
+#define SKS_CKFT_RESTORE_KEY_NOT_NEEDED			(1U << 4)
+#define SKS_CKFT_CLOCK_ON_TOKEN				(1U << 5)
+#define SKS_CKFT_PROTECTED_AUTHENTICATION_PATH		(1U << 6)
+#define SKS_CKFT_DUAL_CRYPTO_OPERATIONS			(1U << 7)
+#define SKS_CKFT_TOKEN_INITIALIZED			(1U << 8)
+#define SKS_CKFT_USER_PIN_COUNT_LOW			(1U << 9)
+#define SKS_CKFT_USER_PIN_FINAL_TRY			(1U << 10)
+#define SKS_CKFT_USER_PIN_LOCKED			(1U << 11)
+#define SKS_CKFT_USER_PIN_TO_BE_CHANGED			(1U << 12)
+#define SKS_CKFT_SO_PIN_COUNT_LOW			(1U << 13)
+#define SKS_CKFT_SO_PIN_FINAL_TRY			(1U << 14)
+#define SKS_CKFT_SO_PIN_LOCKED				(1U << 15)
+#define SKS_CKFT_SO_PIN_TO_BE_CHANGED			(1U << 16)
+#define SKS_CKFT_ERROR_STATE				(1U << 17)
+
+/*
+ * SKS_CMD_CK_MECHANISM_IDS - Get list of the supported mechanisms
+ *
+ * [in]		memref[0] = 32bit slot ID
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = 32bit array mechanism IDs
+ *
+ * This commands relates to the PKCS#11 API function C_GetMechanismList.
+ */
+#define SKS_CMD_CK_MECHANISM_IDS	0x00000004
+
+/*
+ * SKS_CMD_CK_MECHANISM_INFO - Get information on a specific mechanism
+ *
+ * [in]		memref[0] = [
+ *			32bit slot ID,
+ *			32bit mechanism ID
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = (struct sks_mecha_info)info
+ *
+ * This commands relates to the PKCS#11 API function C_GetMechanismInfo.
+ */
+#define SKS_CMD_CK_MECHANISM_INFO	0x00000005
+
+struct sks_mechanism_info {
+	uint32_t min_key_size;
+	uint32_t max_key_size;
+	uint32_t flags;
+};
+
+/*
+ * Values for sks_mechanism_info::flags.
+ * SKS_CKFM_<x> strictly matches cryptoki CKF_<x> related to mechanism flags.
+ */
+#define SKS_CKFM_HW			(1U << 0)
+#define SKS_CKFM_ENCRYPT		(1U << 8)
+#define SKS_CKFM_DECRYPT		(1U << 9)
+#define SKS_CKFM_DIGEST			(1U << 10)
+#define SKS_CKFM_SIGN			(1U << 11)
+#define SKS_CKFM_SIGN_RECOVER		(1U << 12)
+#define SKS_CKFM_VERIFY			(1U << 13)
+#define SKS_CKFM_VERIFY_RECOVER		(1U << 14)
+#define SKS_CKFM_GENERATE		(1U << 15)
+#define SKS_CKFM_GENERATE_PAIR		(1U << 16)
+#define SKS_CKFM_WRAP			(1U << 17)
+#define SKS_CKFM_UNWRAP			(1U << 18)
+#define SKS_CKFM_DERIVE			(1U << 19)
+#define SKS_CKFM_EC_F_P			(1U << 20)
+#define SKS_CKFM_EC_F_2M		(1U << 21)
+#define SKS_CKFM_EC_ECPARAMETERS	(1U << 22)
+#define SKS_CKFM_EC_NAMEDCURVE		(1U << 23)
+#define SKS_CKFM_EC_UNCOMPRESS		(1U << 24)
+#define SKS_CKFM_EC_COMPRESS		(1U << 25)
+
+/*
+ * SKS_CMD_CK_INIT_TOKEN - Initialize PKCS#11 token
+ *
+ * [in]		memref[0] = [
+ *			32bit slot ID,
+ *			32bit PIN length,
+ *			8bit array PIN[PIN length],
+ *			8bit array label[32]
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_InitToken().
+ */
+#define SKS_CMD_CK_INIT_TOKEN		0x00000006
+
+/*
+ * SKS_CMD_CK_INIT_PIN - Initialize PKCS#11 token PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit PIN length,
+ *			8bit array PIN[PIN length]
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_InitPIN().
+ */
+#define SKS_CMD_CK_INIT_PIN		0x00000007
+
+/*
+ * SKS_CMD_CK_SET_PIN - Set PKCS#11 token PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit old_pin_length,
+ *			8bit array old_pin[old_pin_length],
+ *			32bit new_pin_length,
+ *			8bit array new_pin[new_pin_length]
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_SetPIN()
+ */
+#define SKS_CMD_CK_SET_PIN		0x00000008
+
+/*
+ * SKS_CMD_CK_OPEN_RO_SESSION - Open read-only session
+ *
+ * [in]		memref[0] = 32bit slot ID
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[0] = 32bit session handle
+ *
+ * This commands relates to the PKCS#11 API function C_OpenSession() for a
+ * read-only session.
+ */
+#define SKS_CMD_CK_OPEN_RO_SESSION	0x00000009
+
+/*
+ * SKS_CMD_CK_OPEN_RW_SESSION - Open read/write session
+ *
+ * [in]		memref[0] = 32bit slot
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[0] = 32bit session handle
+ *
+ * This commands relates to the PKCS#11 API function C_OpenSession() for a
+ * read/Write session.
+ */
+#define SKS_CMD_CK_OPEN_RW_SESSION	0x0000000a
+
+/*
+ * SKS_CMD_CK_CLOSE_SESSION - Close an opened session
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_CloseSession().
+ */
+#define SKS_CMD_CK_CLOSE_SESSION	0x0000000b
+
+/*
+ * SKS_CMD_CK_SESSION_INFO - Get Cryptoki information on a session
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]        memref[2] = (struct sks_ck_session_info)info
+ *
+ * This commands relates to the PKCS#11 API function C_GetSessionInfo().
+ */
+#define SKS_CMD_CK_SESSION_INFO		0x0000000c
+
+/*
+ * Values for sks_session_info::state.
+ * SKS_CKSS_<x> strictly matches cryptoki CKS_<x> related to session state.
+ */
+#define SKS_CKSS_RO_PUBLIC_SESSION	0
+#define SKS_CKSS_RO_USER_FUNCTIONS	1
+#define SKS_CKSS_RW_PUBLIC_SESSION	2
+#define SKS_CKSS_RW_USER_FUNCTIONS	3
+#define SKS_CKSS_RW_SO_FUNCTIONS	4
+
+struct sks_session_info {
+	uint32_t slot_id;
+	uint32_t state;
+	uint32_t flags;
+	uint32_t error_code;
+};
+
+/*
+ * Values for sks_session_info::flags.
+ * SKS_CKFS_<x> strictly matches cryptoki CKF_<x> related to session flags.
+ */
+#define SKS_CKFS_RW_SESSION			(1U << 1)
+#define SKS_CKFS_SERIAL_SESSION		(1U << 2)
+
+/*
+ * SKS_CMD_CK_CLOSE_ALL_SESSIONS - Close all client sessions on slot/token
+ *
+ * [in]		memref[0] = 32bit slot
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_CloseAllSessions().
+ */
+#define SKS_CMD_CK_CLOSE_ALL_SESSIONS	0x0000000d
+
+/*
+ * SKS_CMD_IMPORT_OBJECT - Import a raw object in the session or token
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit object handle
+ *
+ * This commands relates to the PKCS#11 API function C_CreateObject().
+ */
+#define SKS_CMD_IMPORT_OBJECT		0x0000000e
+
+/**
+ * Serialization of object attributes
+ */
+
+/*
+ * sks_object_head - Header of object whose data are serialized in memory
+ *
+ * An object in made of several attributes. Attributes are store one next to
+ * the other with byte alignment as serialized byte arrays. Appended
+ * attributes byte arrays are prepend with this header structure that
+ * defines the number of attribute items and the overall byte size of the
+ * attrs byte array.
+ *
+ * @attrs_size - byte size of whole byte array attrs[]
+ * @attrs_count - number of attribute items stored in attrs[]
+ * @attrs - then starts the attributes data
+ */
+struct sks_object_head {
+	uint32_t attrs_size;
+	uint32_t attrs_count;
+	uint8_t attrs[];
+};
+
+/*
+ * Attribute reference in the TA ABI. Each attribute start with the header
+ * structure followed by the attribute value, its byte size being defined
+ * in the attribute header.
+ *
+ * @id - the 32bit identificator of the attribute, see SKS_CKA_<x>
+ * @size - the 32bit value attribute byte size
+ * @data - then starts the attribute value
+ */
+struct sks_attribute_head {
+	uint32_t id;
+	uint32_t size;
+	uint8_t data[];
+};
+
+/*
+ * SKS_CMD_DESTROY_OBJECT - Destroy an object
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit object handle
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This commands relates to the PKCS#11 API function C_DestroyObject().
+ */
+#define SKS_CMD_DESTROY_OBJECT		0x0000000f
+
+/*
+ * SKS_CMD_ENCRYPT_INIT - Initialize enryption processing
+ * SKS_CMD_DECRYPT_INIT - Initialize decryption processing
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * These commands relate to the PKCS#11 API functions C_EncryptInit() and
+ * C_DecryptInit.
+ */
+#define SKS_CMD_ENCRYPT_INIT		0x00000010
+#define SKS_CMD_DECRYPT_INIT		0x00000011
+
+/*
+ * SKS_CMD_ENCRYPT_UPDATE - Update encryption processing
+ * SKS_CMD_DECRYPT_UPDATE - Update decryption processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [in]		memref[1] = input data to be processed
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = output processed data
+ *
+ * These commands relate to the PKCS#11 API functions C_EncryptUpdate() and
+ * C_DecryptUpdate.
+ */
+#define SKS_CMD_ENCRYPT_UPDATE		0x00000012
+#define SKS_CMD_DECRYPT_UPDATE		0x00000013
+
+/*
+ * SKS_CMD_ENCRYPT_FINAL - Finalize encryption processing
+ * SKS_CMD_DECRYPT_FINAL - Finalize decryption processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = output processed data
+ *
+ * These commands relate to the PKCS#11 API functions C_EncryptFinal() and
+ * C_DecryptFinal.
+ */
+#define SKS_CMD_ENCRYPT_FINAL		0x00000014
+#define SKS_CMD_DECRYPT_FINAL		0x00000015
+
+/*
+ * SKS_CMD_GENERATE_SYMM_KEY - Generate a symmetric key
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit key handle
+ *
+ * This command relates to the PKCS#11 API functions C_GenerateKey().
+ */
+#define SKS_CMD_GENERATE_SYMM_KEY	0x00000016
+
+/*
+ * SKS_CMD_SIGN_INIT - Initialize a signature computation processing
+ * SKS_CMD_VERIFY_INIT - Initialize a signature verification processing
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit key handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters,
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * These commands relate to the PKCS#11 API functions C_SignInit() and
+ * C_VerifyInit.
+ */
+#define SKS_CMD_SIGN_INIT		0x00000017
+#define SKS_CMD_VERIFY_INIT		0x00000018
+
+/*
+ * SKS_CMD_SIGN_UPDATE - Update a signature computation processing
+ * SKS_CMD_VERIFY_UPDATE - Update a signature verification processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [in]		memref[1] = input data to be processed
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * These commands relate to the PKCS#11 API functions C_SignUpdate() and
+ * C_VerifyUpdate.
+ */
+#define SKS_CMD_SIGN_UPDATE		0x00000019
+#define SKS_CMD_VERIFY_UPDATE		0x0000001a
+
+/*
+ * SKS_CMD_SIGN_FINAL - Finalize a signature computation processing
+ * SKS_CMD_VERIFY_FINAL - Finalize a signature verification processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = output processed data
+ *
+ * These commands relate to the PKCS#11 API functions C_SignFinal() and
+ * C_VerifyFinal.
+ */
+#define SKS_CMD_SIGN_FINAL		0x0000001b
+#define SKS_CMD_VERIFY_FINAL		0x0000001c
+
+/*
+ * SKS_CMD_FIND_OBJECTS_INIT - Initialize a objects search
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This command relates to the PKCS#11 API function C_FindOjectsInit().
+ */
+#define SKS_CMD_FIND_OBJECTS_INIT	0x0000001d
+
+/*
+ * SKS_CMD_FIND_OBJECTS - Get handles of matching objects
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit array object_handle_array[N]
+ *
+ * This command relates to the PKCS#11 API function C_FindOjects().
+ * The size of object_handle_array depends output buffer size
+ * provided by the client.
+ */
+#define SKS_CMD_FIND_OBJECTS		0x0000001e
+
+/*
+ * SKS_CMD_FIND_OBJECTS_FINAL - Finalize current objects search
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * This command relates to the PKCS#11 API function C_FindOjectsFinal().
+ */
+#define SKS_CMD_FIND_OBJECTS_FINAL	0x0000001f
+
+/*
+ * SKS_CMD_GET_OBJECT_SIZE - Get size used by object in the TEE
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit key handle
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit object_byte_size
+ */
+#define SKS_CMD_GET_OBJECT_SIZE		0x00000020
+
+/*
+ * SKS_CMD_GET_ATTRIBUTE_VALUE - Get the value of object attribute(s)
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit object handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = (struct sks_object_head)attribs + attributes data
+ */
+#define SKS_CMD_GET_ATTRIBUTE_VALUE	0x00000021
+
+/*
+ * SKS_CMD_SET_ATTRIBUTE_VALUE - Set the value for object attribute(s)
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit object handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = (struct sks_object_head)attribs + attributes data
+ */
+#define SKS_CMD_SET_ATTRIBUTE_VALUE	0x00000022
+
+/*
+ * SKS_CMD_DERIVE_KEY - Derive a key from already provisioned parent key
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters,
+ *			32bit key handle,
+ *			(struct sks_object_head)attribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = 32bit object handle
+ */
+#define SKS_CMD_DERIVE_KEY		0x00000023
+
+/*
+ * SKS_CMD_INIT_PIN - Initialize user PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit PIN byte size,
+ *			byte arrays: PIN data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ */
+#define SKS_CMD_INIT_PIN		0x00000024
+
+/*
+ * SKS_CMD_SET_PIN - Change user PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit old PIN byte size,
+ *			byte arrays: PIN data
+ *			32bit new PIN byte size,
+ *			byte arrays: new PIN data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ */
+#define SKS_CMD_SET_PIN			0x00000025
+
+/*
+ * SKS_CMD_LOGIN - Initialize user PIN
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit user identifier,
+ *			32bit PIN byte size,
+ *			byte arrays: PIN data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ */
+#define SKS_CMD_LOGIN			0x00000026
+
+/*
+ * Values for user identifier parameter in SKS_CMD_LOGIN
+ */
+#define SKS_CKU_SO			0x000
+#define SKS_CKU_USER			0x001
+#define SKS_CKU_CONTEXT_SPECIFIC	0x002
+
+/*
+ * SKS_CMD_LOGOUT - Log out from token
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			32bit PIN byte size,
+ *			byte array: PIN data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ */
+#define SKS_CMD_LOGOUT			0x00000027
+
+/*
+ * SKS_CMD_GENERATE_KEY_PAIR - Generate an asymmetric key pair
+ *
+ * [in]		memref[0] = [
+ *			32bit session handle,
+ *			(struct sks_attribute_head)mechanism + mecha parameters,
+ *			(struct sks_object_head)pubkey_attribs + attributes data
+ *			(struct sks_object_head)privkeyattribs + attributes data
+ *		]
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = [
+ *			32bit public key handle,
+ *			32bit prive key handle
+ *		]
+ *
+ * This command relates to the PKCS#11 API functions C_GenerateKeyPair().
+ */
+#define SKS_CMD_GENERATE_KEY_PAIR	0x00000028
+
+/*
+ * SKS_CMD_ENCRYPT_ONESHOT - Update and finalize encryption processing
+ * SKS_CMD_DECRYPT_ONESHOT - Update and finalize decryption processing
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [in]		memref[1] = input data to be processed
+ * [out]	memref[0] = 32bit fine grain retrun code
+ * [out]	memref[2] = output processed data
+ *
+ * These commands relate to the PKCS#11 API functions C_EncryptUpdate() and
+ * C_DecryptUpdate.
+ */
+#define SKS_CMD_ENCRYPT_ONESHOT		0x00000029
+#define SKS_CMD_DECRYPT_ONESHOT		0x0000002a
+
+/*
+ * SKS_CMD_SIGN_ONESHOT - Update and finalize a signature computation
+ * SKS_CMD_VERIFY_ONESHOT - Update and finalize a signature verification
+ *
+ * [in]		memref[0] = 32bit session handle
+ * [in]		memref[1] = input data to be processed
+ * [out]	memref[0] = 32bit fine grain retrun code
+ *
+ * These commands relate to the PKCS#11 API functions C_SignUpdate() and
+ * C_VerifyUpdate.
+ */
+#define SKS_CMD_SIGN_ONESHOT		0x0000002b
+#define SKS_CMD_VERIFY_ONESHOT		0x0000002c
+
+/*
+ * Command return codes
+ * SKS_CKR_<x> relates cryptoki CKR_<x> in meaning if not in value.
+ */
+#define SKS_CKR_OK				0x00000000
+#define SKS_CKR_GENERAL_ERROR			0x00000001
+#define SKS_CKR_DEVICE_MEMORY			0x00000002
+#define SKS_CKR_ARGUMENTS_BAD			0x00000003
+#define SKS_CKR_BUFFER_TOO_SMALL		0x00000004
+#define SKS_CKR_FUNCTION_FAILED			0x00000005
+#define SKS_CKR_SIGNATURE_INVALID		0x00000007
+#define SKS_CKR_ATTRIBUTE_TYPE_INVALID		0x00000008
+#define SKS_CKR_ATTRIBUTE_VALUE_INVALID		0x00000009
+#define SKS_CKR_OBJECT_HANDLE_INVALID		0x0000000a
+#define SKS_CKR_KEY_HANDLE_INVALID		0x0000000b
+#define SKS_CKR_MECHANISM_INVALID		0x0000000c
+#define SKS_CKR_SESSION_HANDLE_INVALID		0x0000000d
+#define SKS_CKR_SLOT_ID_INVALID			0x0000000e
+#define SKS_CKR_MECHANISM_PARAM_INVALID		0x0000000f
+#define SKS_CKR_TEMPLATE_INCONSISTENT		0x00000010
+#define SKS_CKR_TEMPLATE_INCOMPLETE		0x00000011
+#define SKS_CKR_PIN_INCORRECT			0x00000012
+#define SKS_CKR_PIN_LOCKED			0x00000013
+#define SKS_CKR_PIN_EXPIRED			0x00000014
+#define SKS_CKR_PIN_INVALID			0x00000015
+#define SKS_CKR_PIN_LEN_RANGE			0x00000016
+#define SKS_CKR_SESSION_EXISTS			0x00000017
+#define SKS_CKR_SESSION_READ_ONLY		0x00000018
+#define SKS_CKR_SESSION_READ_WRITE_SO_EXISTS	0x00000019
+#define SKS_CKR_OPERATION_ACTIVE		0x0000001a
+#define SKS_CKR_KEY_FUNCTION_NOT_PERMITTED	0x0000001b
+#define SKS_CKR_OPERATION_NOT_INITIALIZED	0x0000001c
+#define SKS_CKR_TOKEN_WRITE_PROTECTED		0x0000001d
+#define SKS_CKR_TOKEN_NOT_PRESENT		0x0000001e
+#define SKS_CKR_TOKEN_NOT_RECOGNIZED		0x0000001f
+#define SKS_CKR_ACTION_PROHIBITED		0x00000020
+#define SKS_CKR_ATTRIBUTE_READ_ONLY		0x00000021
+#define SKS_CKR_PIN_TOO_WEAK			0x00000022
+#define SKS_CKR_CURVE_NOT_SUPPORTED		0x00000023
+#define SKS_CKR_DOMAIN_PARAMS_INVALID		0x00000024
+#define SKS_CKR_USER_ALREADY_LOGGED_IN		0x00000025
+#define SKS_CKR_USER_ANOTHER_ALREADY_LOGGED_IN	0x00000026
+#define SKS_CKR_USER_NOT_LOGGED_IN		0x00000027
+#define SKS_CKR_USER_PIN_NOT_INITIALIZED	0x00000028
+#define SKS_CKR_USER_TOO_MANY_TYPES		0x00000029
+#define SKS_CKR_USER_TYPE_INVALID		0x0000002a
+#define SKS_CKR_SESSION_READ_ONLY_EXISTS	0x0000002b
+#define SKS_CKR_KEY_SIZE_RANGE			0x0000002c
+#define SKS_CKR_ATTRIBUTE_SENSITIVE		0x0000002d
+#define SKS_CKR_SIGNATURE_LEN_RANGE		0x0000002e
+#define SKS_CKR_KEY_TYPE_INCONSISTENT		0x0000002f
+#define SKS_CKR_DATA_LEN_RANGE			0x00000030
+#define SKS_CKR_ENCRYPTED_DATA_LEN_RANGE	0x00000031
+
+/* Status without strict equivalence in Cryptoki API */
+#define SKS_NOT_FOUND				0x00001000
+#define SKS_NOT_IMPLEMENTED			0x00001001
+
+/* Attribute specific values */
+#define SKS_CK_UNAVAILABLE_INFORMATION		((uint32_t)0xFFFFFFFF)
+#define SKS_UNDEFINED_ID			SKS_CK_UNAVAILABLE_INFORMATION
+#define SKS_FALSE				0
+#define SKS_TRUE				1
+
+/*
+ * Attribute identificators
+ * Valid values for struct sks_attribute_head::id
+ *
+ * SKS_ATTR_<x> corresponds to cryptoki CKA_<x>.
+ * Value range [0 63] is reserved to boolean value attributes.
+ */
+#define SKS_BOOLPROPS_BASE			0x00000000
+#define SKS_CKA_TOKEN				0x00000000
+#define SKS_CKA_PRIVATE				0x00000001
+#define SKS_CKA_TRUSTED				0x00000002
+#define SKS_CKA_SENSITIVE			0x00000003
+#define SKS_CKA_ENCRYPT				0x00000004
+#define SKS_CKA_DECRYPT				0x00000005
+#define SKS_CKA_WRAP				0x00000006
+#define SKS_CKA_UNWRAP				0x00000007
+#define SKS_CKA_SIGN				0x00000008
+#define SKS_CKA_SIGN_RECOVER			0x00000009
+#define SKS_CKA_VERIFY				0x0000000a
+#define SKS_CKA_VERIFY_RECOVER			0x0000000b
+#define SKS_CKA_DERIVE				0x0000000c
+#define SKS_CKA_EXTRACTABLE			0x0000000d
+#define SKS_CKA_LOCAL				0x0000000e
+#define SKS_CKA_NEVER_EXTRACTABLE		0x0000000f
+#define SKS_CKA_ALWAYS_SENSITIVE		0x00000010
+#define SKS_CKA_MODIFIABLE			0x00000011
+#define SKS_CKA_COPYABLE			0x00000012
+#define SKS_CKA_DESTROYABLE			0x00000013
+#define SKS_CKA_ALWAYS_AUTHENTICATE		0x00000014
+#define SKS_CKA_WRAP_WITH_TRUSTED		0x00000015
+/* Last boolean properity ID (value is 63) is reserved */
+#define SKS_BOOLPROPS_LAST			SKS_CKA_WRAP_WITH_TRUSTED
+#define SKS_BOOLPROPS_END			0x0000003F
+#define SKS_BOOLPROPH_FLAG			BIT(31)
+
+#define SKS_CKA_LABEL				0x00000040
+#define SKS_CKA_VALUE				0x00000041
+#define SKS_CKA_VALUE_LEN			0x00000042
+#define SKS_CKA_WRAP_TEMPLATE			0x00000043
+#define SKS_CKA_UNWRAP_TEMPLATE			0x00000044
+#define SKS_CKA_DERIVE_TEMPLATE			0x00000045
+#define SKS_CKA_START_DATE			0x00000046
+#define SKS_CKA_END_DATE			0x00000047
+#define SKS_CKA_OBJECT_ID			0x00000048
+#define SKS_CKA_APPLICATION			0x00000049
+#define SKS_CKA_MECHANISM_TYPE			0x0000004a
+#define SKS_CKA_ID				0x0000004b
+#define SKS_CKA_ALLOWED_MECHANISMS		0x0000004c
+#define SKS_CKA_CLASS				0x0000004d
+#define SKS_CKA_KEY_TYPE			0x0000004e
+#define SKS_CKA_EC_POINT			0x0000004f
+#define SKS_CKA_EC_PARAMS			0x00000050
+#define SKS_CKA_MODULUS				0x00000051
+#define SKS_CKA_MODULUS_BITS			0x00000052
+#define SKS_CKA_PUBLIC_EXPONENT			0x00000053
+#define SKS_CKA_PRIVATE_EXPONENT		0x00000054
+#define SKS_CKA_PRIME_1				0x00000055
+#define SKS_CKA_PRIME_2				0x00000056
+#define SKS_CKA_EXPONENT_1			0x00000057
+#define SKS_CKA_EXPONENT_2			0x00000058
+#define SKS_CKA_COEFFICIENT			0x00000059
+#define SKS_CKA_SUBJECT				0x0000005a
+#define SKS_CKA_PUBLIC_KEY_INFO			0x0000005b
+#define SKS_CKA_CERTIFICATE_TYPE		0x0000005c
+#define SKS_CKA_CERTIFICATE_CATEGORY		0x0000005d
+#define SKS_CKA_ISSUER				0x0000005e
+#define SKS_CKA_SERIAL_NUMBER			0x0000005f
+#define SKS_CKA_URL				0x00000060
+#define SKS_CKA_HASH_OF_SUBJECT_PUBLIC_KEY	0x00000061
+#define SKS_CKA_HASH_OF_ISSUER_PUBLIC_KEY	0x00000062
+#define SKS_CKA_NAME_HASH_ALGORITHM		0x00000063
+#define SKS_CKA_KEY_GEN_MECHANISM		0x00000064
+
+/*
+ * Valid values for attribute SKS_CKA_CLASS
+ * SKS_CKO_<x> corresponds to cryptoki CKO_<x>.
+ */
+#define SKS_CKO_SECRET_KEY			0x000
+#define SKS_CKO_PUBLIC_KEY			0x001
+#define SKS_CKO_PRIVATE_KEY			0x002
+#define SKS_CKO_OTP_KEY				0x003
+#define SKS_CKO_CERTIFICATE			0x004
+#define SKS_CKO_DATA				0x005
+#define SKS_CKO_DOMAIN_PARAMETERS		0x006
+#define SKS_CKO_HW_FEATURE			0x007
+#define SKS_CKO_MECHANISM			0x008
+
+/*
+ * Valid values for attribute SKS_CKA_KEY_TYPE
+ * SKS_CKK_<x> corresponds to cryptoki CKK_<x> related to symmetric keys
+ */
+#define SKS_CKK_AES				0x000
+#define SKS_CKK_GENERIC_SECRET			0x001
+#define SKS_CKK_MD5_HMAC			0x002
+#define SKS_CKK_SHA_1_HMAC			0x003
+#define SKS_CKK_SHA224_HMAC			0x004
+#define SKS_CKK_SHA256_HMAC			0x005
+#define SKS_CKK_SHA384_HMAC			0x006
+#define SKS_CKK_SHA512_HMAC			0x007
+#define SKS_CKK_EC				0x008
+#define SKS_CKK_RSA				0x009
+#define SKS_CKK_DSA				0x00a
+#define SKS_CKK_DH				0x00b
+#define SKS_CKK_DES				0x00c
+#define SKS_CKK_DES2				0x00d
+#define SKS_CKK_DES3				0x00e
+
+/*
+ * Valid values for attribute SKS_CKA_CERTIFICATE_TYPE
+ * SKS_CKC_<x> corresponds to cryptoki CKC_<x>.
+ */
+#define SKS_CKC_X_509			0x000
+#define SKS_CKC_X_509_ATTR_CER		0x001
+#define SKS_CKC_WTLS			0x002
+
+/*
+ * Valid values for attribute SKS_CKA_MECHANISM_TYPE
+ * SKS_CKM_<x> corresponds to cryptoki CKM_<x>.
+ */
+#define SKS_CKM_AES_ECB				0x000
+#define SKS_CKM_AES_CBC				0x001
+#define SKS_CKM_AES_CBC_PAD			0x002
+#define SKS_CKM_AES_CTS				0x003
+#define SKS_CKM_AES_CTR				0x004
+#define SKS_CKM_AES_GCM				0x005
+#define SKS_CKM_AES_CCM				0x006
+#define SKS_CKM_AES_GMAC			0x007
+#define SKS_CKM_AES_CMAC			0x008
+#define SKS_CKM_AES_CMAC_GENERAL		0x009
+#define SKS_CKM_AES_ECB_ENCRYPT_DATA		0x00a
+#define SKS_CKM_AES_CBC_ENCRYPT_DATA		0x00b
+#define SKS_CKM_AES_KEY_GEN			0x00c
+#define SKS_CKM_GENERIC_SECRET_KEY_GEN		0x00d
+#define SKS_CKM_MD5_HMAC			0x00e
+#define SKS_CKM_SHA_1_HMAC			0x00f
+#define SKS_CKM_SHA224_HMAC			0x010
+#define SKS_CKM_SHA256_HMAC			0x011
+#define SKS_CKM_SHA384_HMAC			0x012
+#define SKS_CKM_SHA512_HMAC			0x013
+#define SKS_CKM_AES_XCBC_MAC			0x014
+#define SKS_CKM_EC_KEY_PAIR_GEN			0x015
+#define SKS_CKM_ECDSA				0x016
+#define SKS_CKM_ECDSA_SHA1			0x017
+#define SKS_CKM_ECDSA_SHA224			0x018	/* /!\ CK !PKCS#11 */
+#define SKS_CKM_ECDSA_SHA256			0x019	/* /!\ CK !PKCS#11 */
+#define SKS_CKM_ECDSA_SHA384			0x01a	/* /!\ CK !PKCS#11 */
+#define SKS_CKM_ECDSA_SHA512			0x01b	/* /!\ CK !PKCS#11 */
+#define SKS_CKM_ECDH1_DERIVE			0x01c
+#define SKS_CKM_ECDH1_COFACTOR_DERIVE		0x01d
+#define SKS_CKM_ECMQV_DERIVE			0x01e
+#define SKS_CKM_ECDH_AES_KEY_WRAP		0x01f
+#define SKS_CKM_RSA_PKCS_KEY_PAIR_GEN		0x020
+#define SKS_CKM_RSA_PKCS			0x021
+#define SKS_CKM_RSA_9796			0x022
+#define SKS_CKM_RSA_X_509			0x023
+#define SKS_CKM_SHA1_RSA_PKCS			0x024
+#define SKS_CKM_RSA_PKCS_OAEP			0x025
+#define SKS_CKM_SHA1_RSA_PKCS_PSS		0x026
+#define SKS_CKM_SHA256_RSA_PKCS			0x027
+#define SKS_CKM_SHA384_RSA_PKCS			0x028
+#define SKS_CKM_SHA512_RSA_PKCS			0x029
+#define SKS_CKM_SHA256_RSA_PKCS_PSS		0x02a
+#define SKS_CKM_SHA384_RSA_PKCS_PSS		0x02b
+#define SKS_CKM_SHA512_RSA_PKCS_PSS		0x02c
+#define SKS_CKM_SHA224_RSA_PKCS			0x02d
+#define SKS_CKM_SHA224_RSA_PKCS_PSS		0x02e
+#define SKS_CKM_RSA_AES_KEY_WRAP		0x02f
+#define SKS_CKM_RSA_PKCS_PSS			0x030
+#define SKS_CKM_MD5				0x031
+#define SKS_CKM_SHA_1				0x032
+#define SKS_CKM_SHA224				0x033
+#define SKS_CKM_SHA256				0x034
+#define SKS_CKM_SHA384				0x035
+#define SKS_CKM_SHA512				0x036
+#define SKS_CKM_DH_PKCS_DERIVE			0x037
+#define SKS_CKM_DES_KEY_GEN			0x038
+#define SKS_CKM_DES_ECB			0x039
+#define SKS_CKM_DES_CBC			0x040
+#define SKS_CKM_DES_MAC			0x041
+#define SKS_CKM_DES_MAC_GENERAL		0x042
+#define SKS_CKM_DES_CBC_PAD			0x043
+
+/* SKS added IDs for operation without cryptoki mechanism ID defined */
+#define SKS_PROCESSING_IMPORT			0x1000
+#define SKS_PROCESSING_COPY			0x1001
+
+/*
+ * Valid values key differentiation function identifiers
+ * SKS_CKD_<x> reltaes to cryptoki CKD_<x>.
+ */
+#define SKS_CKD_NULL				0x0000UL
+#define SKS_CKD_SHA1_KDF			0x0001UL
+#define SKS_CKD_SHA1_KDF_ASN1			0x0002UL
+#define SKS_CKD_SHA1_KDF_CONCATENATE		0x0003UL
+#define SKS_CKD_SHA224_KDF			0x0004UL
+#define SKS_CKD_SHA256_KDF			0x0005UL
+#define SKS_CKD_SHA384_KDF			0x0006UL
+#define SKS_CKD_SHA512_KDF			0x0007UL
+#define SKS_CKD_CPDIVERSIFY_KDF			0x0008UL
+
+/*
+ * Valid values MG function identifiers
+ * SKS_CKG_<x> reltaes to cryptoki CKG_<x>.
+ */
+#define SKS_CKG_MGF1_SHA1			0x0001UL
+#define SKS_CKG_MGF1_SHA224			0x0005UL
+#define SKS_CKG_MGF1_SHA256			0x0002UL
+#define SKS_CKG_MGF1_SHA384			0x0003UL
+#define SKS_CKG_MGF1_SHA512			0x0004UL
+
+/*
+ * Valid values for RSA PKCS/OAEP source type identifier
+ * SKS_CKZ_<x> reltaes to cryptoki CKZ_<x>.
+ */
+#define SKS_CKZ_DATA_SPECIFIED			0x0001UL
+
+/*
+ * Processing parameters
+ *
+ * These can hardly be described by ANSI-C structures since the byte size of
+ * some fields of the structure are specified by a previous field in the
+ * structure. Therefore the format of the parameter binary data for each
+ * supported processing is defined here from this comment rather than using
+ * C structures.
+ *
+ * Processing parameters are used as argument the C_EncryptInit and friends
+ * using the struct sks_attribute_head format where field 'type' is the SKS
+ * processing ID and field 'size' is the parameter byte size. Below is shown
+ * the head structure struct sks_attribute_head fields and the trailling data
+ * that are the effective parameters binary blob for the target
+ * processing/mechanism.
+ *
+ * AES ECB
+ *   head:	32bit: type = SKS_CKM_AES_ECB
+ *		32bit: params byte size = 0
+ *
+ * AES CBC, CBC_NOPAD and CTS
+ *   head:	32bit: type = SKS_CKM_AES_CBC
+ *			  or SKS_CKM_AES_CBC_PAD
+ *			  or SKS_CKM_AES_CTS
+ *		32bit: params byte size = 16
+ *  params:	16byte: IV
+ *
+ * AES CTR, params relates to struct CK_AES_CTR_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_CTR
+ *		32bit: params byte size = 20
+ *  params:	32bit: counter bit increment
+ *		16byte: IV
+ *
+ * AES GCM, params relates to struct CK_AES_GCM_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_GCM
+ *		32bit: params byte size
+ *  params:	32bit: IV_byte_size
+ *		byte array: IV (IV_byte_size bytes)
+ *		32bit: AAD_byte_size
+ *		byte array: AAD data (AAD_byte_size bytes)
+ *		32bit: tag bit size
+ *
+ * AES CCM, params relates to struct CK_AES_CCM_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_CCM
+ *		32bit: params byte size
+ *  params:	32bit: data_byte_size
+ *		32bit: nonce_byte_size
+ *		byte array: nonce data (nonce_byte_size bytes)
+ *		32bit: AAD_byte_size
+ *		byte array: AAD data (AAD_byte_size bytes)
+ *		32bit: MAC byte size
+ *
+ * AES GMAC
+ *   head:	32bit: type = SKS_CKM_AES_GMAC
+ *		32bit: params byte size = 12
+ *  params:	12byte: IV
+ *
+ * AES CMAC with general length, params relates to struct CK_MAC_GENERAL_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_CMAC_GENERAL
+ *		32bit: params byte size = 12
+ *  params:	32bit: byte size of the output CMAC data
+ *
+ * AES CMAC fixed size (16byte CMAC)
+ *   head:	32bit: type = SKS_CKM_AES_CMAC_GENERAL
+ *		32bit: size = 0
+ *
+ * AES derive by ECB, params relates to struct CK_KEY_DERIVATION_STRING_DATA.
+ *   head:	32bit: type = SKS_CKM_AES_ECB_ENCRYPT_DATA
+ *		32bit: params byte size
+ *  params:	32bit: byte size of the data to encrypt
+ *		byte array: data to encrypt
+ *
+ * AES derive by CBC, params relates to struct CK_AES_CBC_ENCRYPT_DATA_PARAMS.
+ *   head:	32bit: type = SKS_CKM_AES_CBC_ENCRYPT_DATA
+ *		32bit: params byte size
+ *  params:	16byte: IV
+ *		32bit: byte size of the data to encrypt
+ *		byte array: data to encrypt
+ *
+ * AES and generic secret generation
+ *   head:	32bit: type = SKS_CKM_AES_KEY_GEN
+ *			   or SKS_CKM_GENERIC_SECRET_KEY_GEN
+ *		32bit: size = 0
+ *
+ * ECDH, params relates to struct CK_ECDH1_DERIVE_PARAMS.
+ *   head:	32bit: type = SKS_CKM_ECDH1_DERIVE
+ *			   or SKS_CKM_ECDH1_COFACTOR_DERIVE
+ *		32bit: params byte size
+ *  params:	32bit: key derivation function (SKS_CKD_xxx)
+ *		32bit: byte size of the shared data
+ *		byte array: shared data
+ *		32bit: byte: size of the public data
+ *		byte array: public data
+ *
+ * AES key wrap by ECDH, params relates to struct CK_ECDH_AES_KEY_WRAP_PARAMS.
+ *   head:	32bit: type = SKS_CKM_ECDH_AES_KEY_WRAP
+ *		32bit: params byte size
+ *  params:	32bit: bit size of the AES key
+ *		32bit: key derivation function (SKS_CKD_xxx)
+ *		32bit: byte size of the shared data
+ *		byte array: shared data
+ *
+ * RSA_PKCS (pre-hashed payload)
+ *   head:	32bit: type = SKS_CKM_RSA_PKCS
+ *		32bit: size = 0
+ *
+ * RSA PKCS OAEP, params relates to struct CK_RSA_PKCS_OAEP_PARAMS.
+ *   head:	32bit: type = SKS_CKM_RSA_PKCS_OAEP
+ *		32bit: params byte size
+ *  params:	32bit: hash algorithm identifier (SKS_CK_M_xxx)
+ *		32bit: CK_RSA_PKCS_MGF_TYPE
+ *		32bit: CK_RSA_PKCS_OAEP_SOURCE_TYPE
+ *		32bit: byte size of the source data
+ *		byte array: source data
+ *
+ * RSA PKCS PSS, params relates to struct CK_RSA_PKCS_PSS_PARAMS.
+ *   head:	32bit: type = SKS_CKM_RSA_PKCS_PSS
+ *			   or SKS_CKM_SHA256_RSA_PKCS_PSS
+ *			   or SKS_CKM_SHA384_RSA_PKCS_PSS
+ *			   or SKS_CKM_SHA512_RSA_PKCS_PSS
+ *		32bit: params byte size
+ *  params:	32bit: hash algorithm identifier (SKS_CK_M_xxx)
+ *		32bit: CK_RSA_PKCS_MGF_TYPE
+ *		32bit: byte size of the salt in the PSS encoding
+ *
+ * AES key wrapping by RSA, params relates to struct CK_RSA_AES_KEY_WRAP_PARAMS.
+ *   head:	32bit: type = CKM_RSA_AES_KEY_WRAP
+ *		32bit: params byte size
+ *  params:	32bit: bit size of the AES key
+ *		32bit: hash algorithm identifier (SKS_CK_M_xxx)
+ *		32bit: CK_RSA_PKCS_MGF_TYPE
+ *		32bit: CK_RSA_PKCS_OAEP_SOURCE_TYPE
+ *		32bit: byte size of the source data
+ *		byte array: source data
+ */
+
+#endif /*__SKS_TA_H__*/
diff --git a/ta/secure_key_services/src/attributes.c b/ta/secure_key_services/src/attributes.c
new file mode 100644
index 00000000..1537fc71
--- /dev/null
+++ b/ta/secure_key_services/src/attributes.c
@@ -0,0 +1,606 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <compiler.h>
+#include <sks_internal_abi.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <string_ext.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include <trace.h>
+#include <util.h>
+
+#include "attributes.h"
+#include "sks_helpers.h"
+#include "serializer.h"
+
+uint32_t init_attributes_head(struct sks_attrs_head **head)
+{
+	*head = TEE_Malloc(sizeof(struct sks_attrs_head), TEE_MALLOC_FILL_ZERO);
+	if (!*head)
+		return SKS_MEMORY;
+
+#ifdef SKS_SHEAD_WITH_TYPE
+	(*head)->class = SKS_UNDEFINED_ID;
+	(*head)->type = SKS_UNDEFINED_ID;
+#endif
+
+	return SKS_OK;
+}
+
+#if defined(SKS_SHEAD_WITH_TYPE) || defined(SKS_SHEAD_WITH_BOOLPROPS)
+static bool attribute_is_in_head(uint32_t attribute)
+{
+#ifdef SKS_SHEAD_WITH_TYPE
+	if (attribute == SKS_CKA_CLASS || sks_attr_is_type(attribute))
+		return true;
+#endif
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	if (sks_attr2boolprop_shift(attribute) >= 0)
+		return true;
+#endif
+
+	return false;
+}
+#endif
+
+uint32_t add_attribute(struct sks_attrs_head **head,
+			uint32_t attribute, void *data, size_t size)
+{
+	size_t buf_len = sizeof(struct sks_attrs_head) + (*head)->attrs_size;
+	uint32_t rv = 0;
+	uint32_t data32 = 0;
+	char **bstart = (void *)head;
+	int __maybe_unused shift = 0;
+
+#ifdef SKS_SHEAD_WITH_TYPE
+	if (attribute == SKS_CKA_CLASS || sks_attr_is_type(attribute)) {
+		assert(size == sizeof(uint32_t));
+
+		TEE_MemMove(attribute == SKS_CKA_CLASS ?
+				&(*head)->class : &(*head)->type,
+				data, sizeof(uint32_t));
+
+		return SKS_OK;
+	}
+#endif
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	shift = sks_attr2boolprop_shift(attribute);
+	if (head_contains_boolprops(*head) && shift >= 0) {
+		uint32_t mask = shift < 32 ? BIT(shift) : BIT(shift - 32);
+		uint32_t val = *(uint8_t *)data ? mask : 0;
+
+		if (size != sizeof(uint8_t)) {
+			EMSG("Invalid size %zu", size);
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		}
+
+		if (shift < 32)
+			(*head)->boolpropl = ((*head)->boolpropl & ~mask) | val;
+		else
+			(*head)->boolproph = ((*head)->boolproph & ~mask) | val;
+
+		return SKS_OK;
+	}
+#endif
+
+	data32 = attribute;
+	rv = serialize(bstart, &buf_len, &data32, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	data32 = size;
+	rv = serialize(bstart, &buf_len, &data32, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialize(bstart, &buf_len, data, size);
+	if (rv)
+		return rv;
+
+	/* Alloced buffer is always 64byte align, safe for us */
+	head = (void *)bstart;
+	(*head)->attrs_size += 2 * sizeof(uint32_t) + size;
+	(*head)->attrs_count++;
+
+	return rv;
+}
+
+uint32_t remove_attribute(struct sks_attrs_head **head, uint32_t attribute)
+{
+	struct sks_attrs_head *h = *head;
+	char *cur = NULL;
+	char *end = NULL;
+	size_t next_off = 0;
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	/* Can't remove an attribute that is defined in the head */
+	if (head_contains_boolprops(*head) && attribute_is_in_head(attribute)) {
+		EMSG("Can't remove attribute from the head");
+		return SKS_FAILED;
+	}
+#endif
+
+	/* Let's find the target attribute */
+	cur = (char *)h + sizeof(struct sks_attrs_head);
+	end = cur + h->attrs_size;
+	for (; cur < end; cur += next_off) {
+		struct sks_ref sks_ref;
+
+		TEE_MemMove(&sks_ref, cur, sizeof(sks_ref));
+		next_off = sizeof(sks_ref) + sks_ref.size;
+
+		if (sks_ref.id != attribute)
+			continue;
+
+		TEE_MemMove(cur, cur + next_off, end - (cur + next_off));
+
+		h->attrs_count--;
+		h->attrs_size -= next_off;
+		end -= next_off;
+		next_off = 0;
+		return SKS_OK;
+	}
+
+	DMSG("SKS_VALUE not found");
+	return SKS_NOT_FOUND;
+}
+
+uint32_t remove_attribute_check(struct sks_attrs_head **head, uint32_t attribute,
+				size_t max_check)
+{
+	struct sks_attrs_head *h = *head;
+	char *cur = NULL;
+	char *end = NULL;
+	size_t next_off = 0;
+	size_t found = 0;
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	/* Can't remove an attribute that is defined in the head */
+	if (head_contains_boolprops(*head) && attribute_is_in_head(attribute)) {
+		EMSG("Can't remove attribute from the head");
+		TEE_Panic(0);
+	}
+#endif
+
+	/* Let's find the target attribute */
+	cur = (char *)h + sizeof(struct sks_attrs_head);
+	end = cur + h->attrs_size;
+	for (; cur < end; cur += next_off) {
+		struct sks_ref sks_ref;
+
+		TEE_MemMove(&sks_ref, cur, sizeof(sks_ref));
+		next_off = sizeof(sks_ref) + sks_ref.size;
+
+		if (sks_ref.id != attribute)
+			continue;
+
+		found++;
+		if (found > max_check) {
+			DMSG("Too many attribute occurences");
+			return SKS_FAILED;
+		}
+
+		TEE_MemMove(cur, cur + next_off, end - (cur + next_off));
+
+		h->attrs_count--;
+		h->attrs_size -= next_off;
+		end -= next_off;
+		next_off = 0;
+	}
+
+	/* sanity */
+	if (cur != end) {
+		EMSG("Bad end address");
+		return SKS_ERROR;
+	}
+
+	if (!found) {
+		EMSG("SKS_VALUE not found");
+		return SKS_FAILED;
+
+	}
+
+	return SKS_OK;
+}
+
+void get_attribute_ptrs(struct sks_attrs_head *head, uint32_t attribute,
+			void **attr, size_t *attr_size, size_t *count)
+{
+	char *cur = (char *)head + sizeof(struct sks_attrs_head);
+	char *end = cur + head->attrs_size;
+	size_t next_off = 0;
+	size_t max_found = *count;
+	size_t found = 0;
+	void **attr_ptr = attr;
+	size_t *attr_size_ptr = attr_size;
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	/* Can't return a pointer to a boolprop attribute */
+	if (head_contains_boolprops(head) && attribute_is_in_head(attribute)) {
+		EMSG("Can't get poitner to an attribute in the head");
+		TEE_Panic(0);
+	}
+#endif
+
+	for (; cur < end; cur += next_off) {
+		/* Structure aligned copy of the sks_ref in the object */
+		struct sks_ref sks_ref;
+
+		TEE_MemMove(&sks_ref, cur, sizeof(sks_ref));
+		next_off = sizeof(sks_ref) + sks_ref.size;
+
+		if (sks_ref.id != attribute)
+			continue;
+
+		found++;
+
+		if (!max_found)
+			continue;	/* only count matching attributes */
+
+		if (attr)
+			*attr_ptr++ = cur + sizeof(sks_ref);
+
+		if (attr_size)
+			*attr_size_ptr++ = sks_ref.size;
+
+		if (found == max_found)
+			break;
+	}
+
+	/* Sanity */
+	if (cur > end) {
+		DMSG("Exceeding serial object length");
+		TEE_Panic(0);
+	}
+
+	*count = found;
+}
+
+uint32_t get_attribute_ptr(struct sks_attrs_head *head, uint32_t attribute,
+			   void **attr_ptr, size_t *attr_size)
+{
+	size_t count = 1;
+
+#ifdef SKS_SHEAD_WITH_TYPE
+	if (attribute == SKS_CKA_CLASS) {
+		if (attr_size)
+			*attr_size = sizeof(uint32_t);
+		if (attr_ptr)
+			*attr_ptr = &head->class;
+
+		return SKS_OK;
+	}
+	if (attribute == SKS_CKA_KEY_TYPE) {
+		if (attr_size)
+			*attr_size = sizeof(uint32_t);
+		if (attr_ptr)
+			*attr_ptr = &head->type;
+
+		return SKS_OK;
+	}
+#endif
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	if (head_contains_boolprops(head) &&
+	    sks_attr2boolprop_shift(attribute) >= 0)
+		TEE_Panic(0);
+#endif
+
+	get_attribute_ptrs(head, attribute, attr_ptr, attr_size, &count);
+
+	if (!count)
+		return SKS_NOT_FOUND;
+
+	if (count != 1)
+		return SKS_ERROR;
+
+	return SKS_OK;
+}
+
+uint32_t get_attribute(struct sks_attrs_head *head, uint32_t attribute,
+			void *attr, size_t *attr_size)
+{
+	uint32_t rc = 0;
+	void *attr_ptr = NULL;
+	size_t size = 0;
+	uint8_t __maybe_unused bbool = 0;
+	int __maybe_unused shift = 0;
+
+#ifdef SKS_SHEAD_WITH_TYPE
+	if (attribute == SKS_CKA_CLASS) {
+		size = sizeof(uint32_t);
+		attr_ptr = &head->class;
+		goto found;
+	}
+
+	if (attribute == SKS_CKA_KEY_TYPE) {
+		size = sizeof(uint32_t);
+		attr_ptr = &head->type;
+		goto found;
+	}
+#endif
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	shift = sks_attr2boolprop_shift(attribute);
+	if (head_contains_boolprops(head) && shift >= 0) {
+		uint32_t *boolprop = NULL;
+
+		boolprop = (shift < 32) ? &head->boolpropl : &head->boolproph;
+		bbool = (*boolprop & (1 << (shift % 32))) ? SKS_TRUE : SKS_FALSE;
+
+		size = sizeof(uint8_t);
+		attr_ptr = &bbool;
+		goto found;
+	}
+#endif
+	rc = get_attribute_ptr(head, attribute, &attr_ptr, &size);
+	if (rc == SKS_OK)
+		goto found;
+
+	return rc;
+
+found:
+	if (attr_size && *attr_size != size) {
+		*attr_size = size;
+		/* This reuses buffer-to-small for any bad size matching */
+		return SKS_SHORT_BUFFER;
+	}
+
+	if (attr)
+		TEE_MemMove(attr, attr_ptr, size);
+
+	if (attr_size)
+		*attr_size = size;
+
+	return SKS_OK;
+}
+
+bool get_bool(struct sks_attrs_head *head, uint32_t attribute)
+{
+	uint32_t __maybe_unused rc = 0;
+	uint8_t bbool = 0;
+	size_t size = sizeof(bbool);
+	int __maybe_unused shift = 0;
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	shift = sks_attr2boolprop_shift(attribute);
+	if (shift < 0)
+		TEE_Panic(SKS_NOT_FOUND);
+
+	if (head_contains_boolprops(head)) {
+		if (shift > 31)
+			return head->boolproph & BIT(shift - 32);
+		else
+			return head->boolpropl & BIT(shift);
+	}
+#endif
+
+	rc = get_attribute(head, attribute, &bbool, &size);
+
+	if (rc == SKS_NOT_FOUND)
+		return false;
+
+	assert(rc == SKS_OK);
+	return !!bbool;
+}
+
+bool attributes_match_reference(struct sks_attrs_head *candidate,
+				struct sks_attrs_head *ref)
+{
+	size_t count = ref->attrs_count;
+	unsigned char *ref_attr = ref->attrs;
+	uint32_t rc = 0;
+
+	if (!ref->attrs_count) {
+		DMSG("Empty reference: no match");
+		return false;
+	}
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	/*
+	 * All boolprops attributes must ne explicitly defined
+	 * as an attribute reference in the reference object.
+	 */
+	assert(!head_contains_boolprops(ref));
+#endif
+
+	for (count = 0; count < ref->attrs_count; count++) {
+		struct sks_ref sks_ref;
+		void *found = NULL;
+		size_t size = 0;
+		int shift = 0;
+
+		TEE_MemMove(&sks_ref, ref_attr, sizeof(sks_ref));
+
+		shift = sks_attr2boolprop_shift(sks_ref.id);
+		if (shift >= 0) {
+			bool bb_ref = get_bool(ref, sks_ref.id);
+			bool bb_candidate = get_bool(candidate, sks_ref.id);
+
+			if (bb_ref != bb_candidate) {
+				return false;
+			}
+		} else {
+			rc = get_attribute_ptr(candidate, sks_ref.id,
+					       &found, &size);
+
+			if (rc || !found || size != sks_ref.size ||
+			    TEE_MemCompare(ref_attr + sizeof(sks_ref),
+					   found, size)) {
+				return false;
+			}
+		}
+
+		ref_attr += sizeof(sks_ref) + sks_ref.size;
+	}
+
+	return true;
+}
+
+/*
+ * Debug: dump CK attribute array to output trace
+ */
+#define ATTR_TRACE_FMT	"%s attr %s / %s\t(0x%04" PRIx32 " %" PRIu32 "-byte"
+#define ATTR_FMT_0BYTE	ATTR_TRACE_FMT ")"
+#define ATTR_FMT_1BYTE	ATTR_TRACE_FMT ": %02x)"
+#define ATTR_FMT_2BYTE	ATTR_TRACE_FMT ": %02x %02x)"
+#define ATTR_FMT_3BYTE	ATTR_TRACE_FMT ": %02x %02x %02x)"
+#define ATTR_FMT_4BYTE	ATTR_TRACE_FMT ": %02x %02x %02x %02x)"
+#define ATTR_FMT_ARRAY	ATTR_TRACE_FMT ": %02x %02x %02x %02x ...)"
+
+static uint32_t __trace_attributes(char *prefix, void *src, void *end)
+{
+	size_t next_off = 0;
+	char *prefix2 = NULL;
+	size_t prefix_len = strlen(prefix);
+	char *cur = src;
+
+	/* append 4 spaces to the prefix plus terminal '\0' */
+	prefix2 = TEE_Malloc(prefix_len + 1 + 4, TEE_MALLOC_FILL_ZERO);
+	if (!prefix2)
+		return SKS_MEMORY;
+
+	TEE_MemMove(prefix2, prefix, prefix_len + 1);
+	TEE_MemFill(prefix2 + prefix_len, ' ', 4);
+	*(prefix2 + prefix_len + 4) = '\0';
+
+	for (; cur < (char *)end; cur += next_off) {
+		struct sks_ref sks_ref;
+		uint8_t data[4] = { 0 };
+
+		TEE_MemMove(&sks_ref, cur, sizeof(sks_ref));
+		TEE_MemMove(&data[0], cur + sizeof(sks_ref),
+			    MIN(sks_ref.size, sizeof(data)));
+
+		next_off = sizeof(sks_ref) + sks_ref.size;
+
+		switch (sks_ref.size) {
+		case 0:
+			IMSG_RAW(ATTR_FMT_0BYTE,
+				 prefix, sks2str_attr(sks_ref.id), "*",
+				 sks_ref.id, sks_ref.size);
+			break;
+		case 1:
+			IMSG_RAW(ATTR_FMT_1BYTE,
+				 prefix, sks2str_attr(sks_ref.id),
+				 sks2str_attr_value(sks_ref.id, sks_ref.size,
+						    cur + sizeof(sks_ref)),
+				 sks_ref.id, sks_ref.size, data[0]);
+			break;
+		case 2:
+			IMSG_RAW(ATTR_FMT_2BYTE,
+				 prefix, sks2str_attr(sks_ref.id),
+				 sks2str_attr_value(sks_ref.id, sks_ref.size,
+						    cur + sizeof(sks_ref)),
+				 sks_ref.id, sks_ref.size, data[0], data[1]);
+			break;
+		case 3:
+			IMSG_RAW(ATTR_FMT_3BYTE,
+				 prefix, sks2str_attr(sks_ref.id),
+				 sks2str_attr_value(sks_ref.id, sks_ref.size,
+						    cur + sizeof(sks_ref)),
+				 sks_ref.id, sks_ref.size,
+				 data[0], data[1], data[2]);
+			break;
+		case 4:
+			IMSG_RAW(ATTR_FMT_4BYTE,
+				 prefix, sks2str_attr(sks_ref.id),
+				 sks2str_attr_value(sks_ref.id, sks_ref.size,
+						    cur + sizeof(sks_ref)),
+				 sks_ref.id, sks_ref.size,
+				 data[0], data[1], data[2], data[3]);
+			break;
+		default:
+			IMSG_RAW(ATTR_FMT_ARRAY,
+				 prefix, sks2str_attr(sks_ref.id),
+				 sks2str_attr_value(sks_ref.id, sks_ref.size,
+						    cur + sizeof(sks_ref)),
+				 sks_ref.id, sks_ref.size,
+				 data[0], data[1], data[2], data[3]);
+			break;
+		}
+
+		switch (sks_ref.id) {
+		case SKS_CKA_WRAP_TEMPLATE:
+		case SKS_CKA_UNWRAP_TEMPLATE:
+		case SKS_CKA_DERIVE_TEMPLATE:
+			trace_attributes(prefix2,
+					 (void *)(cur + sizeof(sks_ref)));
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* Sanity */
+	if (cur != (char *)end) {
+		EMSG("Warning: unexpect alignment in object attibutes");
+	}
+
+	TEE_Free(prefix2);
+	return SKS_OK;
+}
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+static void trace_boolprops(const char *prefix, struct sks_attrs_head *head)
+{
+	size_t __maybe_unused n = 0;
+
+	for (n = 0; n <= SKS_BOOLPROPS_LAST; n++) {
+		bool bp = n < 32 ? !!(head->boolpropl & BIT(n)) :
+				 !!(head->boolproph & BIT(n - 32));
+
+		IMSG_RAW("%s| attr %s / %s (0x%" PRIx32 ")",
+			 prefix, sks2str_attr(n), bp ? "TRUE" : "FALSE", n);
+	}
+}
+#endif
+
+uint32_t trace_attributes(const char *prefix, void *ref)
+{
+	struct sks_attrs_head head;
+	char *pre = NULL;
+	uint32_t rc = 0;
+	size_t __maybe_unused n = 0;
+
+	TEE_MemMove(&head, ref, sizeof(head));
+
+	pre = TEE_Malloc(prefix ? strlen(prefix) + 2 : 2, TEE_MALLOC_FILL_ZERO);
+	if (!pre)
+		return SKS_MEMORY;
+	if (prefix)
+		TEE_MemMove(pre, prefix, strlen(prefix));
+
+	IMSG_RAW("%s,--- (serial object) Attributes list --------", pre);
+	IMSG_RAW("%s| %" PRIu32 " item(s) - %" PRIu32 " bytes",
+		pre, head.attrs_count, head.attrs_size);
+#ifdef SKS_SHEAD_WITH_TYPE
+	IMSG_RAW("%s| class (0x%" PRIx32 ") %s type (0x%" PRIx32 ") %s",
+		 pre, head.class, sks2str_class(head.class),
+		 head.type, sks2str_type(head.type, head.class));
+#endif
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	if (head_contains_boolprops(&head))
+		trace_boolprops(pre, &head);
+#endif
+
+	pre[prefix ? strlen(prefix) : 0] = '|';
+	rc = __trace_attributes(pre, (char *)ref + sizeof(head),
+			        (char *)ref + sizeof(head) + head.attrs_size);
+	if (rc)
+		goto bail;
+
+	IMSG_RAW("%s`-----------------------", prefix ? prefix : "");
+
+bail:
+	TEE_Free(pre);
+	return rc;
+}
diff --git a/ta/secure_key_services/src/attributes.h b/ta/secure_key_services/src/attributes.h
new file mode 100644
index 00000000..f8e78583
--- /dev/null
+++ b/ta/secure_key_services/src/attributes.h
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __ATTRIBUTES_H
+#define __ATTRIBUTES_H
+
+#include <assert.h>
+#include <sks_internal_abi.h>
+#include <stdint.h>
+#include <stddef.h>
+
+#include "sks_helpers.h"
+
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+static inline void set_attributes_in_head(struct sks_attrs_head *head)
+{
+	head->boolproph |= SKS_BOOLPROPH_FLAG;
+}
+
+static inline bool head_contains_boolprops(struct sks_attrs_head __unused *head)
+{
+	return head->boolproph & SKS_BOOLPROPH_FLAG;
+}
+#endif
+
+/*
+ * Allocation a reference for a serialized attributes.
+ * Can be freed from a simple TEE_Free(reference);
+ *
+ * Return a SKS_OK on success or a SKS return code.
+ */
+uint32_t init_attributes_head(struct sks_attrs_head **head);
+
+/*
+ * Update serialized attributes to add an entry. Can relocate the attribute
+ * list buffer.
+ *
+ * Return a SKS_OK on success or a SKS return code.
+ */
+uint32_t add_attribute(struct sks_attrs_head **head,
+			uint32_t attribute, void *data, size_t size);
+
+/*
+ * Update serialized attributes to remove an entry. Can relocate the attribute
+ * list buffer. Only 1 instance of the entry is expected (TODO factory with _check)
+ *
+ * Return a SKS_OK on success or a SKS return code.
+ */
+uint32_t remove_attribute(struct sks_attrs_head **head, uint32_t attrib);
+
+/*
+ * Update serialized attributes to remove an entry. Can relocate the attribute
+ * list buffer. If attribute ID is find several times, remove all of them.
+ *
+ * Return a SKS_OK on success or a SKS return code.
+ */
+uint32_t remove_attribute_check(struct sks_attrs_head **head, uint32_t attribute,
+				size_t max_check);
+
+/*
+ * If *count == 0, count and return in *count the number of attributes matching
+ * the input attribute ID.
+ *
+ * If *count != 0, return the address and size of the attributes found, up to
+ * the occurence number *conut. attr and attri_size and expected large
+ * enougth. attr is the output array of the values found. attr_size is the
+ * output array of the size of each values found.
+ *
+ * If attr_size != NULL, return in in *attr_size attribute value size .
+ * If attr != NULL return in *attr the address in memory of the attribute value.
+ */
+void get_attribute_ptrs(struct sks_attrs_head *head, uint32_t attribute,
+			void **attr, size_t *attr_size, size_t *count);
+
+/*
+ * If attributes is not found return SKS_NOT_FOUND.
+ * If attr_size != NULL, return in in *attr_size attribute value size .
+ * If attr != NULL return in *attr the address in memory of the attribute value.
+ *
+ * Return a SKS_OK or SKS_NOT_FOUND on success, or a SKS return code.
+ */
+uint32_t get_attribute_ptr(struct sks_attrs_head *head, uint32_t attribute,
+			   void **attr_ptr, size_t *attr_size);
+/*
+ * If attributes is not found, rturn SKS_NOT_FOUND.
+ * If attr_size != NULL, check *attr_size matches attributes size of return
+ * SKS_SHORT_BUFFER with expected size in *attr_size.
+ * If attr != NULL and attr_size is NULL or gives expected buffer size,
+ * copy attribute value into attr.
+ *
+ * Return a SKS_OK or SKS_NOT_FOUND on success, or a SKS return code.
+ */
+uint32_t get_attribute(struct sks_attrs_head *head, uint32_t attribute,
+			void *attr, size_t *attr_size);
+
+static inline uint32_t get_u32_attribute(struct sks_attrs_head *head,
+					 uint32_t attribute, uint32_t *attr)
+{
+	size_t size = sizeof(uint32_t);
+	uint32_t rv = get_attribute(head, attribute, attr, &size);
+
+	if (size != sizeof(uint32_t))
+		return SKS_ERROR;
+
+	return rv;
+}
+
+/*
+ * Return true all attributes from the reference are found and match value
+ * in the candidate attribute list.
+ *
+ * Return a SKS_OK on success, or a SKS return code.
+ */
+bool attributes_match_reference(struct sks_attrs_head *ref,
+				struct sks_attrs_head *candidate);
+
+/*
+ * Some helpers
+ */
+static inline size_t attributes_size(struct sks_attrs_head *head)
+{
+	return sizeof(struct sks_attrs_head) + head->attrs_size;
+}
+
+#ifdef SKS_SHEAD_WITH_TYPE
+static inline uint32_t get_class(struct sks_attrs_head *head)
+{
+	return head->class;
+}
+
+static inline uint32_t get_type(struct sks_attrs_head *head)
+{
+	return head->type;
+}
+#else
+static inline uint32_t get_class(struct sks_attrs_head *head)
+{
+	uint32_t class;
+	size_t size = sizeof(class);
+
+	if (get_attribute(head, SKS_CKA_CLASS, &class, &size))
+		return SKS_UNDEFINED_ID;
+
+	return class;
+}
+static inline uint32_t get_type(struct sks_attrs_head *head)
+{
+	uint32_t type;
+	size_t size = sizeof(type);
+
+	if (get_attribute(head, SKS_CKA_KEY_TYPE, &type, &size))
+		return SKS_UNDEFINED_ID;
+
+	return type;
+}
+#endif
+
+bool get_bool(struct sks_attrs_head *head, uint32_t attribute);
+
+/* Debug: dump object attributes to IMSG() trace console */
+uint32_t trace_attributes(const char *prefix, void *ref);
+
+#endif /*__ATTRIBUTES_H*/
diff --git a/ta/secure_key_services/src/entry.c b/ta/secure_key_services/src/entry.c
new file mode 100644
index 00000000..4abc8cf6
--- /dev/null
+++ b/ta/secure_key_services/src/entry.c
@@ -0,0 +1,374 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <compiler.h>
+#include <sks_ta.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+#include "handle.h"
+#include "object.h"
+#include "pkcs11_token.h"
+#include "processing.h"
+#include "sks_helpers.h"
+
+/* Client session context: currently only use the alloced address */
+struct tee_session {
+	int foo;
+};
+
+
+TEE_Result TA_CreateEntryPoint(void)
+{
+	if (pkcs11_init())
+		return TEE_ERROR_SECURITY;
+
+	return TEE_SUCCESS;
+}
+
+void TA_DestroyEntryPoint(void)
+{
+	pkcs11_deinit();
+}
+
+TEE_Result TA_OpenSessionEntryPoint(uint32_t __unused param_types,
+				    TEE_Param __unused params[4],
+				    void **tee_session)
+{
+	uintptr_t client = register_client();
+
+	if (!client)
+		return TEE_ERROR_OUT_OF_MEMORY;
+
+	*tee_session = (void *)client;
+
+	return TEE_SUCCESS;
+}
+
+void TA_CloseSessionEntryPoint(void *tee_session)
+{
+	unregister_client((uintptr_t)tee_session);
+}
+
+static uint32_t entry_ping(TEE_Param *ctrl, TEE_Param *in, TEE_Param *out)
+{
+	uint32_t *ver = NULL;
+
+	if (ctrl || in)
+		return SKS_BAD_PARAM;
+
+	if (!out)
+		return SKS_OK;
+
+	if (out->memref.size < 2 * sizeof(uint32_t))
+		return SKS_SHORT_BUFFER;
+
+	if ((uintptr_t)out->memref.buffer & 0x03UL)
+		return SKS_BAD_PARAM;
+
+	ver = (uint32_t *)out->memref.buffer;
+	*ver = SKS_VERSION_ID0;
+	*(ver + 1) = SKS_VERSION_ID1;
+
+	return SKS_OK;
+}
+
+/*
+ * Entry point for SKS TA commands
+ *
+ * ABI: param#0 is the control buffer with serialazed arguments.
+ *	param#1 is an input/output data buffer
+ *	param#2 is an input/output data buffer (also used to return handles)
+ *	param#3 is not used
+ *
+ * Param#0 ctrl, if defined is an in/out buffer, is used to send back to
+ * the client a Cryptoki status ID that superseeds the TEE result code which
+ * will be force to TEE_SUCCESS. Note that some Cryptoki error status are
+ * sent straight through TEE result code. See sks2tee_noerr().
+ */
+TEE_Result TA_InvokeCommandEntryPoint(void *tee_session, uint32_t cmd,
+				      uint32_t ptypes,
+				      TEE_Param params[TEE_NUM_PARAMS])
+{
+	TEE_Param *ctrl = NULL;
+	TEE_Param *p1_in = NULL;
+	TEE_Param __maybe_unused *p1_out = NULL;
+	TEE_Param *p2_in = NULL;
+	TEE_Param *p2_out = NULL;
+	uintptr_t teesess = (uintptr_t)tee_session;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint32_t rc = 0;
+
+	/* param#0: input buffer with request serialazed arguments */
+	switch (TEE_PARAM_TYPE_GET(ptypes, 0)) {
+	case TEE_PARAM_TYPE_NONE:
+		break;
+	case TEE_PARAM_TYPE_MEMREF_INPUT:
+	case TEE_PARAM_TYPE_MEMREF_INOUT:
+		ctrl = &params[0];
+		break;
+	default:
+		goto bad_types;
+	}
+
+	/* param#1: input data buffer */
+	switch (TEE_PARAM_TYPE_GET(ptypes, 1)) {
+	case TEE_PARAM_TYPE_NONE:
+		break;
+	case TEE_PARAM_TYPE_MEMREF_INPUT:
+		p1_in = &params[1];
+		break;
+	case TEE_PARAM_TYPE_MEMREF_OUTPUT:
+		p1_out = &params[1];
+		break;
+	case TEE_PARAM_TYPE_MEMREF_INOUT:
+		p1_in = &params[1];
+		p1_out = &params[1];
+		break;
+	default:
+		goto bad_types;
+	}
+
+	/* param#2: input or output data buffer */
+	switch (TEE_PARAM_TYPE_GET(ptypes, 2)) {
+	case TEE_PARAM_TYPE_NONE:
+		break;
+	case TEE_PARAM_TYPE_MEMREF_INPUT:
+		p2_in = &params[2];
+		break;
+	case TEE_PARAM_TYPE_MEMREF_OUTPUT:
+		p2_out = &params[2];
+		break;
+	case TEE_PARAM_TYPE_MEMREF_INOUT:
+		p2_in = &params[2];
+		p2_out = &params[2];
+		break;
+	default:
+		goto bad_types;
+	}
+
+	/* param#3: unused */
+	switch (TEE_PARAM_TYPE_GET(ptypes, 3)) {
+	case TEE_PARAM_TYPE_NONE:
+		break;
+	default:
+		goto bad_types;
+	}
+
+	DMSG("%s ctrl %" PRIu32 "@%p, %s %" PRIu32 "@%p, %s %" PRIu32 "@%p",
+		sks2str_skscmd(cmd),
+		ctrl ? ctrl->memref.size : 0, ctrl ? ctrl->memref.buffer : 0,
+		p1_out ? "out" : (p1_in ? "in" : "---"),
+		p1_out ? p1_out->memref.size : (p1_in ? p1_in->memref.size : 0),
+		p1_out ? p1_out->memref.buffer :
+			(p1_in ? p1_in->memref.buffer : NULL),
+		p2_out ? "out" : (p2_in ? "in" : "---"),
+		p2_out ? p2_out->memref.size : (p2_in ? p2_in->memref.size : 0),
+		p2_out ? p2_out->memref.buffer :
+			(p2_in ? p2_in->memref.buffer : NULL));
+
+	switch (cmd) {
+	case SKS_CMD_PING:
+		rc = entry_ping(ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_CK_SLOT_LIST:
+		rc = entry_ck_slot_list(ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_CK_SLOT_INFO:
+		rc = entry_ck_slot_info(ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_CK_TOKEN_INFO:
+		rc = entry_ck_token_info(ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_CK_INIT_TOKEN:
+		rc = entry_ck_token_initialize(ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_CK_MECHANISM_IDS:
+		rc = entry_ck_token_mecha_ids(ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_CK_MECHANISM_INFO:
+		rc = entry_ck_token_mecha_info(ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_CK_OPEN_RO_SESSION:
+		rc = entry_ck_token_ro_session(teesess, ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_CK_OPEN_RW_SESSION:
+		rc = entry_ck_token_rw_session(teesess, ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_CK_CLOSE_SESSION:
+		rc = entry_ck_token_close_session(teesess, ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_CK_CLOSE_ALL_SESSIONS:
+		rc = entry_ck_token_close_all(teesess, ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_CK_SESSION_INFO:
+		rc = entry_ck_token_session_info(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_IMPORT_OBJECT:
+		rc = entry_import_object(teesess, ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_DESTROY_OBJECT:
+		rc = entry_destroy_object(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_ENCRYPT_INIT:
+		rc = entry_processing_init(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_ENCRYPT);
+		break;
+	case SKS_CMD_DECRYPT_INIT:
+		rc = entry_processing_init(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_DECRYPT);
+		break;
+	case SKS_CMD_ENCRYPT_UPDATE:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_ENCRYPT,
+					   SKS_FUNC_STEP_UPDATE);
+		break;
+	case SKS_CMD_DECRYPT_UPDATE:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_DECRYPT,
+					   SKS_FUNC_STEP_UPDATE);
+		break;
+	case SKS_CMD_ENCRYPT_ONESHOT:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_ENCRYPT,
+					   SKS_FUNC_STEP_ONESHOT);
+		break;
+	case SKS_CMD_DECRYPT_ONESHOT:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_DECRYPT,
+					   SKS_FUNC_STEP_ONESHOT);
+		break;
+	case SKS_CMD_ENCRYPT_FINAL:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_ENCRYPT,
+					   SKS_FUNC_STEP_FINAL);
+		break;
+	case SKS_CMD_DECRYPT_FINAL:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_DECRYPT,
+					   SKS_FUNC_STEP_FINAL);
+		break;
+
+	case SKS_CMD_GENERATE_SYMM_KEY:
+		rc = entry_generate_secret(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_SIGN_INIT:
+		rc = entry_processing_init(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_SIGN);
+		break;
+	case SKS_CMD_VERIFY_INIT:
+		rc = entry_processing_init(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_VERIFY);
+		break;
+	case SKS_CMD_SIGN_ONESHOT:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_SIGN,
+					   SKS_FUNC_STEP_ONESHOT);
+		break;
+	case SKS_CMD_VERIFY_ONESHOT:
+		rc = entry_verify_oneshot(teesess, ctrl, p1_in, p2_in,
+					   SKS_FUNCTION_VERIFY,
+					   SKS_FUNC_STEP_ONESHOT);
+		break;
+	case SKS_CMD_SIGN_UPDATE:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_SIGN,
+					   SKS_FUNC_STEP_UPDATE);
+		break;
+	case SKS_CMD_VERIFY_UPDATE:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_VERIFY,
+					   SKS_FUNC_STEP_UPDATE);
+		break;
+	case SKS_CMD_SIGN_FINAL:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_SIGN,
+					   SKS_FUNC_STEP_FINAL);
+		break;
+	case SKS_CMD_VERIFY_FINAL:
+		rc = entry_processing_step(teesess, ctrl, p1_in, p2_out,
+					   SKS_FUNCTION_VERIFY,
+					   SKS_FUNC_STEP_FINAL);
+		break;
+
+	case SKS_CMD_FIND_OBJECTS_INIT:
+		rc = entry_find_objects_init(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_FIND_OBJECTS:
+		rc = entry_find_objects(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_FIND_OBJECTS_FINAL:
+		rc = entry_find_objects_final(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_GET_OBJECT_SIZE:
+		rc = entry_get_object_size(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_GET_ATTRIBUTE_VALUE:
+		rc = entry_get_attribute_value(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_INIT_PIN:
+		rc = entry_init_pin(teesess, ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_SET_PIN:
+		rc = entry_set_pin(teesess, ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_LOGIN:
+		rc = entry_login(teesess, ctrl, p1_in, p2_out);
+		break;
+	case SKS_CMD_LOGOUT:
+		rc = entry_logout(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_GENERATE_KEY_PAIR:
+		rc = entry_generate_key_pair(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	case SKS_CMD_DERIVE_KEY:
+		rc = entry_derive_key(teesess, ctrl, p1_in, p2_out);
+		break;
+
+	default:
+		EMSG("Command ID 0x%x is not supported", cmd);
+		return TEE_ERROR_NOT_SUPPORTED;
+	}
+
+	if (TEE_PARAM_TYPE_GET(ptypes, 0) == TEE_PARAM_TYPE_MEMREF_INOUT &&
+	    ctrl->memref.size >= sizeof(uint32_t) &&
+	    !((uintptr_t)ctrl->memref.buffer & 0x03UL)) {
+
+		TEE_MemMove(ctrl->memref.buffer, &rc, sizeof(uint32_t));
+		ctrl->memref.size = sizeof(uint32_t);
+
+		res = sks2tee_noerr(rc);
+
+		DMSG("SKS TA exit: %s rc 0x%08" PRIx32 "/%s",
+			sks2str_skscmd(cmd), rc, sks2str_rc(rc));
+	} else {
+		res = sks2tee_error(rc);
+		DMSG("SKS TA exit: %s rc 0x%08" PRIx32 "/%s, TEE rc %" PRIx32,
+			sks2str_skscmd(cmd), rc, sks2str_rc(rc), res);
+	}
+
+	return res;
+
+bad_types:
+	DMSG("Bad parameter types used at SKS TA entry:");
+	DMSG("- parameter #0: formated input request buffer or none");
+	DMSG("- parameter #1: processed input data buffer or none");
+	DMSG("- parameter #2: processed output data buffer or none");
+	DMSG("- parameter #3: none");
+	return TEE_ERROR_BAD_PARAMETERS;
+}
diff --git a/ta/secure_key_services/src/handle.c b/ta/secure_key_services/src/handle.c
new file mode 100644
index 00000000..ebc8b7bc
--- /dev/null
+++ b/ta/secure_key_services/src/handle.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2014-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <stdlib.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+#include "handle.h"
+
+/*
+ * Define the initial capacity of the database. It should be a low number
+ * multiple of 2 since some databases a likely to only use a few handles.
+ * Since the algorithm is to doubles up when growing it shouldn't cause a
+ * noticeable overhead on large databases.
+ */
+#define HANDLE_DB_INITIAL_MAX_PTRS	4
+
+void handle_db_init(struct handle_db *db)
+{
+	TEE_MemFill(db, 0, sizeof(*db));
+}
+
+void handle_db_destroy(struct handle_db *db)
+{
+	if (db) {
+		TEE_Free(db->ptrs);
+		db->ptrs = NULL;
+		db->max_ptrs = 0;
+	}
+}
+
+uint32_t handle_get(struct handle_db *db, void *ptr)
+{
+	uint32_t n = 0;
+	void *p = NULL;
+	uint32_t new_max_ptrs = 0;
+
+	if (!db || !ptr)
+		return 0;
+
+	/* Try to find an empty location (index 0 is reserved as invalid) */
+	for (n = 1; n < db->max_ptrs; n++) {
+		if (!db->ptrs[n]) {
+			db->ptrs[n] = ptr;
+			return n;
+		}
+	}
+
+	/* No location available, grow the ptrs array */
+	if (db->max_ptrs)
+		new_max_ptrs = db->max_ptrs * 2;
+	else
+		new_max_ptrs = HANDLE_DB_INITIAL_MAX_PTRS;
+
+	p = TEE_Realloc(db->ptrs, new_max_ptrs * sizeof(void *));
+	if (!p)
+		return 0;
+	db->ptrs = p;
+	TEE_MemFill(db->ptrs + db->max_ptrs, 0,
+		    (new_max_ptrs - db->max_ptrs) * sizeof(void *));
+	db->max_ptrs = new_max_ptrs;
+
+	/* Since n stopped at db->max_ptrs there is an empty location there */
+	db->ptrs[n] = ptr;
+	return n;
+}
+
+void *handle_put(struct handle_db *db, uint32_t handle)
+{
+	void *p = NULL;
+
+	if (!db || !handle || handle >= db->max_ptrs)
+		return NULL;
+
+	p = db->ptrs[handle];
+	db->ptrs[handle] = NULL;
+	return p;
+}
+
+void *handle_lookup(struct handle_db *db, uint32_t handle)
+{
+	if (!db || !handle || handle >= db->max_ptrs)
+		return NULL;
+
+	return db->ptrs[handle];
+}
+
+uint32_t handle_lookup_handle(struct handle_db *db, void *ptr)
+{
+	uint32_t n = 0;
+
+	if (ptr) {
+		for (n = 1; n < db->max_ptrs; n++) {
+			if (db->ptrs[n] == ptr) {
+				return n;
+			}
+		}
+	}
+
+	return 0;
+}
diff --git a/ta/secure_key_services/src/handle.h b/ta/secure_key_services/src/handle.h
new file mode 100644
index 00000000..1c60e00f
--- /dev/null
+++ b/ta/secure_key_services/src/handle.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2014-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __HANDLE_H
+#define __HANDLE_H
+
+#include <stddef.h>
+
+struct handle_db {
+	void **ptrs;
+	uint32_t max_ptrs;
+};
+
+#define HANDLE_DB_INITIALIZER { NULL, 0 }
+
+/*
+ * Initialize the handle database
+ */
+void handle_db_init(struct handle_db *db);
+
+/*
+ * Free all internal data structures of the database, but does not free
+ * the db pointer. The database is safe to reuse after it's destroyed, it
+ * just be empty again.
+ */
+void handle_db_destroy(struct handle_db *db);
+
+/*
+ * Allocate a new handle and assigns the supplied pointer to it,
+ * ptr must not be NULL.
+ * The function returns
+ * >= 0 on success and
+ * -1 on failure
+ */
+uint32_t handle_get(struct handle_db *db, void *ptr);
+
+/*
+ * Deallocate a handle. Returns the assiciated pointer of the handle
+ * the the handle was valid or NULL if it's invalid.
+ */
+void *handle_put(struct handle_db *db, uint32_t handle);
+
+/*
+ * Return the associated pointer of the handle if the handle is a valid
+ * handle.
+ * Returns NULL on failure.
+ */
+void *handle_lookup(struct handle_db *db, uint32_t handle);
+
+/* Return the handle associated to a pointer if found, else return 0 */
+uint32_t handle_lookup_handle(struct handle_db *db, void *ptr);
+
+#endif /*__HANDLE_H*/
+
diff --git a/ta/secure_key_services/src/object.c b/ta/secure_key_services/src/object.c
new file mode 100644
index 00000000..f5f34660
--- /dev/null
+++ b/ta/secure_key_services/src/object.c
@@ -0,0 +1,834 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <inttypes.h>
+#include <sks_internal_abi.h>
+#include <string_ext.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+#include "attributes.h"
+#include "handle.h"
+#include "object.h"
+#include "pkcs11_attributes.h"
+#include "pkcs11_token.h"
+#include "processing.h"
+#include "sanitize_object.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+struct sks_object *sks_handle2object(uint32_t handle,
+				     struct pkcs11_session *session)
+{
+	return handle_lookup(&session->object_handle_db, handle);
+}
+
+uint32_t sks_object2handle(struct sks_object *obj,
+			   struct pkcs11_session *session)
+{
+	return handle_lookup_handle(&session->object_handle_db, obj);
+}
+
+/* Currently handle pkcs11 sessions and tokens */
+
+static struct object_list *get_session_objects(void *session)
+{
+	/* Currently supporting only pkcs11 session */
+	struct pkcs11_session *ck_session = session;
+
+	return pkcs11_get_session_objects(ck_session);
+}
+
+static struct ck_token *get_session_token(void *session)
+{
+	/* Currently supporting only pkcs11 session */
+	struct pkcs11_session *ck_session = session;
+
+	return pkcs11_session2token(ck_session);
+}
+
+/* Release resources of a non persistent object */
+static void cleanup_volatile_obj_ref(struct sks_object *obj)
+{
+	if (!obj)
+		return;
+
+	if (obj->key_handle != TEE_HANDLE_NULL)
+		TEE_FreeTransientObject(obj->key_handle);
+
+	if (obj->attribs_hdl != TEE_HANDLE_NULL) {
+		TEE_CloseObject(obj->attribs_hdl);
+	}
+
+	TEE_Free(obj->attributes);
+	TEE_Free(obj->uuid);
+	TEE_Free(obj);
+}
+
+
+/* Release resources of a persistent object including volatile resources */
+void cleanup_persistent_object(struct sks_object *obj,
+				      struct ck_token *token)
+{
+	TEE_Result res;
+
+	if (!obj)
+		return;
+
+	/* Open handle with write properties to destroy the object */
+	if (obj->attribs_hdl != TEE_HANDLE_NULL) {
+		TEE_CloseObject(obj->attribs_hdl);
+	}
+
+	res = TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE,
+					obj->uuid, sizeof(TEE_UUID),
+					TEE_DATA_FLAG_ACCESS_WRITE_META,
+					&obj->attribs_hdl);
+	assert(!res);
+	if (res)
+		goto out;
+
+	TEE_CloseAndDeletePersistentObject1(obj->attribs_hdl);
+
+out:
+	obj->attribs_hdl = TEE_HANDLE_NULL;
+	destroy_object_uuid(token, obj);
+
+	LIST_REMOVE(obj, link);
+
+	cleanup_volatile_obj_ref(obj);
+}
+
+/*
+ * destroy_object - destroy an SKS object
+ *
+ * @session - session requesting object destruction
+ * @object - reference to the sks object
+ * @session_object_only - true is only session object shall be destroyed
+ */
+void destroy_object(struct pkcs11_session *session,
+			  struct sks_object *obj,
+			  bool session_only)
+{
+#ifdef DEBUG
+	trace_attributes("[destroy]", obj->attributes);
+	if (obj->uuid)
+		MSG_RAW("[destroy] obj uuid %pUl", (void *)obj->uuid);
+#endif
+
+	/* Remove from session list only if was published */
+	if (obj->link.le_next || obj->link.le_prev)
+		LIST_REMOVE(obj, link);
+
+	if (session_only) {
+		/* Destroy object due to session closure */
+		handle_put(&session->object_handle_db,
+			   sks_object2handle(obj, session));
+		cleanup_volatile_obj_ref(obj);
+
+		return;
+	}
+
+	/* Destroy target object (persistent or not) */
+	if (get_bool(obj->attributes, SKS_CKA_TOKEN)) {
+		assert(obj->uuid);
+		/* Try twice otherwise panic! */
+		if (unregister_persistent_object(session->token, obj->uuid) &&
+		    unregister_persistent_object(session->token, obj->uuid))
+			TEE_Panic(0);
+
+		cleanup_persistent_object(obj, session->token);
+		handle_put(&session->object_handle_db,
+			   sks_object2handle(obj, session));
+	} else {
+		handle_put(&session->object_handle_db,
+			   sks_object2handle(obj, session));
+		cleanup_volatile_obj_ref(obj);
+	}
+}
+
+static struct sks_object *create_object_instance(struct sks_attrs_head *head)
+{
+	struct sks_object *obj = NULL;
+
+	obj = TEE_Malloc(sizeof(struct sks_object), TEE_MALLOC_FILL_ZERO);
+	if (!obj)
+		return NULL;
+
+	obj->key_handle = TEE_HANDLE_NULL;
+	obj->attribs_hdl = TEE_HANDLE_NULL;
+	obj->attributes = head;
+
+	return obj;
+}
+
+struct sks_object *create_token_object_instance(struct sks_attrs_head *head,
+						TEE_UUID *uuid)
+{
+	struct sks_object *obj = create_object_instance(head);
+
+	if (!obj)
+		return NULL;
+
+	obj->uuid = uuid;
+
+	return obj;
+}
+
+/*
+ * create_object - create an SKS object from its attributes and value
+ *
+ * @session - session requesting object creation
+ * @attributes - reference to serialized attributes
+ * @handle - generated handle for the created object
+ */
+uint32_t create_object(void *sess, struct sks_attrs_head *head,
+		       uint32_t *out_handle)
+{
+	uint32_t rv = 0;
+	TEE_Result res = TEE_SUCCESS;
+	struct sks_object *obj = NULL;
+	struct pkcs11_session *session = (struct pkcs11_session *)sess;
+	uint32_t obj_handle = 0;
+
+#ifdef DEBUG
+	trace_attributes("[create]", head);
+#endif
+
+	/*
+	 * We do not check the key attributes. At this point, key attributes
+	 * are expected consistent and reliable.
+	 */
+
+	obj = create_object_instance(head);
+	if (!obj)
+		return SKS_MEMORY;
+
+	/* Create a handle for the object in the session database */
+	obj_handle = handle_get(&session->object_handle_db, obj);
+	if (!obj_handle) {
+		rv = SKS_MEMORY;
+		goto bail;
+	}
+
+	if (get_bool(obj->attributes, SKS_CKA_TOKEN)) {
+		/*
+		 * Get an ID for the persistent object
+		 * Create the file
+		 * Register the object in the persistent database
+		 * (move the full sequence to persisent_db.c?)
+		 */
+		size_t size = attributes_size(obj->attributes);
+
+		rv = create_object_uuid(get_session_token(session), obj);
+		if (rv)
+			goto bail;
+
+		res = TEE_CreatePersistentObject(TEE_STORAGE_PRIVATE,
+						 obj->uuid, sizeof(TEE_UUID),
+						 TEE_DATA_FLAG_ACCESS_READ |
+						 TEE_DATA_FLAG_ACCESS_WRITE |
+						 TEE_DATA_FLAG_ACCESS_WRITE_META,
+						 TEE_HANDLE_NULL,
+						 obj->attributes, size,
+						 &obj->attribs_hdl);
+		if (res) {
+			rv = tee2sks_error(res);
+			goto bail;
+		}
+
+		rv = register_persistent_object(get_session_token(session),
+						obj->uuid);
+		if (rv)
+			goto bail;
+
+		LIST_INSERT_HEAD(&session->token->object_list, obj, link);
+	} else {
+		rv = SKS_OK;
+		LIST_INSERT_HEAD(get_session_objects(session), obj, link);
+	}
+
+
+	*out_handle = obj_handle;
+
+bail:
+	if (rv) {
+		handle_put(&session->object_handle_db, obj_handle);
+		if (get_bool(obj->attributes, SKS_CKA_TOKEN))
+			cleanup_persistent_object(obj, session->token);
+		else
+			cleanup_volatile_obj_ref(obj);
+	}
+
+	return rv;
+}
+
+uint32_t entry_destroy_object(uintptr_t tee_session, TEE_Param *ctrl,
+				TEE_Param *in, TEE_Param *out)
+{
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	uint32_t object_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_object *object = NULL;
+	uint32_t rv = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &object_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	object = sks_handle2object(object_handle, session);
+	if (!object)
+		return SKS_BAD_PARAM;
+
+	destroy_object(session, object, false);
+	handle_put(&session->object_handle_db, object_handle);
+
+	IMSG("SKSs%" PRIu32 ": destroy object 0x%" PRIx32,
+	     session_handle, object_handle);
+
+	return rv;
+}
+
+static uint32_t token_obj_matches_ref(struct sks_attrs_head *req_attrs,
+				      struct sks_object *obj)
+{
+	uint32_t rv = 0;
+
+	if (!obj->attributes)
+		return SKS_NOT_FOUND;
+
+	if (!attributes_match_reference(obj->attributes, req_attrs))
+		return SKS_NOT_FOUND;
+
+	rv = SKS_OK;
+
+	return rv;
+}
+
+static void release_find_obj_context(struct pkcs11_session *session,
+				     struct pkcs11_find_objects *find_ctx)
+{
+	size_t idx = 0;
+
+	if (!find_ctx)
+		return;
+
+	/* Release handles not yet published to client */
+	idx = find_ctx->next;
+	if (idx < find_ctx->temp_start)
+		idx = find_ctx->temp_start;
+
+	for (;idx < find_ctx->count; idx++)
+		handle_put(&session->object_handle_db, find_ctx->handles[idx]);
+
+	TEE_Free(find_ctx->attributes);
+	TEE_Free(find_ctx->handles);
+	TEE_Free(find_ctx);
+}
+
+/*
+ * Entry for command SKS_CMD_FIND_OBJECTS_INIT
+ */
+uint32_t entry_find_objects_init(uintptr_t tee_session, TEE_Param *ctrl,
+				 TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_object_head *template = NULL;
+	struct sks_attrs_head *req_attrs = NULL;
+	struct sks_object *obj = NULL;
+	struct pkcs11_find_objects *find_ctx = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_alloc_get_attributes(&ctrlargs, &template);
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session) {
+		rv = SKS_CKR_SESSION_HANDLE_INVALID;
+		goto bail;
+	}
+
+	/* Search objects only if no operation is on-going */
+	if (session_is_active(session)) {
+		rv = SKS_CKR_OPERATION_ACTIVE;
+		goto bail;
+	}
+
+	if (session->find_ctx) {
+		EMSG("Active object search already in progress");
+		rv = SKS_FAILED;
+		goto bail;
+	}
+
+	/* Must zero init the structure */
+	find_ctx = TEE_Malloc(sizeof(*find_ctx), TEE_MALLOC_FILL_ZERO);
+	if (!find_ctx) {
+		rv = SKS_MEMORY;
+		goto bail;
+	}
+
+	rv = sanitize_client_object(&req_attrs, template,
+				    sizeof(*template) + template->attrs_size);
+	if (rv)
+		goto bail;
+
+	TEE_Free(template);
+	template = NULL;
+
+	switch (get_class(req_attrs)) {
+	case SKS_UNDEFINED_ID:
+	/* Unspecified class searches among data objects */
+	case SKS_CKO_CERTIFICATE:
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+	case SKS_CKO_DATA:
+		break;
+	default:
+		EMSG("Find object of class %s (%u) is not supported",
+		     sks2str_class(get_class(req_attrs)),
+		     get_class(req_attrs));
+		rv = SKS_CKR_ARGUMENTS_BAD;
+		goto bail;
+
+	}
+
+	/*
+	 * Scan all objects (sessions and persistent ones) and set a list of
+	 * candidates that match caller attributes. First scan all current
+	 * session objects (that are visible to the session). Then scan all
+	 * remaining persistent object for which no session object handle was
+	 * publised to the client.
+	 */
+
+	LIST_FOREACH(obj, &session->object_list, link) {
+		uint32_t *handles = NULL;
+
+		rv = check_access_attrs_against_token(session, obj->attributes);
+		if (rv)
+			continue;
+
+		if (!attributes_match_reference(obj->attributes, req_attrs))
+			continue;
+
+		handles = TEE_Realloc(find_ctx->handles,
+				      (find_ctx->count + 1) * sizeof(*handles));
+		if (!handles) {
+			rv = SKS_MEMORY;
+			goto bail;
+		}
+		find_ctx->handles = handles;
+
+		*(find_ctx->handles + find_ctx->count) =
+			sks_object2handle(obj, session);
+		find_ctx->count++;
+	}
+
+	/* Remaining handles are those not yet published by the session */
+	find_ctx->temp_start = find_ctx->count;
+
+	LIST_FOREACH(obj, &session->token->object_list, link) {
+		uint32_t obj_handle = 0;
+		uint32_t *handles = NULL;
+
+		/*
+		 * If there are no attributes specified, we return
+		 * every object
+		 */
+		if (req_attrs->attrs_count) {
+			rv = token_obj_matches_ref(req_attrs, obj);
+			if (rv == SKS_NOT_FOUND)
+				continue;
+			if (rv != SKS_OK)
+				goto bail;
+		}
+
+		rv = check_access_attrs_against_token(session, obj->attributes);
+		if (rv)
+			continue;
+
+		/* Object may not yet be published in the session */
+		obj_handle = sks_object2handle(obj, session);
+		if (!obj_handle) {
+			obj_handle = handle_get(&session->object_handle_db,
+						obj);
+			if (!obj_handle) {
+				rv = SKS_MEMORY;
+				goto bail;
+			}
+		}
+
+		handles = TEE_Realloc(find_ctx->handles,
+				      (find_ctx->count + 1) * sizeof(*handles));
+		if (!handles) {
+			rv = SKS_MEMORY;
+			goto bail;
+		}
+
+		/* Store object handle for later publishing */
+		find_ctx->handles = handles;
+		*(handles + find_ctx->count) = obj_handle;
+		find_ctx->count++;
+	}
+
+	if (rv == SKS_NOT_FOUND)
+		rv = SKS_OK;
+
+	/* Save target attributes to search (if needed later) */
+	find_ctx->attributes = req_attrs;
+	req_attrs = NULL;
+	session->find_ctx = find_ctx;
+	find_ctx = NULL;
+	rv = SKS_OK;
+
+bail:
+	TEE_Free(req_attrs);
+	TEE_Free(template);
+	release_find_obj_context(session, find_ctx);
+
+	return rv;
+}
+
+/*
+ * Entry for command SKS_CMD_FIND_OBJECTS
+ */
+uint32_t entry_find_objects(uintptr_t tee_session, TEE_Param *ctrl,
+			    TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct pkcs11_find_objects *ctx = NULL;
+	uint32_t *out_handles = NULL;
+	size_t out_count = 0;
+	size_t count = 0;
+	size_t idx = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	out_count = out->memref.size / sizeof(uint32_t);
+	out_handles = (uint32_t *)(uintptr_t)out->memref.buffer;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	ctx = session->find_ctx;
+
+	/*
+	 * TODO: should we check again if these handles are valid?
+	 */
+	if (!ctx)
+		return SKS_CKR_OPERATION_NOT_INITIALIZED;
+
+	for (count = 0, idx = ctx->next; idx < ctx->count; idx++, count++) {
+		struct sks_object *obj = NULL;
+
+		if (count >= out_count)
+			break;
+
+		*(out_handles + count) = *(ctx->handles + idx);
+		ctx->next = idx + 1;
+
+		if (idx < session->find_ctx->temp_start)
+			continue;
+
+		/* Newly published handles: store in session list */
+		obj = handle_lookup(&session->object_handle_db,
+				    *(ctx->handles + idx));
+		if (!obj)
+			TEE_Panic(0);
+
+	}
+
+	/* Update output buffer accoriding the number of handles provided */
+	out->memref.size = count * sizeof(uint32_t);
+
+	IMSG("SKSs%" PRIu32 ": finding objects", session_handle);
+
+	return SKS_OK;
+}
+
+void release_session_find_obj_context(struct pkcs11_session *session)
+{
+	release_find_obj_context(session, session->find_ctx);
+	session->find_ctx = NULL;
+}
+
+/*
+ * Entry for command SKS_CMD_FIND_OBJECTS_FINAL
+ */
+uint32_t entry_find_objects_final(uintptr_t tee_session, TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 9;
+	struct pkcs11_session *session = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	if (!session->find_ctx)
+		return SKS_CKR_OPERATION_NOT_INITIALIZED;
+
+	release_session_find_obj_context(session);
+
+	return SKS_OK;
+}
+
+
+/*
+ * Entry for command SKS_CMD_GET_OBJECT_SIZE
+ */
+uint32_t entry_get_object_size(uintptr_t tee_session, TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out)
+{
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	uint32_t object_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_object *object = NULL;
+	uint32_t rv = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < sizeof(uint32_t))
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &object_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	object = sks_handle2object(object_handle, session);
+	if (!object)
+		return SKS_CKR_OBJECT_HANDLE_INVALID;
+
+	*(uint32_t *)out->memref.buffer = SKS_UNAVAILABLE_INFORMATION;
+	out->memref.size = sizeof(uint32_t);
+
+	return rv;
+}
+
+/*
+ * Entry for command SKS_CMD_GET_ATTRIBUTE_VALUE
+ */
+uint32_t entry_get_attribute_value(uintptr_t tee_session, TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_object_head *template = NULL;
+	struct sks_object *obj = NULL;
+	uint32_t object_handle = 0;
+	char *cur = NULL;
+	size_t len = 0;
+	size_t size = 0;
+	char *end = NULL;
+	bool attr_sensitive = 0;
+	bool attr_type_invalid = 0;
+	bool buffer_too_small = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &object_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_alloc_get_attributes(&ctrlargs, &template);
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session) {
+		rv = SKS_CKR_SESSION_HANDLE_INVALID;
+		goto bail;
+	}
+
+	obj = sks_handle2object(object_handle, session);
+	if (!obj) {
+		rv = SKS_CKR_OBJECT_HANDLE_INVALID;
+		goto bail;
+	}
+
+	rv = check_access_attrs_against_token(session, obj->attributes);
+	if (rv) {
+		rv = SKS_CKR_OBJECT_HANDLE_INVALID;
+		goto bail;
+	}
+
+	/* iterate over attributes and set their values */
+	/*
+	 * 1. If the specified attribute (i.e., the attribute specified by the
+	 * type field) for the object cannot be revealed because the object is
+	 * sensitive or unextractable, then the ulValueLen field in that triple
+	 * is modified to hold the value CK_UNAVAILABLE_INFORMATION.
+	 *
+	 * 2. Otherwise, if the specified value for the object is invalid (the
+	 * object does not possess such an attribute), then the ulValueLen field
+	 * in that triple is modified to hold the value
+	 * CK_UNAVAILABLE_INFORMATION.
+	 *
+	 * 3. Otherwise, if the pValue field has the value NULL_PTR, then the
+	 * ulValueLen field is modified to hold the exact length of the
+	 * specified attribute for the object.
+	 *
+	 * 4. Otherwise, if the length specified in ulValueLen is large enough
+	 * to hold the value of the specified attribute for the object, then
+	 * that attribute is copied into the buffer located at pValue, and the
+	 * ulValueLen field is modified to hold the exact length of the
+	 * attribute.
+	 *
+	 * 5. Otherwise, the ulValueLen field is modified to hold the value
+	 * CK_UNAVAILABLE_INFORMATION.
+	 */
+	cur = (char *)template + sizeof(struct sks_object_head);
+	end = cur + template->attrs_size;
+
+	for (; cur < end; cur += len) {
+		struct sks_attribute_head *cli_ref =
+			(struct sks_attribute_head *)(void *)cur;
+
+		len = sizeof(*cli_ref) + cli_ref->size;
+
+		/* Check 1. */
+		if (!attribute_is_exportable(cli_ref, obj)) {
+			cli_ref->size = SKS_CK_UNAVAILABLE_INFORMATION;
+			attr_sensitive = 1;
+			continue;
+		}
+
+		/*
+		 * We assume that if size is 0, pValue was NULL, so we return
+		 * the size of the required buffer for it (3., 4.)
+		 */
+		size = cli_ref->size;
+		rv = get_attribute(obj->attributes, cli_ref->id,
+				   size ? cli_ref->data : NULL, &size);
+		cli_ref->size = size;
+		/* Check 2. */
+		switch (rv) {
+		case SKS_OK:
+			break;
+		case SKS_NOT_FOUND:
+			cli_ref->size = SKS_CK_UNAVAILABLE_INFORMATION;
+			attr_type_invalid = 1;
+			break;
+		case SKS_SHORT_BUFFER:
+			buffer_too_small = 1;
+			break;
+		default:
+			rv = SKS_ERROR;
+			goto bail;
+		}
+	}
+
+	/*
+	 * If case 1 applies to any of the requested attributes, then the call
+	 * should return the value CKR_ATTRIBUTE_SENSITIVE. If case 2 applies to
+	 * any of the requested attributes, then the call should return the
+	 * value CKR_ATTRIBUTE_TYPE_INVALID. If case 5 applies to any of the
+	 * requested attributes, then the call should return the value
+	 * CKR_BUFFER_TOO_SMALL. As usual, if more than one of these error codes
+	 * is applicable, Cryptoki may return any of them. Only if none of them
+	 * applies to any of the requested attributes will CKR_OK be returned.
+	 */
+
+	rv = SKS_OK;
+	if (attr_sensitive)
+		rv = SKS_CKR_ATTRIBUTE_SENSITIVE;
+	if (attr_type_invalid)
+		rv = SKS_CKR_ATTRIBUTE_TYPE_INVALID;
+	if (buffer_too_small)
+		rv = SKS_CKR_BUFFER_TOO_SMALL;
+
+	/* Move updated template to out buffer */
+	TEE_MemMove(out->memref.buffer, template, out->memref.size);
+
+	IMSG("SKSs%" PRIu32 ": get attributes 0x%" PRIx32,
+	     session_handle, object_handle);
+
+bail:
+	TEE_Free(template);
+	template = NULL;
+
+	return rv;
+}
diff --git a/ta/secure_key_services/src/object.h b/ta/secure_key_services/src/object.h
new file mode 100644
index 00000000..16b5002a
--- /dev/null
+++ b/ta/secure_key_services/src/object.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#ifndef __SKS_OBJECT_H__
+#define __SKS_OBJECT_H__
+
+#include <sks_internal_abi.h>
+#include <sys/queue.h>
+#include <tee_internal_api.h>
+
+struct pkcs11_session;
+struct ck_token;
+
+struct sks_object {
+	LIST_ENTRY(sks_object) link;
+	/* pointer to the serialized object attributes */
+	void *attributes;
+	TEE_ObjectHandle key_handle;	/* Valid handle for TEE operations */
+	uint32_t key_type;		/* TEE type of key_handle */
+
+	/* These are for persistent/token objects */
+	TEE_UUID *uuid;
+	TEE_ObjectHandle attribs_hdl;
+};
+
+LIST_HEAD(object_list, sks_object);
+
+struct sks_object *sks_handle2object(uint32_t client_handle,
+				     struct pkcs11_session *session);
+
+uint32_t sks_object2handle(struct sks_object *obj,
+			   struct pkcs11_session *session);
+
+struct sks_object *create_token_object_instance(struct sks_attrs_head *head,
+						TEE_UUID *uuid);
+
+uint32_t create_object(void *session, struct sks_attrs_head *attributes,
+			uint32_t *handle);
+
+void cleanup_persistent_object(struct sks_object *obj,
+			struct ck_token *token);
+
+void destroy_object(struct pkcs11_session *session, struct sks_object *object,
+		    bool session_object_only);
+
+/*
+ * Entry function called from the SKS command parser
+ */
+uint32_t entry_destroy_object(uintptr_t teesess, TEE_Param *ctrl,
+			      TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_find_objects_init(uintptr_t teesess, TEE_Param *ctrl,
+				 TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_find_objects(uintptr_t teesess, TEE_Param *ctrl,
+			    TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_find_objects_final(uintptr_t teesess, TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_get_object_size(uintptr_t teesess, TEE_Param *ctrl,
+			       TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_get_attribute_value(uintptr_t teesess, TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out);
+
+void release_session_find_obj_context(struct pkcs11_session *session);
+
+#endif /*__SKS_OBJECT_H__*/
diff --git a/ta/secure_key_services/src/persistent_token.c b/ta/secure_key_services/src/persistent_token.c
new file mode 100644
index 00000000..3bd3cdee
--- /dev/null
+++ b/ta/secure_key_services/src/persistent_token.c
@@ -0,0 +1,501 @@
+/*
+ * Copyright (c) 2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <assert.h>
+#include <sks_ta.h>
+#include <string.h>
+#include <string_ext.h>
+#include <tee_internal_api_extensions.h>
+#include <util.h>
+
+#include "pkcs11_token.h"
+#include "sks_helpers.h"
+
+/*
+ * Token persistent objects
+ *
+ * The persistent objects are each identified by a UUID.
+ * The persistent object database stores the list of the UUIDs registered. For
+ * each it is expected that a file of ID "UUID" is store in the OP-TEE secure
+ * storage.
+ */
+
+/* 'X' will be replaced by the token decimal id (up to 9!) */
+#define TOKEN_DB_FILE_BASE		"token.db.X"
+
+void close_persistent_db(struct ck_token *token)
+{
+	int n = 0;
+
+	for (n = 0; n < SKS_MAX_USERS; n++) {
+		TEE_CloseObject(token->pin_hdl[n]);
+		token->pin_hdl[n] = TEE_HANDLE_NULL;
+	}
+
+	TEE_CloseObject(token->db_hdl);
+	token->db_hdl = TEE_HANDLE_NULL;
+}
+
+int update_persistent_db(struct ck_token *token, size_t offset, size_t size)
+{
+	unsigned int token_id = get_token_id(token);
+	char file[] = TOKEN_DB_FILE_BASE;
+	uint8_t *field = (uint8_t *)token->db_main + offset;
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	if (snprintf(file + sizeof(file) - 2, 2, "%1d", token_id) >= 2)
+		TEE_Panic(0);
+
+	if (token->db_hdl == TEE_HANDLE_NULL)
+		return 1;
+
+	res = TEE_SeekObjectData(token->db_hdl, offset, TEE_DATA_SEEK_SET);
+	if (res)
+		return tee2sks_error(res);
+
+	res = TEE_WriteObjectData(token->db_hdl, field, size);
+	if (res)
+		return tee2sks_error(res);
+
+	return 0;
+}
+
+static void init_pin_keys(struct ck_token *token, unsigned int uid)
+{
+	TEE_Result res = TEE_ERROR_GENERIC;
+	unsigned int token_id = get_token_id(token);
+	TEE_ObjectHandle *key_hdl = &token->pin_hdl[uid];
+	char file[32] = { 0 };
+
+	assert(token_id < 10 && uid < 10);
+
+	if (snprintf(file, 32, "token.db.%1d-pin%1d", token_id, uid) >= 32)
+		TEE_Panic(0);
+
+	res = TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE,
+					file, sizeof(file), 0, key_hdl);
+	if (res == TEE_SUCCESS) {
+		DMSG("PIN key found");
+		return;
+	}
+
+	if (res == TEE_ERROR_ITEM_NOT_FOUND) {
+		TEE_Attribute attr;
+		TEE_ObjectHandle hdl = TEE_HANDLE_NULL;
+		uint8_t pin_key[16] = { 0 };
+
+		TEE_MemFill(&attr, 0, sizeof(attr));
+
+		TEE_GenerateRandom(pin_key, sizeof(pin_key));
+		TEE_InitRefAttribute(&attr, TEE_ATTR_SECRET_VALUE,
+				     pin_key, sizeof(pin_key));
+
+		res = TEE_AllocateTransientObject(TEE_TYPE_AES, 128, &hdl);
+		if (res)
+			TEE_Panic(0);
+
+		res = TEE_PopulateTransientObject(hdl, &attr, 1);
+		if (res)
+			TEE_Panic(0);
+
+		res = TEE_CreatePersistentObject(TEE_STORAGE_PRIVATE,
+						 file, sizeof(file), 0,
+						 hdl,
+						 pin_key, sizeof(pin_key),
+						 key_hdl);
+		if (res)
+			TEE_Panic(0);
+
+		TEE_FreeTransientObject(hdl);
+		return;
+	}
+
+	TEE_Panic(0);
+}
+
+/* UUID for persistent object */
+uint32_t create_object_uuid(struct ck_token *token __unused,
+			    struct sks_object *obj)
+{
+	assert(!obj->uuid);
+
+	obj->uuid = TEE_Malloc(sizeof(TEE_UUID),
+				TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!obj->uuid)
+		return SKS_MEMORY;
+
+	TEE_GenerateRandom(obj->uuid, sizeof(TEE_UUID));
+
+	/*
+	 * TODO: check uuid against already registered one (in persistent
+	 * database) and the pending created uuids (not already registered
+	 * if any).
+	 */
+	return SKS_OK;
+}
+
+void destroy_object_uuid(struct ck_token *token __unused,
+			 struct sks_object *obj)
+{
+	if (!obj->uuid)
+		return;
+
+	/* TODO: check uuid is not still registered in persistent db ? */
+	TEE_Free(obj->uuid);
+	obj->uuid = NULL;
+}
+
+uint32_t get_persistent_objects_list(struct ck_token *token,
+				     TEE_UUID *array, size_t *size)
+{
+	size_t out_size = *size;
+
+	*size = token->db_objs->count * sizeof(TEE_UUID);
+
+	if (out_size < *size)
+		return SKS_SHORT_BUFFER;
+
+	if (array)
+		TEE_MemMove(array, token->db_objs->uuids, *size);
+
+	return SKS_OK;
+}
+
+uint32_t unregister_persistent_object(struct ck_token *token, TEE_UUID *uuid)
+{
+	int index = 0;
+	int count = 0;
+	struct token_persistent_objs *ptr;
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	if (!uuid)
+		return SKS_OK;
+
+	for (index = (int)(token->db_objs->count) - 1; index >= 0; index--) {
+		if (!TEE_MemCompare(token->db_objs->uuids + index,
+				    uuid, sizeof(TEE_UUID)))
+			break;
+	}
+
+	if (index < 0) {
+		EMSG("Cannot unregister an invalid persistent object");
+		return SKS_NOT_FOUND;
+	}
+
+	ptr = TEE_Malloc(sizeof(struct token_persistent_objs) +
+			 ((token->db_objs->count - 1) * sizeof(TEE_UUID)),
+			 TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!ptr)
+		return SKS_MEMORY;
+
+	res = TEE_SeekObjectData(token->db_hdl,
+				 sizeof(struct token_persistent_main),
+				 TEE_DATA_SEEK_SET);
+	if (res) {
+		EMSG("Failed to read database");
+		TEE_Free(ptr);
+		return tee2sks_error(res);
+	}
+
+	TEE_MemMove(ptr, token->db_objs,
+		    sizeof(struct token_persistent_objs) +
+		    index * sizeof(TEE_UUID));
+
+	ptr->count--;
+	count = ptr->count - index;
+
+	TEE_MemMove(&ptr->uuids[index],
+		    &token->db_objs->uuids[index + 1],
+		    count * sizeof(TEE_UUID));
+
+	res = TEE_WriteObjectData(token->db_hdl, ptr,
+				  sizeof(struct token_persistent_objs) +
+				  ptr->count * sizeof(TEE_UUID));
+	if (res) {
+		EMSG("Failed to update database");
+		TEE_Free(ptr);
+		return tee2sks_error(res);
+	}
+
+	TEE_Free(token->db_objs);
+	token->db_objs = ptr;
+
+	return SKS_OK;
+}
+
+uint32_t register_persistent_object(struct ck_token *token, TEE_UUID *uuid)
+{
+	int count = 0;
+	void *ptr = NULL;
+	size_t __maybe_unused size = 0;
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	for (count = (int)token->db_objs->count - 1; count >= 0; count--)
+		if (!TEE_MemCompare(token->db_objs->uuids + count, uuid,
+				    sizeof(TEE_UUID)))
+			TEE_Panic(0);
+
+	count = token->db_objs->count;
+	ptr = TEE_Realloc(token->db_objs,
+			  sizeof(struct token_persistent_objs) +
+			  ((count + 1) * sizeof(TEE_UUID)));
+	if (!ptr)
+		return SKS_MEMORY;
+
+	token->db_objs = ptr;
+	TEE_MemMove(token->db_objs->uuids + count, uuid, sizeof(TEE_UUID));
+
+	size = sizeof(struct token_persistent_main) +
+		sizeof(struct token_persistent_objs) +
+		count * sizeof(TEE_UUID);
+
+	res = TEE_TruncateObjectData(token->db_hdl, size + sizeof(TEE_UUID));
+	if (res)
+		return tee2sks_error(res);
+
+	res = TEE_SeekObjectData(token->db_hdl,
+				 sizeof(struct token_persistent_main),
+				 TEE_DATA_SEEK_SET);
+	if (res)
+		return tee2sks_error(res);
+
+	token->db_objs->count++;
+
+	res = TEE_WriteObjectData(token->db_hdl, token->db_objs,
+				  sizeof(struct token_persistent_objs) +
+				  token->db_objs->count * sizeof(TEE_UUID));
+	if (res) {
+		token->db_objs->count--;
+		return tee2sks_error(res);
+	}
+
+	return SKS_OK;
+}
+
+static uint32_t token_load_obj_attribs(struct sks_object *obj)
+{
+	uint32_t rv = 0;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	TEE_ObjectHandle hdl = obj->attribs_hdl;
+	TEE_ObjectInfo info;
+	struct sks_attrs_head *attr = NULL;
+	uint32_t read_bytes = 0;
+
+	if (hdl != TEE_HANDLE_NULL) {
+		IMSG("Handle attributes already set for this object");
+		return SKS_OK;
+	}
+
+	res = TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE,
+					   obj->uuid, sizeof(*obj->uuid),
+					   TEE_DATA_FLAG_ACCESS_READ,
+					   &hdl);
+	if (res) {
+		EMSG("OpenPersistent failed 0x%" PRIx32, res);
+		return tee2sks_error(res);
+	}
+
+	TEE_MemFill(&info, 0, sizeof(info));
+	res = TEE_GetObjectInfo1(hdl, &info);
+	if (res) {
+		EMSG("GetObjectInfo failed 0x%" PRIx32, res);
+		rv = tee2sks_error(res);
+		goto bail;
+	}
+
+	attr = TEE_Malloc(info.dataSize, TEE_MALLOC_FILL_ZERO);
+	if (!attr) {
+		rv = SKS_MEMORY;
+		goto bail;
+	}
+
+	res = TEE_ReadObjectData(hdl, attr, info.dataSize, &read_bytes);
+	if (!res) {
+		res = TEE_SeekObjectData(hdl, 0, TEE_DATA_SEEK_SET);
+		if (res)
+			EMSG("Seek to 0 failed 0x%" PRIx32, res);
+	}
+
+	if (res) {
+		rv = tee2sks_error(res);
+		EMSG("Read %" PRIu32 " bytes, failed 0x%" PRIx32,
+			read_bytes, res);
+		goto bail;
+	}
+	if (read_bytes != info.dataSize) {
+		EMSG("Read %" PRIu32 " bytes, expected 0x%" PRIu32,
+			read_bytes, info.dataSize);
+		rv = SKS_ERROR;
+		goto bail;
+	}
+
+	obj->attributes = attr;
+	attr = NULL;
+	obj->attribs_hdl = hdl;
+	hdl = TEE_HANDLE_NULL;
+	rv = SKS_OK;
+
+bail:
+	TEE_Free(attr);
+	if (obj->attribs_hdl == TEE_HANDLE_NULL && hdl != TEE_HANDLE_NULL) {
+		TEE_CloseObject(hdl);
+	}
+
+	return rv;
+}
+
+/*
+ * Return the token instance, either initialized from reset or initialized
+ * from the token persistent state if found.
+ */
+struct ck_token *init_token_db(unsigned int token_id)
+{
+	struct ck_token *token = get_token(token_id);
+	TEE_Result res = TEE_ERROR_GENERIC;
+	char db_file[] = TOKEN_DB_FILE_BASE;
+	TEE_ObjectHandle db_hdl = TEE_HANDLE_NULL;
+	/* Copy persistent database: main db and object db */
+	struct token_persistent_main *db_main = NULL;
+	struct token_persistent_objs *db_objs = NULL;
+	int n = 0;
+	void *ptr = NULL;
+
+	if (!token)
+		return NULL;
+
+	for (n = 0; n < SKS_MAX_USERS; n++)
+		init_pin_keys(token, n);
+
+	LIST_INIT(&token->object_list);
+
+	db_main = TEE_Malloc(sizeof(*db_main), TEE_MALLOC_FILL_ZERO);
+	db_objs = TEE_Malloc(sizeof(*db_objs), TEE_MALLOC_FILL_ZERO);
+	if (!db_main || !db_objs)
+		goto error;
+
+	/* Persistent object ID is the string with last char replaced */
+	if (snprintf(db_file + sizeof(db_file) - 2, 2, "%1d", token_id) >= 2)
+		TEE_Panic(0);
+
+	res = TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE,
+					db_file, sizeof(db_file),
+					TEE_DATA_FLAG_ACCESS_READ |
+					TEE_DATA_FLAG_ACCESS_WRITE,
+					&db_hdl);
+	if (res == TEE_SUCCESS) {
+		uint32_t size = 0;
+		size_t idx = 0;
+
+		IMSG("SKSt%u: load db", token_id);
+
+		size = sizeof(*db_main);
+		res = TEE_ReadObjectData(db_hdl, db_main, size, &size);
+		if (res || size != sizeof(*db_main))
+			TEE_Panic(0);
+
+		size = sizeof(*db_objs);
+		res = TEE_ReadObjectData(db_hdl, db_objs, size, &size);
+		if (res || size != sizeof(*db_objs))
+			TEE_Panic(0);
+
+		size += db_objs->count * sizeof(TEE_UUID);
+		ptr = TEE_Realloc(db_objs, size);
+		if (!ptr)
+			goto error;
+
+		db_objs = ptr;
+		size -= sizeof(struct token_persistent_objs);
+		res = TEE_ReadObjectData(db_hdl, db_objs->uuids, size, &size);
+		if (res || size != (db_objs->count * sizeof(TEE_UUID)))
+			TEE_Panic(0);
+
+		for (idx = 0; idx < db_objs->count; idx++) {
+			/* Create an empty object instance */
+			struct sks_object *obj = NULL;
+			TEE_UUID *uuid = NULL;
+
+			uuid = TEE_Malloc(sizeof(TEE_UUID),
+					  TEE_USER_MEM_HINT_NO_FILL_ZERO);
+			if (!uuid)
+				goto error;
+
+			TEE_MemMove(uuid, &db_objs->uuids[idx], sizeof(*uuid));
+
+			obj = create_token_object_instance(NULL, uuid);
+			if (!obj)
+				TEE_Panic(0);
+
+			if (token_load_obj_attribs(obj) != SKS_OK)
+				EMSG("Unable to load object attributes from db");
+
+			LIST_INSERT_HEAD(&token->object_list, obj, link);
+		}
+
+	} else if (res == TEE_ERROR_ITEM_NOT_FOUND) {
+
+		IMSG("SKSt%u: init db", token_id);
+
+		TEE_MemFill(db_main, 0, sizeof(*db_main));
+		TEE_MemFill(db_main->label, '*', sizeof(db_main->label));
+
+		/*
+		 * Not supported:
+		 *   SKS_TOKEN_FULLY_RESTORABLE
+		 * TODO: check these:
+		 *   SKS_TOKEN_HAS_CLOCK => related to TEE time secure level
+		 */
+		db_main->flags = SKS_CKFT_SO_PIN_TO_BE_CHANGED |
+				 SKS_CKFT_USER_PIN_TO_BE_CHANGED |
+				 SKS_CKFT_RNG |
+				 SKS_CKFT_DUAL_CRYPTO_OPERATIONS |
+				 SKS_CKFT_LOGIN_REQUIRED;
+
+		/* 2 files: persistent state + persistent object references */
+		res = TEE_CreatePersistentObject(TEE_STORAGE_PRIVATE,
+						 db_file, sizeof(db_file),
+						 TEE_DATA_FLAG_ACCESS_READ |
+						 TEE_DATA_FLAG_ACCESS_WRITE,
+						 TEE_HANDLE_NULL,
+						 db_main, sizeof(*db_main),
+						 &db_hdl);
+		if (res)
+			TEE_Panic(0);
+
+		res = TEE_TruncateObjectData(db_hdl, sizeof(*db_main) +
+							sizeof(*db_objs));
+		if (res)
+			TEE_Panic(0);
+
+		res = TEE_SeekObjectData(db_hdl, sizeof(*db_main),
+					 TEE_DATA_SEEK_SET);
+		if (res)
+			TEE_Panic(0);
+
+		db_objs->count = 0;
+		res = TEE_WriteObjectData(db_hdl, db_objs, sizeof(*db_objs));
+		if (res)
+			TEE_Panic(0);
+
+	} else {
+		/* Can't do anything... */
+		return NULL;
+	}
+
+	token->db_main = db_main;
+	token->db_objs = db_objs;
+	token->db_hdl = db_hdl;
+	TEE_SeekObjectData(token->db_hdl, 0, TEE_DATA_SEEK_SET);
+
+	return token;
+
+error:
+	TEE_Free(db_main);
+	TEE_Free(db_objs);
+	if (db_hdl != TEE_HANDLE_NULL)
+		TEE_CloseObject(db_hdl);
+
+	return NULL;
+}
diff --git a/ta/secure_key_services/src/pkcs11_attributes.c b/ta/secure_key_services/src/pkcs11_attributes.c
new file mode 100644
index 00000000..ad115bcf
--- /dev/null
+++ b/ta/secure_key_services/src/pkcs11_attributes.c
@@ -0,0 +1,1751 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <stdlib.h>
+#include <assert.h>
+#include <inttypes.h>
+#include <sks_internal_abi.h>
+#include <sks_ta.h>
+#include <string_ext.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include <util.h>
+
+#include "attributes.h"
+#include "handle.h"
+#include "object.h"
+#include "pkcs11_attributes.h"
+#include "pkcs11_token.h"
+#include "processing.h"
+#include "sanitize_object.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+/* Byte size of CKA_ID attribute when generated locally */
+#define SKS_CKA_DEFAULT_SIZE		16
+
+struct pkcs11_mechachism_modes {
+	uint32_t id;
+	uint32_t flags;
+	bool available;
+	bool one_shot;
+};
+
+/*
+ * SKS_CKFM_EC_F_P
+ * SKS_CKFM_EC_F_2M
+ * SKS_CKFM_EC_ECPARAMETERS
+ * SKS_CKFM_EC_NAMEDCURVE
+ * SKS_CKFM_EC_UNCOMPRESS
+ * SKS_CKFM_EC_COMPRESS
+ */
+#define SKS_ECM		0
+
+/* SKS_CKFM_HW: need to ask core one HW support of the mechanisms */
+#define SKS_M(_label, _dig, _enc, _dec, _sig, _ver,		\
+		_sr, _vr, _der, _wra, _unw, _gen, _gpa, _1s)	\
+	{							\
+		.id = SKS_CKM_  ## _label,			\
+		.one_shot = _1s,				\
+		.flags = (_enc ? SKS_CKFM_ENCRYPT : 0) |	\
+			(_dec ? SKS_CKFM_DECRYPT : 0) |		\
+			(_dig ? SKS_CKFM_DIGEST : 0) |		\
+			(_sig ? SKS_CKFM_SIGN : 0) |		\
+			(_sr ? SKS_CKFM_SIGN_RECOVER : 0) |	\
+			(_ver ? SKS_CKFM_VERIFY : 0) |		\
+			(_vr ? SKS_CKFM_VERIFY_RECOVER : 0) |	\
+			(_gen ? SKS_CKFM_GENERATE : 0) |	\
+			(_gpa ? SKS_CKFM_GENERATE_PAIR : 0) |	\
+			(_wra ? SKS_CKFM_WRAP : 0) |		\
+			(_unw ? SKS_CKFM_UNWRAP : 0) |		\
+			(_der ? SKS_CKFM_DERIVE : 0) |		\
+			SKS_ECM,				\
+	}
+
+static const __maybe_unused struct pkcs11_mechachism_modes pkcs11_modes[] = {
+	/*
+	 * PKCS#11 directives on mechanism support for the several processing
+	 * modes.
+	 *				1: One shot processing only --------.
+	 *				Gp: Generate secret pair --------.  |
+	 *				Ge: Generate secret value ----.  |  |
+	 *				Wr|Uw: Wrap/Unwrap -------.   |  |  |
+	 *				Dr: Derive ----------.    |   |  |  |
+	 *		Sr|Vr: SignRecover/VerifyRecov --.   |    |   |  |  |
+	 *		Si|Ve: Sign/Verify --------.     |   |    |   |  |  |
+	 *		En|De: Encrypt/Decrypt     |     |   |    |   |  |  |
+	 *		Di: Digest -----.    |     |     |   |    |   |  |  |
+	 *				|   / \   / \   / \  |   / \  |  |  |
+	 * Mechanism			Di|En|De|Si|Ve|Sr|Vr|Dr|Wr|Uw|Ge|Gp|1
+	 */
+	SKS_M(AES_ECB,			0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	SKS_M(AES_CBC,			0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	SKS_M(AES_CBC_PAD,		0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	SKS_M(AES_CTS,			0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	SKS_M(AES_CTR,			0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	SKS_M(AES_GCM,			0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	SKS_M(AES_CCM,			0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	SKS_M(AES_GMAC,			0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0),
+	SKS_M(AES_CMAC,			0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(AES_CMAC_GENERAL,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(AES_ECB_ENCRYPT_DATA,	0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0),
+	SKS_M(AES_CBC_ENCRYPT_DATA,	0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0),
+	SKS_M(AES_KEY_GEN,		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0),
+	/* Mechanism			Di|En|De|Si|Ve|Sr|Vr|Dr|Wr|Uw|Ge|Gp|1 */
+	SKS_M(GENERIC_SECRET_KEY_GEN,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0),
+	SKS_M(MD5_HMAC,			0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA_1_HMAC,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA224_HMAC,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA256_HMAC,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA384_HMAC,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA512_HMAC,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(AES_XCBC_MAC,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* Mechanism			Di|En|De|Si|Ve|Sr|Vr|Dr|Wr|Uw|Ge|Gp|1 */
+	SKS_M(EC_KEY_PAIR_GEN,		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0),
+	SKS_M(ECDSA,			0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1),
+	SKS_M(ECDSA_SHA1,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(ECDSA_SHA224,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(ECDSA_SHA256,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(ECDSA_SHA384,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(ECDSA_SHA512,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(ECDH1_DERIVE,		0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0),
+	SKS_M(ECDH1_COFACTOR_DERIVE,	0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0),
+	SKS_M(ECMQV_DERIVE,		0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0),
+	SKS_M(ECDH_AES_KEY_WRAP,	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	/* Mechanism			Di|En|De|Si|Ve|Sr|Vr|Dr|Wr|Uw|Ge|Gp|1 */
+	SKS_M(RSA_PKCS_KEY_PAIR_GEN,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0),
+	SKS_M(RSA_PKCS,			0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1),
+	SKS_M(RSA_PKCS_PSS,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1),
+	SKS_M(RSA_PKCS_OAEP,		0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1),
+	SKS_M(RSA_9796,			0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1),
+	SKS_M(RSA_X_509,		0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1),
+	SKS_M(SHA1_RSA_PKCS,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0),
+	SKS_M(SHA1_RSA_PKCS_PSS,	0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA256_RSA_PKCS,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA384_RSA_PKCS,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA512_RSA_PKCS,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA256_RSA_PKCS_PSS,	0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA384_RSA_PKCS_PSS,	0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA512_RSA_PKCS_PSS,	0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA224_RSA_PKCS,		0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA224_RSA_PKCS_PSS,	0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(RSA_AES_KEY_WRAP,		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0),
+	/* Mechanism			Di|En|De|Si|Ve|Sr|Vr|Dr|Wr|Uw|Ge|Gp|1 */
+	SKS_M(MD5,			1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA_1,			1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA224,			1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA256,			1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA384,			1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	SKS_M(SHA512,			1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	/*
+	 * Mechanism			Di|En|De|Si|Ve|Sr|Vr|Dr|Wr|Uw|Ge|Gp|1
+	 *                              |   \_/   \_/   \_/  |   \_/  |  |  |
+	 *		Di: Digest -----'    |     |     |   |    |   |  |  |
+	 *		En|De: Encrypt/Decrypt     |     |   |    |   |  |  |
+	 *		Si|Ve: Sign/Verify --------'     |   |    |   |  |  |
+	 *		Sr|Vr: SignUpdate/VerifyRecover -'   |    |   |  |  |
+	 *				Dr: Derive ----------'    |   |  |  |
+	 *				Wr|Uw: Wrap/Unwrap -------'   |  |  |
+	 *				Ge: Generate secret value ----'  |  |
+	 *				Gp: Generate secret pair --------'  |
+	 *				1: One shot processing only --------'
+	 */
+};
+
+static uint32_t sks_function2ckfm(enum processing_func function)
+{
+	switch (function) {
+	case SKS_FUNCTION_DIGEST:
+		return SKS_CKFM_DIGEST;
+	case SKS_FUNCTION_GENERATE:
+		return SKS_CKFM_GENERATE;
+	case SKS_FUNCTION_GENERATE_PAIR:
+		return SKS_CKFM_GENERATE_PAIR;
+	case SKS_FUNCTION_DERIVE:
+		return SKS_CKFM_DERIVE;
+	case SKS_FUNCTION_WRAP:
+		return SKS_CKFM_WRAP;
+	case SKS_FUNCTION_UNWRAP:
+		return SKS_CKFM_UNWRAP;
+	case SKS_FUNCTION_ENCRYPT:
+		return SKS_CKFM_ENCRYPT;
+	case SKS_FUNCTION_DECRYPT:
+		return SKS_CKFM_DECRYPT;
+	case SKS_FUNCTION_SIGN:
+		return SKS_CKFM_SIGN;
+	case SKS_FUNCTION_VERIFY:
+		return SKS_CKFM_VERIFY;
+	case SKS_FUNCTION_SIGN_RECOVER:
+		return SKS_CKFM_SIGN_RECOVER;
+	case SKS_FUNCTION_VERIFY_RECOVER:
+		return SKS_CKFM_VERIFY_RECOVER;
+	default:
+		return 0;
+	}
+}
+
+int check_pkcs11_mechanism_flags(uint32_t mechanism_type, uint32_t flags)
+{
+	size_t n = 0;
+	uint32_t test_flags = flags & (SKS_CKFM_ENCRYPT | SKS_CKFM_DECRYPT |
+				SKS_CKFM_DERIVE | SKS_CKFM_DIGEST |
+				SKS_CKFM_SIGN | SKS_CKFM_SIGN_RECOVER |
+				SKS_CKFM_VERIFY | SKS_CKFM_VERIFY_RECOVER |
+				SKS_CKFM_GENERATE | SKS_CKFM_GENERATE_PAIR |
+				SKS_CKFM_WRAP | SKS_CKFM_UNWRAP);
+
+	for (n = 0; n < ARRAY_SIZE(pkcs11_modes); n++) {
+		if (pkcs11_modes[n].id == mechanism_type) {
+			if (test_flags & ~pkcs11_modes[n].flags) {
+				EMSG("%s flags: 0x%" PRIx32 " vs 0x%" PRIx32,
+					sks2str_proc(mechanism_type),
+					test_flags, pkcs11_modes[n].flags);
+			}
+			return test_flags & ~pkcs11_modes[n].flags;
+		}
+	}
+
+	return 1;
+}
+
+uint32_t check_mechanism_against_processing(struct pkcs11_session *session,
+					    uint32_t mechanism_type,
+					    enum processing_func function,
+					    enum processing_step step)
+{
+	size_t n = 0;
+	bool allowed = false;
+
+	switch (step) {
+	case SKS_FUNC_STEP_INIT:
+		switch (function) {
+		case SKS_FUNCTION_IMPORT:
+		case SKS_FUNCTION_COPY:
+		case SKS_FUNCTION_MODIFY:
+		case SKS_FUNCTION_DESTROY:
+			return SKS_OK;
+		default:
+			for (n = 0; n < ARRAY_SIZE(pkcs11_modes); n++) {
+				if (pkcs11_modes[n].id == mechanism_type) {
+					allowed = pkcs11_modes[n].flags &
+						  sks_function2ckfm(function);
+					break;
+				}
+			}
+			break;
+		}
+		break;
+
+	case SKS_FUNC_STEP_ONESHOT:
+	case SKS_FUNC_STEP_UPDATE:
+		if (session->processing->always_authen &&
+		    !session->processing->relogged)
+			return SKS_CKR_USER_NOT_LOGGED_IN;
+
+		if (!session->processing->updated) {
+			allowed = true;
+		} else {
+			for (n = 0; n < ARRAY_SIZE(pkcs11_modes); n++) {
+				if (pkcs11_modes[n].id == mechanism_type) {
+					allowed = !pkcs11_modes[n].one_shot;
+					break;
+				}
+			}
+		}
+		break;
+
+	case SKS_FUNC_STEP_FINAL:
+		if (session->processing->always_authen &&
+		    !session->processing->relogged)
+			return SKS_CKR_USER_NOT_LOGGED_IN;
+
+		return SKS_OK;
+
+	default:
+		TEE_Panic(step);
+		break;
+	}
+
+	if (!allowed)
+		EMSG("Processing %s (%" PRIx32 ") not permitted (%u/%u)",
+			sks2str_proc(mechanism_type), mechanism_type,
+			function, step);
+
+	return allowed ? SKS_OK : SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+}
+
+/*
+ * Object default boolean attributes as per PKCS#11
+ */
+static uint8_t *pkcs11_object_default_boolprop(uint32_t attribute)
+{
+	static const uint8_t bool_true = 1;
+	static const uint8_t bool_false = 0;
+
+	switch (attribute) {
+	/* As per PKCS#11 default value */
+	case SKS_CKA_MODIFIABLE:
+	case SKS_CKA_COPYABLE:
+	case SKS_CKA_DESTROYABLE:
+	case SKS_CKA_SIGN:
+	case SKS_CKA_VERIFY:
+		return (uint8_t *)&bool_true;
+	case SKS_CKA_TOKEN:
+	case SKS_CKA_PRIVATE:
+	case SKS_CKA_SENSITIVE:  /* TODO: symkey false, privkey: token specific */
+	/* Token specific default value */
+	case SKS_CKA_DERIVE:
+	case SKS_CKA_ENCRYPT:
+	case SKS_CKA_DECRYPT:
+	case SKS_CKA_SIGN_RECOVER:
+	case SKS_CKA_VERIFY_RECOVER:
+	case SKS_CKA_WRAP:
+	case SKS_CKA_UNWRAP:
+	case SKS_CKA_EXTRACTABLE:
+	case SKS_CKA_WRAP_WITH_TRUSTED:
+	case SKS_CKA_ALWAYS_AUTHENTICATE:
+	case SKS_CKA_TRUSTED:
+		return (uint8_t *)&bool_false;
+	default:
+		DMSG("No default for boolprop attribute 0x%" PRIx32, attribute);
+		TEE_Panic(0); // FIXME: errno
+	}
+
+	/* Keep compiler happy */
+	return NULL;
+}
+
+/*
+ * Object expects several boolean attributes to be set to a default value
+ * or to a validate client configuration value. This function append the input
+ * attrubute (id/size/value) in the serailzed object.
+ */
+static uint32_t pkcs11_import_object_boolprop(struct sks_attrs_head **out,
+					      struct sks_attrs_head *template,
+					      uint32_t attribute)
+{
+	uint32_t rv = 0;
+	uint8_t bbool = 0;
+	size_t size = sizeof(uint8_t);
+	void *attr = NULL;
+
+	rv = get_attribute(template, attribute, &bbool, &size);
+	if (rv || !bbool)
+		attr = pkcs11_object_default_boolprop(attribute);
+	else
+		attr = &bbool;
+
+	/* Boolean attributes are 1byte in the ABI, no alignment issue */
+	return add_attribute(out, attribute, attr, sizeof(uint8_t));
+}
+
+static uint32_t set_mandatory_boolprops(struct sks_attrs_head **out,
+					struct sks_attrs_head *temp,
+					uint32_t const *bp, size_t bp_count)
+{
+	uint32_t rv = SKS_OK;
+	size_t n = 0;
+
+	for (n = 0; n < bp_count; n++) {
+		rv = pkcs11_import_object_boolprop(out, temp, bp[n]);
+		if (rv)
+			return rv;
+	}
+
+	return rv;
+}
+
+static uint32_t __unused set_mandatory_attributes(struct sks_attrs_head **out,
+					 struct sks_attrs_head *temp,
+					 uint32_t const *bp, size_t bp_count)
+{
+	uint32_t rv = SKS_OK;
+	size_t n = 0;
+
+	for (n = 0; n < bp_count; n++) {
+		size_t size = 0;
+		void *value = NULL;
+
+		if (get_attribute_ptr(temp, bp[n], &value, &size)) {
+			/* FIXME: currently set attribute as empty. Fail? */
+			size = 0;
+		}
+
+		rv = add_attribute(out, bp[n], value, size);
+		if (rv)
+			return rv;
+	}
+
+	return rv;
+}
+
+static uint32_t set_optional_attributes(struct sks_attrs_head **out,
+					struct sks_attrs_head *temp,
+					uint32_t const *bp, size_t bp_count)
+{
+	uint32_t rv = SKS_OK;
+	size_t n = 0;
+
+	for (n = 0; n < bp_count; n++) {
+		size_t size = 0;
+		void *value = NULL;
+
+		if (get_attribute_ptr(temp, bp[n], &value, &size))
+			continue;
+
+		rv = add_attribute(out, bp[n], value, size);
+		if (rv)
+			return rv;
+	}
+
+	return rv;
+}
+
+/*
+ * Below are listed the mandated or optional epected attributes for
+ * PKCS#11 storage objects.
+ *
+ * Note: boolprops (manadated boolean attributes) SKS_CKA_ALWAYS_SENSITIVE,
+ * and SKS_CKA_NEVER_EXTRACTABLE are set by the token, not provided
+ * in the client template.
+ */
+
+/* PKCS#11 specification for any object (session/token) of the storage */
+static const uint32_t pkcs11_any_object_boolprops[] = {
+	SKS_CKA_TOKEN, SKS_CKA_PRIVATE,
+	SKS_CKA_MODIFIABLE, SKS_CKA_COPYABLE, SKS_CKA_DESTROYABLE,
+};
+static const uint32_t pkcs11_any_object_mandated[] = {
+	SKS_CKA_LABEL,
+};
+/* PKCS#11 specification for raw data object (+pkcs11_any_object_xxx) */
+const uint32_t pkcs11_raw_data_optional[] = {
+	SKS_CKA_OBJECT_ID, SKS_CKA_APPLICATION, SKS_CKA_VALUE,
+};
+/* PKCS#11 specification for any key object (+pkcs11_any_object_xxx) */
+static const uint32_t pkcs11_any_key_boolprops[] = {
+	SKS_CKA_DERIVE,
+};
+static const uint32_t pkcs11_any_key_optional[] = {
+	SKS_CKA_ID,
+	SKS_CKA_START_DATE, SKS_CKA_END_DATE,
+	SKS_CKA_ALLOWED_MECHANISMS,
+};
+/* PKCS#11 specification for any symmetric key (+pkcs11_any_key_xxx) */
+static const uint32_t pkcs11_symm_key_boolprops[] = {
+	SKS_CKA_ENCRYPT, SKS_CKA_DECRYPT, SKS_CKA_SIGN, SKS_CKA_VERIFY,
+	SKS_CKA_WRAP, SKS_CKA_UNWRAP,
+	SKS_CKA_SENSITIVE, SKS_CKA_EXTRACTABLE,
+	SKS_CKA_WRAP_WITH_TRUSTED, SKS_CKA_TRUSTED,
+};
+static const uint32_t pkcs11_symm_key_optional[] = {
+	SKS_CKA_WRAP_TEMPLATE, SKS_CKA_UNWRAP_TEMPLATE, SKS_CKA_DERIVE_TEMPLATE,
+	SKS_CKA_VALUE, SKS_CKA_VALUE_LEN,
+};
+/* PKCS#11 specification for any asymmetric public key (+pkcs11_any_key_xxx) */
+static const uint32_t pkcs11_public_key_boolprops[] = {
+	SKS_CKA_ENCRYPT, SKS_CKA_VERIFY, SKS_CKA_VERIFY_RECOVER, SKS_CKA_WRAP,
+	SKS_CKA_TRUSTED,
+};
+static const uint32_t pkcs11_public_key_mandated[] = {
+	SKS_CKA_SUBJECT
+};
+static const uint32_t pkcs11_public_key_optional[] = {
+	SKS_CKA_WRAP_TEMPLATE, SKS_CKA_PUBLIC_KEY_INFO,
+};
+/* PKCS#11 specification for any asymmetric private key (+pkcs11_any_key_xxx) */
+static const uint32_t pkcs11_private_key_boolprops[] = {
+	SKS_CKA_DECRYPT, SKS_CKA_SIGN, SKS_CKA_SIGN_RECOVER,
+	SKS_CKA_UNWRAP,
+	SKS_CKA_SENSITIVE, SKS_CKA_EXTRACTABLE,
+	SKS_CKA_WRAP_WITH_TRUSTED, SKS_CKA_ALWAYS_AUTHENTICATE,
+};
+static const uint32_t pkcs11_private_key_mandated[] = {
+	SKS_CKA_SUBJECT
+};
+static const uint32_t pkcs11_private_key_optional[] = {
+	SKS_CKA_UNWRAP_TEMPLATE, SKS_CKA_PUBLIC_KEY_INFO,
+};
+/* PKCS#11 specification for any RSA key (+pkcs11_public/private_key_xxx) */
+static const uint32_t pkcs11_rsa_public_key_mandated[] = {
+	SKS_CKA_MODULUS_BITS,
+};
+static const uint32_t pkcs11_rsa_public_key_optional[] = {
+	SKS_CKA_MODULUS, SKS_CKA_PUBLIC_EXPONENT,
+};
+static const uint32_t pkcs11_rsa_private_key_optional[] = {
+	SKS_CKA_MODULUS, SKS_CKA_PUBLIC_EXPONENT, SKS_CKA_PRIVATE_EXPONENT,
+	SKS_CKA_PRIME_1, SKS_CKA_PRIME_2,
+	SKS_CKA_EXPONENT_1, SKS_CKA_EXPONENT_2,	SKS_CKA_COEFFICIENT,
+};
+/* PKCS#11 specification for any EC key (+pkcs11_public/private_key_xxx) */
+static const uint32_t pkcs11_ec_public_key_mandated[] = {
+	SKS_CKA_EC_PARAMS,
+};
+static const uint32_t pkcs11_ec_public_key_optional[] = {
+	SKS_CKA_EC_POINT,
+};
+static const uint32_t pkcs11_ec_private_key_mandated[] = {
+	SKS_CKA_EC_PARAMS,
+};
+static const uint32_t pkcs11_ec_private_key_optional[] = {
+	SKS_CKA_VALUE, SKS_CKA_EC_POINT,
+};
+/* PKCS#11 specification for certificate (+pkcs11_any_object_xxx) */
+static const uint32_t pkcs11_cert_boolprops[] = {
+	SKS_CKA_TRUSTED,
+};
+static const uint32_t pkcs11_cert_mandated[] = {
+	SKS_CKA_CERTIFICATE_CATEGORY,
+};
+static const uint32_t pkcs11_cert_optional[] = {
+	SKS_CKA_START_DATE, SKS_CKA_END_DATE,
+	SKS_CKA_PUBLIC_KEY_INFO,
+};
+static const uint32_t pkcs11_cert_x509_mandated[] = {
+	SKS_CKA_SUBJECT,
+};
+static const uint32_t pkcs11_cert_x509_optional[] = {
+	SKS_CKA_ID, SKS_CKA_ISSUER, SKS_CKA_SERIAL_NUMBER,
+	SKS_CKA_VALUE, SKS_CKA_URL,
+	SKS_CKA_HASH_OF_SUBJECT_PUBLIC_KEY,
+	SKS_CKA_HASH_OF_ISSUER_PUBLIC_KEY,
+	SKS_CKA_NAME_HASH_ALGORITHM,
+};
+
+static uint32_t create_pkcs11_storage_attributes(struct sks_attrs_head **out,
+						 struct sks_attrs_head *temp)
+{
+	uint32_t const *boolprops = &pkcs11_any_object_boolprops[0];
+	uint32_t const *mandated = &pkcs11_any_object_mandated[0];
+	size_t boolprops_count = ARRAY_SIZE(pkcs11_any_object_boolprops);
+	size_t mandated_count = ARRAY_SIZE(pkcs11_any_object_mandated);
+	uint32_t class = 0;
+	uint32_t rv = 0;
+
+	init_attributes_head(out);
+#ifdef SKS_SHEAD_WITH_BOOLPROPS
+	set_attributes_in_head(*out);
+#endif
+
+	/* Object class is mandatory */
+	class = get_class(temp);
+	if (class == SKS_UNDEFINED_ID) {
+		EMSG("Class attribute not found");
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+	rv = add_attribute(out, SKS_CKA_CLASS, &class, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = set_mandatory_boolprops(out, temp, boolprops, boolprops_count);
+	if (rv)
+		return rv;
+
+	return set_mandatory_attributes(out, temp, mandated, mandated_count);
+}
+
+static uint32_t create_pkcs11_genkey_attributes(struct sks_attrs_head **out,
+						struct sks_attrs_head *temp)
+{
+	uint32_t const *boolprops = &pkcs11_any_key_boolprops[0];
+	uint32_t const *optional = &pkcs11_any_key_optional[0];
+	size_t boolprops_count = ARRAY_SIZE(pkcs11_any_key_boolprops);
+	size_t optional_count = ARRAY_SIZE(pkcs11_any_key_optional);
+	uint32_t type = 0;
+	uint32_t rv = 0;
+
+	rv = create_pkcs11_storage_attributes(out, temp);
+	if (rv)
+		return rv;
+
+	type = get_type(temp);
+	if (type == SKS_UNDEFINED_ID) {
+		EMSG("Key type attribute not found");
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+	rv = add_attribute(out, SKS_CKA_KEY_TYPE, &type, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = set_mandatory_boolprops(out, temp, boolprops, boolprops_count);
+	if (rv)
+		return rv;
+
+	return set_optional_attributes(out, temp, optional, optional_count);
+}
+
+static uint32_t create_pkcs11_symm_key_attributes(struct sks_attrs_head **out,
+						  struct sks_attrs_head *temp)
+{
+	uint32_t const *boolprops = &pkcs11_symm_key_boolprops[0];
+	uint32_t const *optional = &pkcs11_symm_key_optional[0];
+	size_t boolprops_count = ARRAY_SIZE(pkcs11_symm_key_boolprops);
+	size_t optional_count = ARRAY_SIZE(pkcs11_symm_key_optional);
+	uint32_t rv = 0;
+
+	assert(get_class(temp) == SKS_CKO_SECRET_KEY);
+
+	rv = create_pkcs11_genkey_attributes(out, temp);
+	if (rv)
+		return rv;
+
+	assert(get_class(*out) == SKS_CKO_SECRET_KEY);
+
+	switch (get_type(*out)) {
+	case SKS_CKK_GENERIC_SECRET:
+	case SKS_CKK_AES:
+	case SKS_CKK_MD5_HMAC:
+	case SKS_CKK_SHA_1_HMAC:
+	case SKS_CKK_SHA256_HMAC:
+	case SKS_CKK_SHA384_HMAC:
+	case SKS_CKK_SHA512_HMAC:
+	case SKS_CKK_SHA224_HMAC:
+		break;
+	default:
+		EMSG("Invalid key type (0x%" PRIx32 ", %s)",
+			get_type(*out), sks2str_key_type(get_type(*out)));
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	rv = set_mandatory_boolprops(out, temp, boolprops, boolprops_count);
+	if (rv)
+		return rv;
+
+	return set_optional_attributes(out, temp, optional, optional_count);
+}
+
+static uint32_t create_pkcs11_data_attributes(struct sks_attrs_head **out,
+					      struct sks_attrs_head *temp)
+{
+	uint32_t rv = 0;
+
+	assert(get_class(temp) == SKS_CKO_DATA);
+
+	rv = create_pkcs11_storage_attributes(out, temp);
+	if (rv)
+		return rv;
+
+	assert(get_class(*out) == SKS_CKO_DATA);
+
+	rv = set_optional_attributes(out, temp,
+				     &pkcs11_raw_data_optional[0],
+				     ARRAY_SIZE(pkcs11_raw_data_optional));
+
+	return rv;
+}
+
+static uint32_t create_pkcs11_pub_key_attributes(struct sks_attrs_head **out,
+						 struct sks_attrs_head *temp)
+{
+	uint32_t rv = 0;
+	uint32_t const *boolprops = &pkcs11_public_key_boolprops[0];
+	uint32_t const *mandated = &pkcs11_public_key_mandated[0];
+	uint32_t const *optional = &pkcs11_public_key_optional[0];
+	size_t boolprops_count = ARRAY_SIZE(pkcs11_public_key_boolprops);
+	size_t mandated_count = ARRAY_SIZE(pkcs11_public_key_mandated);
+	size_t optional_count = ARRAY_SIZE(pkcs11_public_key_optional);
+
+	assert(get_class(temp) == SKS_CKO_PUBLIC_KEY);
+
+	rv = create_pkcs11_genkey_attributes(out, temp);
+	if (rv)
+		return rv;
+
+	assert(get_class(*out) == SKS_CKO_PUBLIC_KEY);
+
+	rv = set_mandatory_boolprops(out, temp, boolprops, boolprops_count);
+	if (rv)
+		return rv;
+
+	rv = set_mandatory_attributes(out, temp, mandated, mandated_count);
+	if (rv)
+		return rv;
+
+	rv = set_optional_attributes(out, temp, optional, optional_count);
+	if (rv)
+		return rv;
+
+	switch (get_type(*out)) {
+	case SKS_CKK_RSA:
+		boolprops = NULL;
+		mandated = &pkcs11_rsa_public_key_mandated[0];
+		optional = &pkcs11_rsa_public_key_optional[0];
+		boolprops_count = 0;
+		mandated_count = ARRAY_SIZE(pkcs11_rsa_public_key_mandated);
+		optional_count = ARRAY_SIZE(pkcs11_rsa_public_key_optional);
+		break;
+	case SKS_CKK_EC:
+		boolprops = NULL;
+		mandated = &pkcs11_ec_public_key_mandated[0];
+		optional = &pkcs11_ec_public_key_optional[0];
+		boolprops_count = 0;
+		mandated_count = ARRAY_SIZE(pkcs11_ec_public_key_mandated);
+		optional_count = ARRAY_SIZE(pkcs11_ec_public_key_optional);
+		break;
+	default:
+		EMSG("Invalid key type (0x%" PRIx32 ", %s)",
+			get_type(*out), sks2str_key_type(get_type(*out)));
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	rv = set_mandatory_boolprops(out, temp, boolprops, boolprops_count);
+	if (rv)
+		return rv;
+
+	rv = set_mandatory_attributes(out, temp, mandated, mandated_count);
+	if (rv)
+		return rv;
+
+	return set_optional_attributes(out, temp, optional, optional_count);
+}
+
+static uint32_t create_pkcs11_priv_key_attributes(struct sks_attrs_head **out,
+						  struct sks_attrs_head *temp)
+{
+	uint32_t const *boolprops = &pkcs11_private_key_boolprops[0];
+	uint32_t const *mandated = &pkcs11_private_key_mandated[0];
+	uint32_t const *optional = &pkcs11_private_key_optional[0];
+	size_t boolprops_count = ARRAY_SIZE(pkcs11_private_key_boolprops);
+	size_t mandated_count = ARRAY_SIZE(pkcs11_private_key_mandated);
+	size_t optional_count = ARRAY_SIZE(pkcs11_private_key_optional);
+	uint32_t rv = 0;
+
+	assert(get_class(temp) == SKS_CKO_PRIVATE_KEY);
+
+	rv = create_pkcs11_genkey_attributes(out, temp);
+	if (rv)
+		return rv;
+
+	assert(get_class(*out) == SKS_CKO_PRIVATE_KEY);
+
+	rv = set_mandatory_boolprops(out, temp, boolprops, boolprops_count);
+	if (rv)
+		return rv;
+
+	rv = set_mandatory_attributes(out, temp, mandated, mandated_count);
+	if (rv)
+		return rv;
+
+	rv = set_optional_attributes(out, temp, optional, optional_count);
+	if (rv)
+		return rv;
+
+	switch (get_type(*out)) {
+	case SKS_CKK_RSA:
+		boolprops = NULL;
+		mandated = NULL;
+		optional = &pkcs11_rsa_private_key_optional[0];
+		boolprops_count = 0;
+		mandated_count = 0;
+		optional_count = ARRAY_SIZE(pkcs11_rsa_private_key_optional);
+		break;
+	case SKS_CKK_EC:
+		boolprops = NULL;
+		mandated = &pkcs11_ec_private_key_mandated[0];
+		optional = &pkcs11_ec_private_key_optional[0];
+		boolprops_count = 0;
+		mandated_count = ARRAY_SIZE(pkcs11_ec_private_key_mandated);
+		optional_count = ARRAY_SIZE(pkcs11_ec_private_key_optional);
+		break;
+	default:
+		EMSG("Invalid key type (0x%" PRIx32 ", %s)",
+			get_type(*out), sks2str_key_type(get_type(*out)));
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	rv = set_mandatory_boolprops(out, temp, boolprops, boolprops_count);
+	if (rv)
+		return rv;
+
+	rv = set_mandatory_attributes(out, temp, mandated, mandated_count);
+	if (rv)
+		return rv;
+
+	return set_optional_attributes(out, temp, optional, optional_count);
+}
+
+static uint32_t create_pkcs11_cert_attributes(struct sks_attrs_head **out,
+					       struct sks_attrs_head *temp)
+{
+	uint32_t const *boolprops = &pkcs11_cert_boolprops[0];
+	uint32_t const *mandated = &pkcs11_cert_mandated[0];
+	uint32_t const *optional = &pkcs11_cert_optional[0];
+	size_t boolprops_count = ARRAY_SIZE(pkcs11_cert_boolprops);
+	size_t mandated_count = ARRAY_SIZE(pkcs11_cert_mandated);
+	size_t optional_count = ARRAY_SIZE(pkcs11_cert_optional);
+	uint32_t type = 0;
+	size_t size = 0;
+	void *value = NULL;
+	uint32_t rv = 0;
+
+	assert(get_class(temp) == SKS_CKO_CERTIFICATE);
+
+	rv = create_pkcs11_storage_attributes(out, temp);
+	if (rv)
+		return rv;
+
+	rv = set_mandatory_boolprops(out, temp, boolprops, boolprops_count);
+	if (rv)
+		return rv;
+
+	rv = set_mandatory_attributes(out, temp, mandated, mandated_count);
+	if (rv)
+		return rv;
+
+	rv = set_optional_attributes(out, temp, optional, optional_count);
+	if (rv)
+		return rv;
+
+	type = get_type(temp);
+	switch (type) {
+	case SKS_CKC_X_509:
+		mandated = &pkcs11_cert_x509_mandated[0];
+		optional = &pkcs11_cert_x509_optional[0];
+		mandated_count = ARRAY_SIZE(pkcs11_cert_x509_mandated);
+		optional_count = ARRAY_SIZE(pkcs11_cert_x509_optional);
+
+		rv = get_attribute_ptr(temp, SKS_CKA_URL, &value, &size);
+		if (rv || !size) {
+			/* CKA_URL not available */
+			rv = get_attribute_ptr(temp, SKS_CKA_VALUE,
+					&value, &size);
+			if (rv || !size) {
+				EMSG("CKA_VALUE must be non-empty");
+				return SKS_CKR_TEMPLATE_INCONSISTENT;
+			}
+		} else {
+			/* CKA_URL available, check for hashes */
+			rv = get_attribute_ptr(temp,
+					SKS_CKA_HASH_OF_SUBJECT_PUBLIC_KEY,
+					&value, &size);
+			if (rv || !size) {
+				EMSG("CKA_HASH_OF_SUBJECT_PUBLIC_KEY empty");
+				return SKS_CKR_TEMPLATE_INCONSISTENT;
+			}
+			rv = get_attribute_ptr(temp,
+					SKS_CKA_HASH_OF_ISSUER_PUBLIC_KEY,
+					&value, &size);
+			if (rv || !size) {
+				EMSG("CKA_HASH_OF_ISSUER_PUBLIC_KEY empty");
+				return SKS_CKR_TEMPLATE_INCONSISTENT;
+			}
+		}
+		break;
+	default:
+		EMSG("Invalid certificate type (0x%" PRIx32 ", %s)",
+				type, sks2str_certificate_type(type));
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	rv = add_attribute(out, SKS_CKA_CERTIFICATE_TYPE,
+			   &type, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	/* TODO: CKA_CHECK_VALUE */
+	/* TODO: CKA_PUBLIC_KEY_INFO */
+
+	rv = set_mandatory_attributes(out, temp, mandated, mandated_count);
+	if (rv)
+		return rv;
+
+	return set_optional_attributes(out, temp, optional, optional_count);
+}
+
+/*
+ * Create an attribute list for a new object from a template and a parent
+ * object (optional) for an object generation function (generate, copy,
+ * derive...).
+ *
+ * PKCS#11 directves on the supplied template:
+ * - template has aninvalid attribute ID: return ATTRIBUTE_TYPE_INVALID
+ * - template has an invalid value for an attribute: return ATTRIBUTE_VALID_INVALID
+ * - template has value for a read-only attribute: retrun ATTRIBUTE_READ_ONLY
+ * - template+default+parent => still miss an attribute: return TEMPLATE_INCONSISTENT
+ *
+ * INFO on SKS_CMD_COPY_OBJECT:
+ * - parent SKS_CKA_COPYIABLE=false => return ACTION_PROHIBITED.
+ * - template can specify SKS_CKA_TOKEN, SKS_CKA_PRIVATE, SKS_CKA_MODIFIABLE,
+ *   SKS_CKA_DESTROYABLE.
+ * - SENSITIVE can change from flase to true, not from true to false.
+ * - LOCAL is the parent LOCAL
+ */
+uint32_t create_attributes_from_template(struct sks_attrs_head **out,
+					 void *template, size_t template_size,
+					 uint32_t proc_id,
+					 struct sks_attrs_head *parent,
+					 enum processing_func function)
+{
+	struct sks_attrs_head *temp = NULL;
+	struct sks_attrs_head *attrs = NULL;
+	uint32_t rv = 0;
+	uint32_t key_gen_m = 0;
+	uint8_t local = 0;
+	uint8_t always_sensitive = 0;
+	uint8_t never_extract = 0;
+	uint32_t class = SKS_UNDEFINED_ID;
+	uint32_t type = SKS_UNDEFINED_ID;
+
+#ifdef DEBUG	/* Sanity: check function argument */
+	trace_attributes_from_api_head("template", template, template_size);
+	switch (function) {
+	case SKS_FUNCTION_GENERATE:
+	case SKS_FUNCTION_GENERATE_PAIR:
+	case SKS_FUNCTION_IMPORT:
+		break;
+	case SKS_FUNCTION_DERIVE:
+		trace_attributes("parent", parent);
+		break;
+	default:
+		TEE_Panic(TEE_ERROR_NOT_SUPPORTED);
+	}
+#endif
+
+	rv = sanitize_client_object(&temp, template, template_size);
+	if (rv)
+		goto bail;
+
+	/* If class/type not defined, match from mechanism */
+	if (get_class(temp) == SKS_UNDEFINED_ID &&
+			get_type(temp) == SKS_UNDEFINED_ID) {
+		switch (proc_id) {
+		case SKS_CKM_GENERIC_SECRET_KEY_GEN:
+			class = SKS_CKO_SECRET_KEY;
+			type = SKS_CKK_GENERIC_SECRET;
+			break;
+		case SKS_CKM_AES_KEY_GEN:
+			class = SKS_CKO_SECRET_KEY;
+			type = SKS_CKK_AES;
+			break;
+		case SKS_CKM_EC_KEY_PAIR_GEN:
+			type = SKS_CKK_DH;
+			break;
+		case SKS_CKM_RSA_PKCS_KEY_PAIR_GEN:
+			type = SKS_CKK_RSA;
+			break;
+		default:
+			EMSG("Unable to define class/type from mechanism");
+			rv = SKS_CKR_TEMPLATE_INCOMPLETE;
+			goto bail;
+		}
+		if (class != SKS_UNDEFINED_ID)
+			add_attribute(&temp, SKS_CKA_CLASS,
+						&class, sizeof(uint32_t));
+		if (type != SKS_UNDEFINED_ID)
+			add_attribute(&temp, SKS_CKA_KEY_TYPE,
+						&type, sizeof(uint32_t));
+	}
+
+	if (!sanitize_consistent_class_and_type(temp)) {
+		EMSG("inconsistent class/type");
+		rv = SKS_CKR_TEMPLATE_INCONSISTENT;
+		goto bail;
+	}
+	switch (get_class(temp)) {
+	case SKS_CKO_DATA:
+		rv = create_pkcs11_data_attributes(&attrs, temp);
+		break;
+	case SKS_CKO_SECRET_KEY:
+		rv = create_pkcs11_symm_key_attributes(&attrs, temp);
+		break;
+	case SKS_CKO_PUBLIC_KEY:
+		rv = create_pkcs11_pub_key_attributes(&attrs, temp);
+		break;
+	case SKS_CKO_PRIVATE_KEY:
+		rv = create_pkcs11_priv_key_attributes(&attrs, temp);
+		break;
+	case SKS_CKO_CERTIFICATE:
+		rv = create_pkcs11_cert_attributes(&attrs, temp);
+		break;
+	default:
+		DMSG("Invalid object class 0x%" PRIx32 "/%s",
+			get_class(temp), sks2str_class(get_class(temp)));
+		rv = SKS_CKR_TEMPLATE_INCONSISTENT;
+		break;
+	}
+	if (rv)
+		goto bail;
+
+	switch (get_class(attrs)) {
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+	case SKS_CKO_PUBLIC_KEY:
+		assert(get_attribute(attrs, SKS_CKA_LOCAL, NULL, NULL) ==
+			SKS_NOT_FOUND);
+
+		local = SKS_FALSE;
+		always_sensitive = SKS_FALSE;
+		never_extract = SKS_FALSE;
+
+		switch (function) {
+		case SKS_FUNCTION_GENERATE:
+			always_sensitive = get_bool(attrs, SKS_CKA_SENSITIVE);
+			never_extract = !get_bool(attrs, SKS_CKA_EXTRACTABLE);
+			local = SKS_TRUE;
+			break;
+		case SKS_FUNCTION_GENERATE_PAIR:
+			local = SKS_TRUE;
+			break;
+		case SKS_FUNCTION_DERIVE:
+			always_sensitive =
+				get_bool(parent, SKS_CKA_ALWAYS_SENSITIVE) &&
+				get_bool(attrs, SKS_CKA_SENSITIVE);
+			never_extract =
+				get_bool(parent, SKS_CKA_NEVER_EXTRACTABLE) &&
+				!get_bool(attrs, SKS_CKA_EXTRACTABLE);
+			break;
+		case SKS_FUNCTION_COPY:
+			always_sensitive =
+				get_bool(parent, SKS_CKA_ALWAYS_SENSITIVE) &&
+				get_bool(attrs, SKS_CKA_SENSITIVE);
+			never_extract =
+				get_bool(parent, SKS_CKA_NEVER_EXTRACTABLE) &&
+				!get_bool(attrs, SKS_CKA_EXTRACTABLE);
+			local = get_bool(parent, SKS_CKA_LOCAL);
+			break;
+		default:
+			break;
+		}
+
+		rv = add_attribute(&attrs, SKS_CKA_LOCAL,
+				   &local, sizeof(local));
+		if (rv)
+			goto bail;
+
+		/* TODO: Set valid key gen mechanism when local */
+		if (local == SKS_FALSE) {
+			key_gen_m = SKS_UNAVAILABLE_INFORMATION;
+			rv = add_attribute(&attrs, SKS_CKA_KEY_GEN_MECHANISM,
+					&key_gen_m, sizeof(key_gen_m));
+			if (rv)
+				goto bail;
+		}
+
+		rv = add_attribute(&attrs, SKS_CKA_ALWAYS_SENSITIVE,
+				   &always_sensitive, sizeof(always_sensitive));
+		if (rv)
+			goto bail;
+
+		rv = add_attribute(&attrs, SKS_CKA_NEVER_EXTRACTABLE,
+				   &never_extract, sizeof(never_extract));
+		if (rv)
+			goto bail;
+
+		break;
+
+	default:
+		break;
+	}
+
+	*out = attrs;
+
+#ifdef DEBUG
+	trace_attributes("object", attrs);
+#endif
+
+bail:
+	TEE_Free(temp);
+	if (rv)
+		TEE_Free(attrs);
+
+	return rv;
+}
+
+static uint32_t check_attrs_misc_integrity(struct sks_attrs_head *head)
+{
+	/* FIXME: is it useful? */
+	if (get_bool(head, SKS_CKA_NEVER_EXTRACTABLE) &&
+	    get_bool(head, SKS_CKA_EXTRACTABLE)) {
+		DMSG("Never/Extractable attributes mismatch %d/%d",
+			get_bool(head, SKS_CKA_NEVER_EXTRACTABLE),
+			get_bool(head, SKS_CKA_EXTRACTABLE));
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	if (get_bool(head, SKS_CKA_ALWAYS_SENSITIVE) &&
+	    !get_bool(head, SKS_CKA_SENSITIVE)) {
+		DMSG("Sensitive/always attributes mismatch %d/%d",
+			get_bool(head, SKS_CKA_SENSITIVE),
+			get_bool(head, SKS_CKA_ALWAYS_SENSITIVE));
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	return SKS_OK;
+}
+
+/*
+ * Check access to object against authentication to token
+ */
+uint32_t check_access_attrs_against_token(struct pkcs11_session *session,
+					  struct sks_attrs_head *head)
+{
+	bool private = true;
+
+	switch(get_class(head)) {
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_CERTIFICATE:
+	case SKS_CKO_DATA:
+		if (!get_bool(head, SKS_CKA_PRIVATE))
+			private = false;
+		break;
+	case SKS_CKO_PRIVATE_KEY:
+		break;
+	default:
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+
+	if (private && pkcs11_session_is_public(session)) {
+		DMSG("Private object access from a public session");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+
+	/*
+	 * TODO: START_DATE and END_DATE: complies with current time?
+	 */
+	return SKS_OK;
+}
+
+/*
+ * Check the attributes of a to-be-created object matches the token state
+ */
+uint32_t check_created_attrs_against_token(struct pkcs11_session *session,
+					   struct sks_attrs_head *head)
+{
+	uint32_t rc = 0;
+
+	rc = check_attrs_misc_integrity(head);
+	if (rc)
+		return rc;
+
+	if (get_bool(head, SKS_CKA_TRUSTED) &&
+	    !pkcs11_session_is_security_officer(session)) {
+		DMSG("Can't create trusted object");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+
+	if (get_bool(head, SKS_CKA_TOKEN) &&
+	    !pkcs11_session_is_read_write(session)) {
+		DMSG("Can't create persistent object");
+		return SKS_CKR_SESSION_READ_ONLY;
+	}
+
+	/*
+	 * TODO: START_DATE and END_DATE: complies with current time?
+	 */
+	return SKS_OK;
+}
+
+/*
+ * Check the attributes of new secret match the requirements of the parent key.
+ */
+uint32_t check_created_attrs_against_parent_key(
+					uint32_t proc_id __unused,
+					struct sks_attrs_head *parent __unused,
+					struct sks_attrs_head *head __unused)
+{
+	/*
+	 * TODO
+	 * Depends on the processing/mechanism used.
+	 * Wrapping: check head vs parent key WRAP_TEMPLATE attribute.
+	 * Unwrapping: check head vs parent key UNWRAP_TEMPLATE attribute.
+	 * Derive: check head vs parent key DERIVE_TEMPLATE attribute (late comer?).
+	 */
+	return SKS_ERROR;
+}
+
+#define DMSG_BAD_BBOOL(attr, proc, head) \
+	do {	\
+		uint8_t __maybe_unused bvalue = 0;		\
+								\
+		DMSG("%s issue for %s: %sfound, value %d",	\
+			sks2str_attr(attr),			\
+			sks2str_proc(proc),			\
+			get_attribute(head, attr, &bvalue, NULL) ? \
+			"not " : "",				\
+			bvalue);				\
+	} while (0)
+
+/*
+ * Check the attributes of a new secret match the processing/mechanism
+ * used to create it.
+ *
+ * @proc_id - SKS_CKM__xxx
+ * @subproc_id - boolean attribute id as encrypt/decrypt/sign/verify,
+ *		 if applicable to proc_id.
+ * @head - head of the attributes of the to-be-created object.
+ */
+uint32_t check_created_attrs_against_processing(uint32_t proc_id,
+						struct sks_attrs_head *head)
+{
+	uint8_t bbool = 0;
+
+	/*
+	 * Processings that do not create secrets are not expected to call
+	 * this function which would panic.
+	 */
+	/*
+	 * FIXME: rellay need to check LOCAL here, it was safely set from
+	 * create_attributes_from_template().
+	 */
+	switch (proc_id) {
+	case SKS_PROCESSING_IMPORT:
+	case SKS_CKM_ECDH1_DERIVE:
+	case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+	case SKS_CKM_DH_PKCS_DERIVE:
+		if (get_class(head) != SKS_CKO_CERTIFICATE &&
+		    get_class(head) != SKS_CKO_DATA &&
+		    (get_attribute(head, SKS_CKA_LOCAL, &bbool, NULL) ||
+		    bbool)) {
+			DMSG_BAD_BBOOL(SKS_CKA_LOCAL, proc_id, head);
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		}
+		break;
+	case SKS_CKM_GENERIC_SECRET_KEY_GEN:
+	case SKS_CKM_AES_KEY_GEN:
+	case SKS_CKM_EC_KEY_PAIR_GEN:
+	case SKS_CKM_RSA_PKCS_KEY_PAIR_GEN:
+		if (get_attribute(head, SKS_CKA_LOCAL, &bbool, NULL) ||
+		    !bbool) {
+			DMSG_BAD_BBOOL(SKS_CKA_LOCAL, proc_id, head);
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		}
+		break;
+	default:
+		TEE_Panic(proc_id);
+		break;
+	}
+
+	switch (proc_id) {
+	case SKS_CKM_GENERIC_SECRET_KEY_GEN:
+		if (get_type(head) != SKS_CKK_GENERIC_SECRET)
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		break;
+	case SKS_CKM_AES_KEY_GEN:
+		if (get_type(head) != SKS_CKK_AES)
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		break;
+	case SKS_CKM_EC_KEY_PAIR_GEN:
+		if (get_type(head) != SKS_CKK_EC)
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		break;
+	case SKS_CKM_RSA_PKCS_KEY_PAIR_GEN:
+		if (get_type(head) != SKS_CKK_RSA)
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		break;
+	case SKS_CKM_ECDH1_DERIVE:
+	case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+	case SKS_CKM_DH_PKCS_DERIVE:
+		if (get_class(head) != SKS_CKO_SECRET_KEY)
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		break;
+	case SKS_PROCESSING_IMPORT:
+	default:
+		break;
+	}
+
+	return SKS_OK;
+}
+
+void pkcs11_max_min_key_size(uint32_t key_type, uint32_t *max_key_size,
+			     uint32_t *min_key_size, bool bit_size_only)
+{
+	uint32_t mult = bit_size_only ? 8 : 1;
+
+	switch (key_type) {
+	case SKS_CKK_GENERIC_SECRET:
+		*min_key_size = 1;	/* in bits */
+		*max_key_size = 4096;	/* in bits */
+		break;
+	case SKS_CKK_MD5_HMAC:
+		*min_key_size = 16 * mult;
+		*max_key_size = 16 * mult;
+		break;
+	case SKS_CKK_SHA_1_HMAC:
+		*min_key_size = 20 * mult;
+		*max_key_size = 20 * mult;
+		break;
+	case SKS_CKK_SHA224_HMAC:
+		*min_key_size = 28 * mult;
+		*max_key_size = 28 * mult;
+		break;
+	case SKS_CKK_SHA256_HMAC:
+		*min_key_size = 32 * mult;
+		*max_key_size = 32 * mult;
+		break;
+	case SKS_CKK_SHA384_HMAC:
+		*min_key_size = 48 * mult;
+		*max_key_size = 48 * mult;
+		break;
+	case SKS_CKK_SHA512_HMAC:
+		*min_key_size = 64 * mult;
+		*max_key_size = 64 * mult;
+		break;
+	case SKS_CKK_AES:
+		*min_key_size = 16 * mult;
+		*max_key_size = 32 * mult;
+		break;
+	case SKS_CKK_EC:
+		*min_key_size = 192;	/* in bits */
+		*max_key_size = 521;	/* in bits */
+		break;
+	case SKS_CKK_RSA:
+	case SKS_CKK_DSA:
+	case SKS_CKK_DH:
+		*min_key_size = 256;	/* in bits */
+		*max_key_size = 4096;	/* in bits */
+		break;
+	default:
+		TEE_Panic(key_type);
+		break;
+	}
+}
+
+uint32_t check_created_attrs(struct sks_attrs_head *key1,
+			     struct sks_attrs_head *key2)
+{
+	struct sks_attrs_head *secret = NULL;
+	struct sks_attrs_head *private = NULL;
+	struct sks_attrs_head *public = NULL;
+	uint32_t max_key_size = 0;
+	uint32_t min_key_size = 0;
+	uint32_t key_length = 0;
+	uint32_t rv = 0;
+
+	switch (get_class(key1)) {
+	case SKS_CKO_SECRET_KEY:
+		secret = key1;
+		break;
+	case SKS_CKO_PUBLIC_KEY:
+		public = key1;
+		break;
+	case SKS_CKO_PRIVATE_KEY:
+		private = key1;
+		break;
+	default:
+		return SKS_CKR_ATTRIBUTE_VALUE_INVALID;
+	}
+
+	if (key2) {
+		switch (get_class(key2)) {
+		case SKS_CKO_PUBLIC_KEY:
+			public = key2;
+			if (private == key1)
+				break;
+
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		case SKS_CKO_PRIVATE_KEY:
+			private = key2;
+			if (public == key1)
+				break;
+
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		default:
+			return SKS_CKR_ATTRIBUTE_VALUE_INVALID;
+		}
+
+		if (get_type(private) != get_type(public))
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	if (secret) {
+		switch (get_type(secret)) {
+		case SKS_CKK_AES:
+		case SKS_CKK_GENERIC_SECRET:
+		case SKS_CKK_MD5_HMAC:
+		case SKS_CKK_SHA_1_HMAC:
+		case SKS_CKK_SHA224_HMAC:
+		case SKS_CKK_SHA256_HMAC:
+		case SKS_CKK_SHA384_HMAC:
+		case SKS_CKK_SHA512_HMAC:
+			break;
+		default:
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		}
+
+		/* Get key size */
+		rv = get_u32_attribute(secret, SKS_CKA_VALUE_LEN, &key_length);
+		if (rv)
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+	if (public) {
+		switch (get_type(public)) {
+		case SKS_CKK_RSA:
+		case SKS_CKK_DSA:
+		case SKS_CKK_DH:
+			/* Get key size */
+			rv = get_u32_attribute(public, SKS_CKA_MODULUS_BITS,
+						&key_length);
+			if (rv)
+				return SKS_CKR_TEMPLATE_INCONSISTENT;
+			break;
+		case SKS_CKK_EC:
+			break;
+		default:
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		}
+	}
+	if (private) {
+		switch (get_type(private)) {
+		case SKS_CKK_RSA:
+		case SKS_CKK_DSA:
+		case SKS_CKK_DH:
+			/* Get key size, if key pair public carries bit size */
+			if (public)
+				break;
+
+			rv = get_u32_attribute(private, SKS_CKA_MODULUS_BITS,
+						&key_length);
+			if (rv)
+				return SKS_CKR_TEMPLATE_INCONSISTENT;
+			break;
+		case SKS_CKK_EC:
+			/* No need to get key size */
+			break;
+		default:
+			return SKS_CKR_TEMPLATE_INCONSISTENT;
+		}
+	}
+
+	/*
+	 * Check key size for symmetric keys and RSA keys
+	 * EC is bound to domains, no need to chekc here.
+	 */
+	switch (get_type(key1)) {
+	case SKS_CKK_EC:
+		return SKS_OK;
+	default:
+		break;
+	}
+
+	pkcs11_max_min_key_size(get_type(key1),
+				&max_key_size, &min_key_size, false);
+
+	if (key_length < min_key_size || key_length > max_key_size) {
+		EMSG("Length %" PRIu32 " vs range [%" PRIu32 " %" PRIu32 "]",
+			key_length, min_key_size, max_key_size);
+		return SKS_CKR_KEY_SIZE_RANGE;
+	}
+
+	return SKS_OK;
+}
+
+/* Check processing ID against attributre ALLOWED_PROCESSINGS if any */
+static bool parent_key_complies_allowed_processings(uint32_t proc_id,
+						    struct sks_attrs_head *head)
+{
+	char *attr = NULL;
+	size_t size = 0;
+	uint32_t proc = 0;
+	size_t count = 0;
+
+	/* Check only if restricted allowed mechanisms list is defined */
+	if (get_attribute_ptr(head, SKS_CKA_ALLOWED_MECHANISMS,
+			      (void *)&attr, &size) != SKS_OK) {
+		return true;
+	}
+
+	for (count = size / sizeof(uint32_t); count; count--) {
+		TEE_MemMove(&proc, attr, sizeof(uint32_t));
+		attr += sizeof(uint32_t);
+
+		if (proc == proc_id)
+			return true;
+	}
+
+	DMSG("can't find %s in allowed list", sks2str_proc(proc_id));
+	return false;
+}
+
+/*
+ * Check the attributes of the parent secret (key) used in the processing
+ * do match the target processing.
+ *
+ * @proc_id - SKS_CKM_xxx
+ * @subproc_id - boolean attribute encrypt or decrypt or sign or verify, if
+ *		 applicable to proc_id.
+ * @head - head of the attributes of parent object.
+ */
+uint32_t check_parent_attrs_against_processing(uint32_t proc_id,
+					       enum processing_func function,
+					       struct sks_attrs_head *head)
+{
+	uint32_t __maybe_unused rc = 0;
+	uint32_t key_class = get_class(head);
+	uint32_t key_type = get_type(head);
+
+	if (function == SKS_FUNCTION_ENCRYPT &&
+	    !get_bool(head, SKS_CKA_ENCRYPT)) {
+		DMSG("encrypt not permitted");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+	if (function == SKS_FUNCTION_DECRYPT &&
+	    !get_bool(head, SKS_CKA_DECRYPT)) {
+		DMSG("decrypt not permitted");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+	if (function == SKS_FUNCTION_SIGN &&
+	    !get_bool(head, SKS_CKA_SIGN)) {
+		DMSG("sign not permitted");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+	if (function == SKS_FUNCTION_VERIFY &&
+	    !get_bool(head, SKS_CKA_VERIFY)) {
+		DMSG("verify not permitted");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+	if (function == SKS_FUNCTION_WRAP &&
+	    !get_bool(head, SKS_CKA_WRAP)) {
+		DMSG("wrap not permitted");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+	if (function == SKS_FUNCTION_UNWRAP &&
+	    !get_bool(head, SKS_CKA_UNWRAP)) {
+		DMSG("unwrap not permitted");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+	if (function == SKS_FUNCTION_DERIVE &&
+	    !get_bool(head, SKS_CKA_DERIVE)) {
+		DMSG("derive not permitted");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+
+	/* Check processing complies for parent key family */
+	switch (proc_id) {
+	case SKS_CKM_AES_ECB:
+	case SKS_CKM_AES_CBC:
+	case SKS_CKM_AES_CBC_PAD:
+	case SKS_CKM_AES_CTS:
+	case SKS_CKM_AES_CTR:
+	case SKS_CKM_AES_GCM:
+	case SKS_CKM_AES_CCM:
+	case SKS_CKM_AES_CMAC:
+	case SKS_CKM_AES_CMAC_GENERAL:
+	case SKS_CKM_AES_XCBC_MAC:
+		if (key_class == SKS_CKO_SECRET_KEY &&
+		    key_type == SKS_CKK_AES)
+			break;
+
+		DMSG("%s invalid key %s/%s", sks2str_proc(proc_id),
+			sks2str_class(key_class), sks2str_key_type(key_type));
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+
+	case SKS_CKM_MD5_HMAC:
+	case SKS_CKM_SHA_1_HMAC:
+	case SKS_CKM_SHA224_HMAC:
+	case SKS_CKM_SHA256_HMAC:
+	case SKS_CKM_SHA384_HMAC:
+	case SKS_CKM_SHA512_HMAC:
+		if (key_class != SKS_CKO_SECRET_KEY)
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+
+		if (key_type == SKS_CKK_GENERIC_SECRET)
+			break;
+
+		switch (proc_id) {
+		case SKS_CKM_MD5_HMAC:
+			if (key_type == SKS_CKK_MD5_HMAC)
+				break;
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+
+		case SKS_CKM_SHA_1_HMAC:
+			if (key_type == SKS_CKK_SHA_1_HMAC)
+				break;
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+		case SKS_CKM_SHA224_HMAC:
+			if (key_type == SKS_CKK_SHA224_HMAC)
+				break;
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+		case SKS_CKM_SHA256_HMAC:
+			if (key_type == SKS_CKK_SHA256_HMAC)
+				break;
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+		case SKS_CKM_SHA384_HMAC:
+			if (key_type == SKS_CKK_SHA384_HMAC)
+				break;
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+		case SKS_CKM_SHA512_HMAC:
+			if (key_type == SKS_CKK_SHA512_HMAC)
+				break;
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+		default:
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+		}
+		break;
+
+	case SKS_CKM_ECDSA:
+	case SKS_CKM_ECDSA_SHA1:
+	case SKS_CKM_ECDSA_SHA224:
+	case SKS_CKM_ECDSA_SHA256:
+	case SKS_CKM_ECDSA_SHA384:
+	case SKS_CKM_ECDSA_SHA512:
+	case SKS_CKM_ECDH1_DERIVE:
+	case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+	case SKS_CKM_ECMQV_DERIVE:
+	case SKS_CKM_ECDH_AES_KEY_WRAP:
+		if (key_type != SKS_CKK_EC) {
+			EMSG("Invalid key %s for mechanism %s",
+				sks2str_type(key_type, key_class),
+				sks2str_proc(proc_id));
+			return SKS_CKR_KEY_TYPE_INCONSISTENT;
+		}
+		if (key_class != SKS_CKO_PUBLIC_KEY &&
+		     key_class != SKS_CKO_PRIVATE_KEY) {
+			EMSG("Invalid key class for mechanism %s",
+				sks2str_proc(proc_id));
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+		}
+		break;
+
+	case SKS_CKM_RSA_PKCS:
+	case SKS_CKM_RSA_9796:
+	case SKS_CKM_RSA_X_509:
+	case SKS_CKM_SHA1_RSA_PKCS:
+	case SKS_CKM_RSA_PKCS_OAEP:
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS:
+	case SKS_CKM_SHA384_RSA_PKCS:
+	case SKS_CKM_SHA512_RSA_PKCS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+	case SKS_CKM_RSA_AES_KEY_WRAP:
+		if (key_type != SKS_CKK_RSA) {
+			EMSG("Invalid key %s for mechanism %s",
+				sks2str_type(key_type, key_class),
+				sks2str_proc(proc_id));
+			return SKS_CKR_KEY_TYPE_INCONSISTENT;
+		}
+		if (key_class != SKS_CKO_PUBLIC_KEY &&
+		     key_class != SKS_CKO_PRIVATE_KEY) {
+			EMSG("Invalid key class for mechanism %s",
+				sks2str_proc(proc_id));
+			return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+		}
+		break;
+
+	default:
+		DMSG("Invalid processing 0x%" PRIx32 " (%s)", proc_id,
+			sks2str_proc(proc_id));
+		return SKS_CKR_MECHANISM_INVALID;
+	}
+
+	if (!parent_key_complies_allowed_processings(proc_id, head)) {
+		DMSG("Allowed mechanism failed");
+		return SKS_CKR_KEY_FUNCTION_NOT_PERMITTED;
+	}
+
+	return SKS_OK;
+}
+
+bool object_is_private(struct sks_attrs_head *head)
+{
+	if (get_class(head) == SKS_CKO_PRIVATE_KEY)
+		return true;
+
+	if (get_bool(head, SKS_CKA_PRIVATE))
+		return true;
+
+	return false;
+}
+
+/*
+ * Add a CKA ID attribute to an object or paired object if missing.
+ * If 2 objects are provided and at least 1 does not have a CKA_ID,
+ * the 2 objects will have the same CKA_ID attribute.
+ *
+ * @attrs1 - Object
+ * @attrs2 - Object paired to attrs1 or NULL
+ * Return an SKS return code
+ */
+uint32_t add_missing_attribute_id(struct sks_attrs_head **attrs1,
+				  struct sks_attrs_head **attrs2)
+{
+	uint32_t rv = 0;
+	void *id1 = NULL;
+	size_t id1_size = 0;
+	void *id2 = NULL;
+	size_t id2_size = 0;
+
+	rv = get_attribute_ptr(*attrs1, SKS_CKA_ID, &id1, &id1_size);
+	if (rv) {
+		if (rv != SKS_NOT_FOUND)
+			return rv;
+		id1 = NULL;
+	}
+
+	if (attrs2) {
+		rv = get_attribute_ptr(*attrs2, SKS_CKA_ID, &id2, &id2_size);
+		if (rv) {
+			if (rv != SKS_NOT_FOUND)
+				return rv;
+			id2 = NULL;
+		}
+
+		if (id1 && id2)
+			return SKS_OK;
+
+		if (id1 && !id2)
+			return add_attribute(attrs2, SKS_CKA_ID, id1, id1_size);
+
+		if (!id1 && id2)
+			return add_attribute(attrs1, SKS_CKA_ID, id2, id2_size);
+	} else {
+		if (id1)
+			return SKS_OK;
+	}
+
+	id1_size = SKS_CKA_DEFAULT_SIZE;
+	id1 = TEE_Malloc(id1_size, 0);
+	if (!id1)
+		return SKS_MEMORY;
+
+	TEE_GenerateRandom(id1, (uint32_t)id1_size);
+
+	rv = add_attribute(attrs1, SKS_CKA_ID, id1, id1_size);
+	if (rv == SKS_OK && attrs2)
+		rv = add_attribute(attrs2, SKS_CKA_ID, id1, id1_size);
+
+	TEE_Free(id1);
+
+	return rv;
+}
+
+bool attribute_is_exportable(struct sks_attribute_head *req_attr,
+			     struct sks_object *obj)
+{
+	uint8_t boolval = 0;
+	size_t boolsize = 0;
+	uint32_t rv = 0;
+
+	switch (req_attr->id) {
+	case SKS_CKA_PRIVATE_EXPONENT:
+	case SKS_CKA_PRIME_1:
+	case SKS_CKA_PRIME_2:
+	case SKS_CKA_EXPONENT_1:
+	case SKS_CKA_EXPONENT_2:
+	case SKS_CKA_COEFFICIENT:
+		boolsize = sizeof(boolval);
+		rv = get_attribute(obj->attributes, SKS_CKA_EXTRACTABLE,
+				   &boolval, &boolsize);
+		if (rv || boolval == SKS_FALSE)
+			return false;
+
+		boolsize = sizeof(boolval);
+		rv = get_attribute(obj->attributes, SKS_CKA_SENSITIVE,
+				   &boolval, &boolsize);
+		if (rv || boolval == SKS_TRUE)
+			return false;
+		break;
+	default:
+		break;
+	}
+
+	return true;
+}
diff --git a/ta/secure_key_services/src/pkcs11_attributes.h b/ta/secure_key_services/src/pkcs11_attributes.h
new file mode 100644
index 00000000..9c674cdf
--- /dev/null
+++ b/ta/secure_key_services/src/pkcs11_attributes.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __PKCS11_ATTRIBUTE_H
+#define __PKCS11_ATTRIBUTE_H
+
+#include <inttypes.h>
+
+#include "serializer.h"
+
+/*
+ * PKCS#11 directives on object attributes.
+ * Those with a '*' are optional, other must be defined, either by caller
+ * or by some known default value.
+ *
+ * [all] objects:	class
+ *
+ * [stored] objects:	persistent, need_authen, modifiable, copyable,
+ *			destroyable, label*.
+ *
+ * [data] objects:	[all], [stored], application_id*, object_id*, value.
+ *
+ * [key] objects:	[all], [stored], type, id*, start_date/end_date*,
+ *			derive, local, allowed_mechanisms*.
+ *
+ * [symm-key]:		[key], sensitive, encrypt, decrypt, sign, verify, wrap,
+ *			unwrap, extractable, wrap_with_trusted, trusted,
+ *			wrap_template, unwrap_template, derive_template.
+ */
+
+/*
+ * Utils to check compliance of attributes at various processing steps.
+ * Any rocessing operation is exclusively one of the following.
+ *
+ * Case 1: Create a secret from some local random value (C_CreateKey & friends)
+ * - client provides a attributs list template, pkcs11 complete with default
+ *   attribute values. Object is created if attributes are consistent and
+ *   comply token/session stte.
+ * - SKS sequence:
+ *   - check/set token/session state
+ *   - create a attribute list from client template and defualt values.
+ *   - check new secret attributes complies requested mechanism .
+ *   - check new secret attributes complies token/session state.
+ *   - Generate the value for the secret.
+ *   - Set some runtime attributes in the new secret.
+ *   - Register the new secret and return a handle for it.
+
+ *
+ * Case 2: Create a secret from a client clear data (C_CreateObject)
+ * - client provides a attributs list template, pkcs11 complete with default
+ *   attribute values. Object is created if attributes are consitent and
+ *   comply token/session state.
+ *   - check/set token/session state
+ *   - create a attribute list from client template and defualt values.
+ *   - check new secret attributes complies requested mechanism (raw-import).
+ *   - check new secret attributes complies token/session state.
+ *   - Set some runtime attributes in the new secret.
+ *   - Register the new secret and return a handle for it.
+
+ * Case 3: Use a secret for data processing
+ * - client provides a mechanism ID and the secret handle.
+ * - SKS checks mechanism and secret comply, if mechanism and token/session
+ *   state comply and last if secret and token/session state comply.
+ *   - check/set token/session state
+ *   - check secret's parent attributes complies requested processing.
+ *   - check secret's parent attributes complies token/session state.
+ *   - check new secret attributes complies secret's parent attributes.
+ *   - check new secret attributes complies requested mechanism.
+ *   - check new secret attributes complies token/session state.
+ *
+ * Case 4: Create a secret from a client template and a secret's parent
+ * (i.e derive a symmetric key)
+ * - client args: new-key template, mechanism ID, parent-key handle.
+ * - SKS create a new-key attribute list based on template + default values +
+ *   inheritance from the parent key attributes.
+ * - SKS checks:
+ *   - token/session state
+ *   - parent-key vs mechanism
+ *   - parent-key vs token/session state
+ *   - parent-key vs new-key
+ *   - new-key vs mechanism
+ *   - new-key vs token/session state
+ * - then do processing
+ * - then finalize object creation
+ */
+
+enum processing_func {
+	SKS_FUNCTION_DIGEST,
+	SKS_FUNCTION_GENERATE,
+	SKS_FUNCTION_GENERATE_PAIR,
+	SKS_FUNCTION_DERIVE,
+	SKS_FUNCTION_WRAP,
+	SKS_FUNCTION_UNWRAP,
+	SKS_FUNCTION_ENCRYPT,
+	SKS_FUNCTION_DECRYPT,
+	SKS_FUNCTION_SIGN,
+	SKS_FUNCTION_VERIFY,
+	SKS_FUNCTION_SIGN_RECOVER,
+	SKS_FUNCTION_VERIFY_RECOVER,
+	SKS_FUNCTION_IMPORT,
+	SKS_FUNCTION_COPY,
+	SKS_FUNCTION_MODIFY,
+	SKS_FUNCTION_DESTROY,
+};
+
+enum processing_step {
+	SKS_FUNC_STEP_INIT,
+	SKS_FUNC_STEP_ONESHOT,
+	SKS_FUNC_STEP_UPDATE,
+	SKS_FUNC_STEP_FINAL,
+};
+
+struct sks_attrs_head;
+struct pkcs11_session;
+
+/* Create an attribute list for a new object (TODO: add parent attribs) */
+uint32_t create_attributes_from_template(struct sks_attrs_head **out,
+					 void *template, size_t template_size,
+					 uint32_t proc_id,
+					 struct sks_attrs_head *parent,
+					 enum processing_func func);
+
+/*
+ * The various checks to be performed before a processing:
+ * - create an new object in the current token state
+ * - use a parent object in the processing
+ * - use a mechanism with provided configuration
+ */
+uint32_t check_created_attrs_against_token(struct pkcs11_session *session,
+					   struct sks_attrs_head *head);
+
+uint32_t check_created_attrs_against_parent_key(uint32_t proc_id,
+						struct sks_attrs_head *parent,
+						struct sks_attrs_head *head);
+
+uint32_t check_created_attrs_against_processing(uint32_t proc_id,
+						struct sks_attrs_head *head);
+
+uint32_t check_created_attrs(struct sks_attrs_head *key1,
+			     struct sks_attrs_head *key2);
+
+uint32_t check_parent_attrs_against_processing(uint32_t proc_id,
+					       enum processing_func func,
+					       struct sks_attrs_head *head);
+
+uint32_t check_access_attrs_against_token(struct pkcs11_session *session,
+					  struct sks_attrs_head *head);
+
+uint32_t check_mechanism_against_processing(struct pkcs11_session *session,
+					    uint32_t mechanism_type,
+					    enum processing_func function,
+					    enum processing_step step);
+
+int check_pkcs11_mechanism_flags(uint32_t mechanism_type, uint32_t flags);
+
+bool object_is_private(struct sks_attrs_head *head);
+
+void pkcs11_max_min_key_size(uint32_t key_type, uint32_t *max_key_size,
+			     uint32_t *min_key_size, bool bit_size_only);
+
+bool attribute_is_exportable(struct sks_attribute_head *req_attr,
+			     struct sks_object *obj);
+
+uint32_t add_missing_attribute_id(struct sks_attrs_head **attrs1,
+				  struct sks_attrs_head **attrs2);
+
+#endif /*__PKCS11_ATTRIBUTE_H*/
diff --git a/ta/secure_key_services/src/pkcs11_token.c b/ta/secure_key_services/src/pkcs11_token.c
new file mode 100644
index 00000000..77b8fc62
--- /dev/null
+++ b/ta/secure_key_services/src/pkcs11_token.c
@@ -0,0 +1,1740 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <assert.h>
+#include <sks_ta.h>
+#include <string.h>
+#include <string_ext.h>
+#include <sys/queue.h>
+#include <tee_internal_api_extensions.h>
+#include <util.h>
+
+#include "attributes.h"
+#include "handle.h"
+#include "pkcs11_token.h"
+#include "pkcs11_attributes.h"
+#include "processing.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+/* ID is token index */
+#define TOKEN_COUNT	CFG_SKS_TA_TOKEN_COUNT
+
+/* Static allocation of tokens runtime instances (reset to 0 at load) */
+struct ck_token ck_token[TOKEN_COUNT];
+
+static struct client_list pkcs11_client_list;
+
+static void close_ck_session(struct pkcs11_session *session);
+
+/* Static allocation of tokens runtime instances */
+struct ck_token *get_token(unsigned int token_id)
+{
+	if (token_id > TOKEN_COUNT)
+		return NULL;
+
+	return &ck_token[token_id];
+}
+
+unsigned int get_token_id(struct ck_token *token)
+{
+	assert(token >= ck_token && token < &ck_token[TOKEN_COUNT]);
+
+	return token - ck_token;
+}
+
+/* Client */
+struct pkcs11_client *tee_session2client(uintptr_t tee_session)
+{
+	struct pkcs11_client *client;
+
+	TAILQ_FOREACH(client, &pkcs11_client_list, link) {
+		if (client == (void *)tee_session)
+			return client;
+	}
+
+	return NULL;
+}
+
+uintptr_t register_client(void)
+{
+	struct pkcs11_client *client = NULL;
+
+	client = TEE_Malloc(sizeof(*client), TEE_MALLOC_FILL_ZERO);
+	if (!client)
+		return 0;
+
+	TAILQ_INSERT_HEAD(&pkcs11_client_list, client, link);
+	TAILQ_INIT(&client->session_list);
+	handle_db_init(&client->session_handle_db);
+
+	return (uintptr_t)(void *)client;
+}
+
+void unregister_client(uintptr_t tee_session)
+{
+	struct pkcs11_client *client = tee_session2client(tee_session);
+	struct pkcs11_session *session = NULL;
+	struct pkcs11_session *next = NULL;
+
+	if (!client) {
+		EMSG("Unexpected invalid TEE session handle");
+		return;
+	}
+
+	TAILQ_FOREACH_SAFE(session, &client->session_list, link, next) {
+		close_ck_session(session);
+	}
+
+	TAILQ_REMOVE(&pkcs11_client_list, client, link);
+	handle_db_destroy(&client->session_handle_db);
+	TEE_Free(client);
+}
+
+static int pkcs11_token_init(unsigned int id)
+{
+	struct ck_token *token = init_token_db(id);
+
+	if (!token)
+		return 1;
+
+	if (token->state != PKCS11_TOKEN_RESET) {
+		/* Token is already in a valid state */
+		return 0;
+	}
+
+	/* Initialize the token runtime state */
+	token->state = PKCS11_TOKEN_READ_WRITE;
+	token->session_count = 0;
+	token->rw_session_count = 0;
+
+	return 0;
+}
+
+int pkcs11_init(void)
+{
+	unsigned int id = 0;
+
+	for (id = 0; id < TOKEN_COUNT; id++)
+		if (pkcs11_token_init(id))
+			return 1;
+
+	TAILQ_INIT(&pkcs11_client_list);
+
+	return 0;
+}
+
+void pkcs11_deinit(void)
+{
+	unsigned int id = 0;
+
+	for (id = 0; id < TOKEN_COUNT; id++)
+		close_persistent_db(get_token(id));
+}
+
+bool pkcs11_session_is_read_write(struct pkcs11_session *session)
+{
+	switch (session->state) {
+	case PKCS11_SESSION_PUBLIC_READ_WRITE:
+	case PKCS11_SESSION_USER_READ_WRITE:
+	case PKCS11_SESSION_SO_READ_WRITE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool pkcs11_session_is_security_officer(struct pkcs11_session *session)
+{
+	return session->state == PKCS11_SESSION_SO_READ_WRITE;
+}
+
+bool pkcs11_session_is_user(struct pkcs11_session *session)
+{
+	return session->state == PKCS11_SESSION_USER_READ_WRITE ||
+		session->state == PKCS11_SESSION_USER_READ_ONLY;
+}
+
+bool pkcs11_session_is_public(struct pkcs11_session *session)
+{
+	return session->state == PKCS11_SESSION_PUBLIC_READ_WRITE ||
+		session->state == PKCS11_SESSION_PUBLIC_READ_ONLY;
+}
+
+struct pkcs11_session *sks_handle2session(uint32_t handle,
+					  uintptr_t tee_session)
+{
+	struct pkcs11_client *client = tee_session2client(tee_session);
+
+	return handle_lookup(&client->session_handle_db, (int)handle);
+}
+
+/*
+ * Currently not support dual operations.
+ */
+int set_processing_state(struct pkcs11_session *session,
+			 enum processing_func function,
+			 struct sks_object *obj1, struct sks_object *obj2)
+{
+	enum pkcs11_proc_state state;
+	struct active_processing *proc = NULL;
+
+	TEE_MemFill(&state, 0, sizeof(state));
+
+	if (session->processing)
+		return SKS_CKR_OPERATION_ACTIVE;
+
+	switch (function) {
+	case SKS_FUNCTION_ENCRYPT:
+		state = PKCS11_SESSION_ENCRYPTING;
+		break;
+	case SKS_FUNCTION_DECRYPT:
+		state = PKCS11_SESSION_DECRYPTING;
+		break;
+	case SKS_FUNCTION_SIGN:
+		state = PKCS11_SESSION_SIGNING;
+		break;
+	case SKS_FUNCTION_VERIFY:
+		state = PKCS11_SESSION_VERIFYING;
+		break;
+	case SKS_FUNCTION_DIGEST:
+		state = PKCS11_SESSION_DIGESTING;
+		break;
+	case SKS_FUNCTION_DERIVE:
+		state = PKCS11_SESSION_READY;
+		break;
+	default:
+		TEE_Panic(function);
+		return -1;
+	}
+
+	proc = TEE_Malloc(sizeof(*proc), TEE_MALLOC_FILL_ZERO);
+	if (!proc)
+		return SKS_MEMORY;
+
+	/* Boolean are default to false and pointers to NULL */
+	proc->state = state;
+	proc->tee_op_handle = TEE_HANDLE_NULL;
+
+	if (obj1 && get_bool(obj1->attributes, SKS_CKA_ALWAYS_AUTHENTICATE))
+		proc->always_authen = true;
+
+	if (obj2 && get_bool(obj2->attributes, SKS_CKA_ALWAYS_AUTHENTICATE))
+		proc->always_authen = true;
+
+	session->processing = proc;
+
+	return SKS_OK;
+}
+
+static void cipher_pin(TEE_ObjectHandle key_handle, uint8_t *buf, size_t len)
+{
+	uint8_t iv[16] = { 0 };
+	uint32_t size = len;
+	TEE_OperationHandle tee_op_handle = TEE_HANDLE_NULL;
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	res = TEE_AllocateOperation(&tee_op_handle,
+				    TEE_ALG_AES_CBC_NOPAD,
+				    TEE_MODE_ENCRYPT, 128);
+	if (res)
+		TEE_Panic(0);
+
+	res = TEE_SetOperationKey(tee_op_handle, key_handle);
+	if (res)
+		TEE_Panic(0);
+
+	TEE_CipherInit(tee_op_handle, iv, sizeof(iv));
+
+	res = TEE_CipherDoFinal(tee_op_handle, buf, len, buf, &size);
+	if (res || size != SKS_TOKEN_PIN_SIZE)
+		TEE_Panic(0);
+
+	TEE_FreeOperation(tee_op_handle);
+}
+
+/* ctrl=[slot-id][pin-size][pin][label], in=unused, out=unused */
+uint32_t entry_ck_token_initialize(TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t token_id = 0;
+	uint32_t pin_size = 0;
+	void *pin = NULL;
+	char label[SKS_TOKEN_LABEL_SIZE + 1] = { 0 };
+	struct ck_token *token;
+	uint8_t *cpin = NULL;
+	int pin_rc = 0;
+	struct pkcs11_client *client;
+	struct sks_object *obj = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	token = get_token(token_id);
+	if (!token)
+		return SKS_CKR_SLOT_ID_INVALID;
+
+	rv = serialargs_get(&ctrlargs, &pin_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	if (pin_size < 8 || pin_size > SKS_TOKEN_PIN_SIZE)
+		return SKS_CKR_PIN_LEN_RANGE;
+
+	rv = serialargs_get_ptr(&ctrlargs, &pin, pin_size);
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &label, SKS_TOKEN_LABEL_SIZE);
+	if (rv)
+		return rv;
+
+	if (token->db_main->flags & SKS_CKFT_SO_PIN_LOCKED) {
+		IMSG("SKSt%u: SO PIN locked", token_id);
+		return SKS_CKR_PIN_LOCKED;
+	}
+
+	TAILQ_FOREACH(client, &pkcs11_client_list, link) {
+		if (!TAILQ_EMPTY(&client->session_list)) {
+			return SKS_CKR_SESSION_EXISTS;
+		}
+	}
+
+	cpin = TEE_Malloc(SKS_TOKEN_PIN_SIZE, TEE_MALLOC_FILL_ZERO);
+	if (!cpin) {
+		return SKS_MEMORY;
+	}
+
+	TEE_MemMove(cpin, pin, pin_size);
+	cipher_pin(token->pin_hdl[0], cpin, SKS_TOKEN_PIN_SIZE);
+
+	if (!token->db_main->so_pin_size) {
+		TEE_MemMove(token->db_main->so_pin, cpin, SKS_TOKEN_PIN_SIZE);
+		token->db_main->so_pin_size = pin_size;
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      so_pin),
+				     sizeof(token->db_main->so_pin));
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      so_pin_size),
+				     sizeof(token->db_main->so_pin_size));
+
+		goto inited;
+	}
+
+	pin_rc = 0;
+	if (token->db_main->so_pin_size != pin_size)
+		pin_rc = 1;
+	if (buf_compare_ct(token->db_main->so_pin, cpin, SKS_TOKEN_PIN_SIZE))
+		pin_rc = 1;
+
+	if (pin_rc) {
+		token->db_main->flags |= SKS_CKFT_SO_PIN_COUNT_LOW;
+		token->db_main->so_pin_count++;
+
+		if (token->db_main->so_pin_count == 6)
+			token->db_main->flags |= SKS_CKFT_SO_PIN_FINAL_TRY;
+		if (token->db_main->so_pin_count == 7)
+			token->db_main->flags |= SKS_CKFT_SO_PIN_LOCKED;
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      flags),
+				     sizeof(token->db_main->flags));
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      so_pin_count),
+				     sizeof(token->db_main->so_pin_count));
+
+		TEE_Free(cpin);
+		return SKS_CKR_PIN_INCORRECT;
+	}
+
+	token->db_main->flags &= ~(SKS_CKFT_SO_PIN_COUNT_LOW |
+				   SKS_CKFT_SO_PIN_FINAL_TRY);
+	token->db_main->so_pin_count = 0;
+
+inited:
+	TEE_MemMove(token->db_main->label, label, SKS_TOKEN_LABEL_SIZE);
+	token->db_main->flags |= SKS_CKFT_TOKEN_INITIALIZED;
+	/* Reset user PIN */
+	token->db_main->user_pin_size = 0;
+	token->db_main->flags &= ~(SKS_CKFT_USER_PIN_INITIALIZED |
+				   SKS_CKFT_USER_PIN_COUNT_LOW |
+				   SKS_CKFT_USER_PIN_FINAL_TRY |
+				   SKS_CKFT_USER_PIN_LOCKED |
+				   SKS_CKFT_USER_PIN_TO_BE_CHANGED);
+
+	update_persistent_db(token, 0, sizeof(*token->db_main));
+
+	/* Remove all persistent objects */
+	if (token->db_objs && token->db_objs->count > 0) {
+		while (!LIST_EMPTY(&token->object_list)) {
+			obj = LIST_FIRST(&token->object_list);
+#ifdef DEBUG
+			MSG_RAW("[destroy] obj uuid %pUl", (void *)obj->uuid);
+#endif
+			unregister_persistent_object(token, obj->uuid);
+			cleanup_persistent_object(obj, token);
+		}
+	}
+
+	label[SKS_TOKEN_LABEL_SIZE] = '\0';
+	IMSG("SKSt%" PRIu32 ": initialized \"%s\"", token_id, label);
+
+	TEE_Free(cpin);
+
+	return SKS_OK;
+}
+
+uint32_t entry_ck_slot_list(TEE_Param *ctrl, TEE_Param *in, TEE_Param *out)
+{
+	const size_t out_size = sizeof(uint32_t) * TOKEN_COUNT;
+	uint32_t *id = NULL;
+	unsigned int n = 0;
+
+	if (ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < out_size) {
+		out->memref.size = out_size;
+		return SKS_SHORT_BUFFER;
+	}
+
+	/* FIXME: we could support unaligment buffers */
+	if ((uintptr_t)out->memref.buffer & 0x03UL)
+		return SKS_BAD_PARAM;
+
+	for (id = out->memref.buffer, n = 0; n < TOKEN_COUNT; n++, id++)
+		*id = (uint32_t)n;
+
+	out->memref.size = out_size;
+
+	return SKS_OK;
+}
+
+uint32_t entry_ck_slot_info(TEE_Param *ctrl, TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t token_id = 0;
+	struct ck_token *token = NULL;
+	const char desc[] = SKS_CRYPTOKI_SLOT_DESCRIPTION;
+	const char manuf[] = SKS_CRYPTOKI_SLOT_MANUFACTURER;
+	const char hwver[2] = SKS_CRYPTOKI_SLOT_HW_VERSION;
+	const char fwver[2] = SKS_CRYPTOKI_SLOT_FW_VERSION;
+	struct sks_slot_info info;
+	char dev_uuid[37]; /* UUID as string */
+	TEE_UUID dev_id;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+	TEE_MemFill(&info, 0, sizeof(info));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < sizeof(struct sks_slot_info)) {
+		out->memref.size = sizeof(struct sks_slot_info);
+		return SKS_SHORT_BUFFER;
+	}
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	token = get_token(token_id);
+	if (!token)
+		return SKS_CKR_SLOT_ID_INVALID;
+
+	TEE_MemFill(&info, 0, sizeof(info));
+
+	/* Set slot description to the device UUID if available */
+	if (TEE_GetPropertyAsUUID(TEE_PROPSET_TEE_IMPLEMENTATION,
+				"gpd.tee.deviceID", &dev_id) == TEE_SUCCESS) {
+		snprintf(dev_uuid, sizeof(dev_uuid),
+			"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+			dev_id.timeLow, dev_id.timeMid,
+			dev_id.timeHiAndVersion,
+			dev_id.clockSeqAndNode[0], dev_id.clockSeqAndNode[1],
+			dev_id.clockSeqAndNode[2], dev_id.clockSeqAndNode[3],
+			dev_id.clockSeqAndNode[4], dev_id.clockSeqAndNode[5],
+			dev_id.clockSeqAndNode[6], dev_id.clockSeqAndNode[7]);
+		PADDED_STRING_COPY(info.slotDescription, dev_uuid);
+	} else {
+		PADDED_STRING_COPY(info.slotDescription, desc);
+	}
+	PADDED_STRING_COPY(info.manufacturerID, manuf);
+
+	info.flags |= SKS_CKFS_TOKEN_PRESENT;
+	info.flags |= SKS_CKFS_REMOVABLE_DEVICE;
+	info.flags &= ~SKS_CKFS_HW_SLOT;
+
+	TEE_MemMove(&info.hardwareVersion, &hwver, sizeof(hwver));
+	TEE_MemMove(&info.firmwareVersion, &fwver, sizeof(fwver));
+
+	out->memref.size = sizeof(struct sks_slot_info);
+	TEE_MemMove(out->memref.buffer, &info, out->memref.size);
+
+	return SKS_OK;
+}
+
+uint32_t entry_ck_token_info(TEE_Param *ctrl, TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t token_id = 0;
+	struct ck_token *token = NULL;
+	const char manuf[] = SKS_CRYPTOKI_TOKEN_MANUFACTURER;
+	const char model[] = SKS_CRYPTOKI_TOKEN_MODEL;
+	const char hwver[] = SKS_CRYPTOKI_TOKEN_HW_VERSION;
+	const char fwver[] = SKS_CRYPTOKI_TOKEN_FW_VERSION;
+	char sernu[] = SKS_CRYPTOKI_TOKEN_SERIAL_NUMBER;
+	struct sks_token_info info;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+	TEE_MemFill(&info, 0, sizeof(info));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < sizeof(struct sks_token_info)) {
+		out->memref.size = sizeof(struct sks_token_info);
+		return SKS_SHORT_BUFFER;
+	}
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	token = get_token(token_id);
+	if (!token)
+		return SKS_CKR_SLOT_ID_INVALID;
+
+	if (snprintf(sernu + sizeof(sernu) - 2, 2, "%1d", token_id) >= 2)
+		TEE_Panic(0);
+
+	TEE_MemFill(&info, 0, sizeof(info));
+
+	PADDED_STRING_COPY(info.label, token->db_main->label);
+	PADDED_STRING_COPY(info.manufacturerID, manuf);
+	PADDED_STRING_COPY(info.model, model);
+	PADDED_STRING_COPY(info.serialNumber, sernu);
+
+	info.flags = token->db_main->flags;
+
+	/* TODO */
+	info.ulMaxSessionCount = ~0;
+	info.ulSessionCount = token->session_count;
+	info.ulMaxRwSessionCount = ~0;
+	info.ulRwSessionCount = token->rw_session_count;
+	/* TODO */
+	info.ulMaxPinLen = 128;
+	info.ulMinPinLen = 10;
+	/* TODO */
+	info.ulTotalPublicMemory = ~0;
+	info.ulFreePublicMemory = ~0;
+	info.ulTotalPrivateMemory = ~0;
+	info.ulFreePrivateMemory = ~0;
+
+	TEE_MemMove(&info.hardwareVersion, &hwver, sizeof(hwver));
+	TEE_MemMove(&info.firmwareVersion, &fwver, sizeof(hwver));
+
+	// TODO: get time and convert from refence into YYYYMMDDhhmmss/UTC
+	TEE_MemFill(info.utcTime, 0, sizeof(info.utcTime));
+
+	/* Return to caller with data */
+	out->memref.size = sizeof(struct sks_token_info);
+	TEE_MemMove(out->memref.buffer, &info, out->memref.size);
+
+	return SKS_OK;
+}
+
+uint32_t entry_ck_token_mecha_ids(TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t token_id = 0;
+	struct ck_token *token = NULL;
+	uint32_t mechanisms_count = (uint32_t)get_supported_mechanisms(NULL, 0);
+	size_t __maybe_unused count = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	token = get_token(token_id);
+	if (!token)
+		return SKS_CKR_SLOT_ID_INVALID;
+
+	if (out->memref.size < mechanisms_count * sizeof(uint32_t)) {
+		out->memref.size = mechanisms_count * sizeof(uint32_t);
+		return SKS_SHORT_BUFFER;
+	}
+
+	out->memref.size = sizeof(uint32_t) *
+		get_supported_mechanisms(out->memref.buffer, mechanisms_count);
+
+	assert(out->memref.size == mechanisms_count * sizeof(uint32_t));
+
+#ifdef DEBUG
+	for (count = 0; count < mechanisms_count; count++) {
+		IMSG("SKSt%" PRIu32 ": mechanism 0x%04" PRIx32 ": %s",
+			token_id, ((uint32_t *)out->memref.buffer)[count],
+			sks2str_proc(((uint32_t *)out->memref.buffer)[count]));
+	}
+#endif
+
+	return SKS_OK;
+}
+
+static uint32_t supported_mechanism_info_flag(uint32_t proc_id)
+{
+	uint32_t flags = 0;
+
+	switch (proc_id) {
+	case SKS_CKM_GENERIC_SECRET_KEY_GEN:
+	case SKS_CKM_AES_KEY_GEN:
+		flags = SKS_CKFM_GENERATE;
+		break;
+	case SKS_CKM_AES_ECB:
+	case SKS_CKM_AES_CBC:
+	case SKS_CKM_AES_CBC_PAD:
+	case SKS_CKM_AES_CTR:
+	case SKS_CKM_AES_CTS:
+	case SKS_CKM_AES_GCM:
+	case SKS_CKM_AES_CCM:
+		flags = SKS_CKFM_ENCRYPT | SKS_CKFM_DECRYPT |
+			SKS_CKFM_WRAP | SKS_CKFM_UNWRAP;
+		break;
+	case SKS_CKM_AES_GMAC:
+		flags = SKS_CKFM_SIGN | SKS_CKFM_VERIFY | SKS_CKFM_DERIVE;
+		break;
+	case SKS_CKM_AES_CMAC:
+	case SKS_CKM_AES_CMAC_GENERAL:
+	case SKS_CKM_MD5_HMAC:
+	case SKS_CKM_SHA_1_HMAC:
+	case SKS_CKM_SHA224_HMAC:
+	case SKS_CKM_SHA256_HMAC:
+	case SKS_CKM_SHA384_HMAC:
+	case SKS_CKM_SHA512_HMAC:
+	case SKS_CKM_AES_XCBC_MAC:
+		flags = SKS_CKFM_SIGN | SKS_CKFM_VERIFY;
+		break;
+	case SKS_CKM_AES_ECB_ENCRYPT_DATA:
+	case SKS_CKM_AES_CBC_ENCRYPT_DATA:
+		flags = SKS_CKFM_DERIVE;
+		break;
+	case SKS_CKM_EC_KEY_PAIR_GEN:
+	case SKS_CKM_RSA_PKCS_KEY_PAIR_GEN:
+		flags = SKS_CKFM_GENERATE_PAIR;
+		break;
+	case SKS_CKM_ECDSA:
+	case SKS_CKM_ECDSA_SHA1:
+	case SKS_CKM_ECDSA_SHA224:
+	case SKS_CKM_ECDSA_SHA256:
+	case SKS_CKM_ECDSA_SHA384:
+	case SKS_CKM_ECDSA_SHA512:
+		flags = SKS_CKFM_SIGN | SKS_CKFM_VERIFY;
+		break;
+	case SKS_CKM_ECDH1_DERIVE:
+	case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+	case SKS_CKM_ECMQV_DERIVE:
+		flags = SKS_CKFM_DERIVE;
+		break;
+	case SKS_CKM_ECDH_AES_KEY_WRAP:
+		flags = SKS_CKFM_WRAP | SKS_CKFM_UNWRAP;
+		break;
+	case SKS_CKM_RSA_PKCS:
+	case SKS_CKM_RSA_X_509:
+		flags = SKS_CKFM_ENCRYPT | SKS_CKFM_DECRYPT |
+			SKS_CKFM_SIGN | SKS_CKFM_VERIFY |
+			SKS_CKFM_SIGN_RECOVER | SKS_CKFM_VERIFY_RECOVER |
+			SKS_CKFM_WRAP | SKS_CKFM_UNWRAP;
+		break;
+	case SKS_CKM_RSA_9796:
+		flags = SKS_CKFM_SIGN | SKS_CKFM_VERIFY |
+			SKS_CKFM_SIGN_RECOVER | SKS_CKFM_VERIFY_RECOVER;
+		break;
+
+	case SKS_CKM_RSA_PKCS_OAEP:
+		flags = SKS_CKFM_ENCRYPT | SKS_CKFM_DECRYPT |
+			SKS_CKFM_WRAP | SKS_CKFM_UNWRAP;
+		break;
+	case SKS_CKM_RSA_PKCS_PSS:
+	case SKS_CKM_SHA1_RSA_PKCS:
+	case SKS_CKM_SHA224_RSA_PKCS:
+	case SKS_CKM_SHA256_RSA_PKCS:
+	case SKS_CKM_SHA384_RSA_PKCS:
+	case SKS_CKM_SHA512_RSA_PKCS:
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+		flags = SKS_CKFM_SIGN | SKS_CKFM_VERIFY;
+		break;
+	case SKS_CKM_RSA_AES_KEY_WRAP:
+		flags = SKS_CKFM_WRAP | SKS_CKFM_UNWRAP;
+		break;
+	default:
+		TEE_Panic(proc_id);
+		break;
+	}
+
+	assert(check_pkcs11_mechanism_flags(proc_id, flags) == 0);
+
+	return flags;
+}
+
+static void supported_mechanism_key_size(uint32_t proc_id,
+					 uint32_t *min_key_size,
+					 uint32_t *max_key_size,
+					 bool bit_size_only)
+{
+	uint32_t mult = bit_size_only ? 8 : 1;
+
+	switch (proc_id) {
+	case SKS_CKM_GENERIC_SECRET_KEY_GEN:
+		*min_key_size = 1;		/* in bits */
+		*max_key_size = 4096;		/* in bits */
+		break;
+	case SKS_CKM_MD5_HMAC:
+		*min_key_size = 16 * mult;
+		*max_key_size = 16 * mult;
+		break;
+	case SKS_CKM_SHA_1_HMAC:
+		*min_key_size = 20 * mult;
+		*max_key_size = 20 * mult;
+		break;
+	case SKS_CKM_SHA224_HMAC:
+		*min_key_size = 28 * mult;
+		*max_key_size = 28 * mult;
+		break;
+	case SKS_CKM_SHA256_HMAC:
+		*min_key_size = 32 * mult;
+		*max_key_size = 32 * mult;
+		break;
+	case SKS_CKM_SHA384_HMAC:
+		*min_key_size = 48 * mult;
+		*max_key_size = 48 * mult;
+		break;
+	case SKS_CKM_SHA512_HMAC:
+		*min_key_size = 64 * mult;
+		*max_key_size = 64 * mult;
+		break;
+	case SKS_CKM_AES_XCBC_MAC:
+		*min_key_size = 28 * mult;
+		*max_key_size = 28 * mult;
+		break;
+	case SKS_CKM_AES_KEY_GEN:
+	case SKS_CKM_AES_ECB:
+	case SKS_CKM_AES_CBC:
+	case SKS_CKM_AES_CBC_PAD:
+	case SKS_CKM_AES_CTR:
+	case SKS_CKM_AES_CTS:
+	case SKS_CKM_AES_GCM:
+	case SKS_CKM_AES_CCM:
+	case SKS_CKM_AES_GMAC:
+	case SKS_CKM_AES_CMAC:
+	case SKS_CKM_AES_CMAC_GENERAL:
+		*min_key_size = 16 * mult;
+		*max_key_size = 32 * mult;
+		break;
+	case SKS_CKM_EC_KEY_PAIR_GEN:
+	case SKS_CKM_ECDSA:
+	case SKS_CKM_ECDSA_SHA1:
+	case SKS_CKM_ECDSA_SHA224:
+	case SKS_CKM_ECDSA_SHA256:
+	case SKS_CKM_ECDSA_SHA384:
+	case SKS_CKM_ECDSA_SHA512:
+	case SKS_CKM_ECDH1_DERIVE:
+	case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+	case SKS_CKM_ECMQV_DERIVE:
+	case SKS_CKM_ECDH_AES_KEY_WRAP:
+		*min_key_size = 160;	/* in bits */
+		*max_key_size = 521;	/* in bits */
+		break;
+	case SKS_CKM_RSA_PKCS_KEY_PAIR_GEN:
+	case SKS_CKM_RSA_PKCS:
+	case SKS_CKM_RSA_9796:
+	case SKS_CKM_RSA_X_509:
+	case SKS_CKM_SHA1_RSA_PKCS:
+	case SKS_CKM_RSA_PKCS_OAEP:
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS:
+	case SKS_CKM_SHA384_RSA_PKCS:
+	case SKS_CKM_SHA512_RSA_PKCS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+		*min_key_size = 256;	/* in bits */
+		*max_key_size = 4096;	/* in bits */
+		break;
+	default:
+		*min_key_size = 0;
+		*max_key_size = 0;
+		break;
+	}
+}
+
+uint32_t entry_ck_token_mecha_info(TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t token_id = 0;
+	uint32_t type = 0;
+	struct ck_token *token = NULL;
+	struct sks_mechanism_info *info = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &type, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	token = get_token(token_id);
+	if (!token)
+		return SKS_CKR_SLOT_ID_INVALID;
+
+	if (!mechanism_is_supported(type))
+		return SKS_CKR_MECHANISM_INVALID;
+
+	if (out->memref.size < sizeof(info)) {
+		out->memref.size = sizeof(info);
+		return SKS_SHORT_BUFFER;
+	}
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	info = (struct sks_mechanism_info *)out->memref.buffer;
+
+	info->flags = supported_mechanism_info_flag(type);
+
+	supported_mechanism_key_size(type, &info->min_key_size,
+					&info->max_key_size, false);
+
+	out->memref.size = sizeof(struct sks_mechanism_info);
+
+	IMSG("SKSt%" PRIu32 ": mechanism 0x%" PRIx32 " info", token_id, type);
+
+	return SKS_OK;
+}
+
+/* Select the read-only/read-write state for session login state */
+static void set_session_state(struct pkcs11_client *client,
+			      struct pkcs11_session *session, bool readonly)
+{
+	struct pkcs11_session *sess = NULL;
+	enum pkcs11_session_state state = PKCS11_SESSION_RESET;
+
+	/*
+	 * No need to check all client session, only the first session on
+	 * target token gives client loggin configuration.
+	 */
+	TAILQ_FOREACH(sess, &client->session_list, link) {
+		assert(sess != session);
+
+		if (sess->token != session->token)
+			continue;
+
+		switch (sess->state) {
+		case PKCS11_SESSION_PUBLIC_READ_WRITE:
+		case PKCS11_SESSION_PUBLIC_READ_ONLY:
+			state = PKCS11_SESSION_PUBLIC_READ_WRITE;
+			break;
+		case PKCS11_SESSION_USER_READ_WRITE:
+		case PKCS11_SESSION_USER_READ_ONLY:
+			state = PKCS11_SESSION_USER_READ_WRITE;
+			break;
+		case PKCS11_SESSION_SO_READ_WRITE:
+			state = PKCS11_SESSION_SO_READ_WRITE;
+			break;
+		default:
+			TEE_Panic(0);
+		}
+		break;
+	 }
+
+	switch (state) {
+	case PKCS11_SESSION_USER_READ_WRITE:
+		session->state = readonly ? PKCS11_SESSION_USER_READ_ONLY :
+					  PKCS11_SESSION_USER_READ_WRITE;
+		break;
+	case PKCS11_SESSION_SO_READ_WRITE:
+		/* SO cannot open read-only sessions */
+		if (readonly)
+			TEE_Panic(0);
+
+		session->state = PKCS11_SESSION_PUBLIC_READ_ONLY;
+		break;
+	default:
+		session->state = readonly ? PKCS11_SESSION_PUBLIC_READ_ONLY :
+					  PKCS11_SESSION_PUBLIC_READ_WRITE;
+		break;
+	}
+}
+
+static void session_login_user(struct pkcs11_session *session)
+{
+	struct pkcs11_client *client = tee_session2client(session->tee_session);
+	struct pkcs11_session *sess = NULL;
+
+	TAILQ_FOREACH(sess, &client->session_list, link) {
+		if (sess->token != session->token)
+			continue;
+
+		if (pkcs11_session_is_read_write(sess))
+			sess->state = PKCS11_SESSION_USER_READ_WRITE;
+		else
+			sess->state = PKCS11_SESSION_USER_READ_ONLY;
+	}
+}
+
+static void session_login_so(struct pkcs11_session *session)
+{
+	struct pkcs11_client *client = tee_session2client(session->tee_session);
+	struct pkcs11_session *sess = NULL;
+
+	TAILQ_FOREACH(sess, &client->session_list, link) {
+		if (sess->token != session->token)
+			continue;
+
+		if (pkcs11_session_is_read_write(sess))
+			sess->state = PKCS11_SESSION_SO_READ_WRITE;
+		else
+			TEE_Panic(0);
+	}
+}
+
+static void session_logout(struct pkcs11_session *session)
+{
+	struct pkcs11_client *client = tee_session2client(session->tee_session);
+	struct pkcs11_session *sess = NULL;
+	struct sks_object *obj = NULL;
+
+	TAILQ_FOREACH(sess, &client->session_list, link) {
+		if (sess->token != session->token)
+			continue;
+
+		LIST_FOREACH(obj, &sess->object_list, link) {
+			if (!object_is_private(obj->attributes))
+				continue;
+
+			destroy_object(sess, obj, true);
+			handle_put(&sess->object_handle_db,
+				   sks_object2handle(obj, sess));
+		}
+
+		if (pkcs11_session_is_read_write(sess))
+			sess->state = PKCS11_SESSION_PUBLIC_READ_WRITE;
+		else
+			sess->state = PKCS11_SESSION_PUBLIC_READ_ONLY;
+	}
+}
+
+/* ctrl=[slot-id], in=unused, out=[session-handle] */
+static uint32_t open_ck_session(uintptr_t tee_session, TEE_Param *ctrl,
+				TEE_Param *in, TEE_Param *out, bool readonly)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t token_id = 0;
+	struct ck_token *token = NULL;
+	struct pkcs11_session *session = NULL;
+	struct pkcs11_client *client = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < sizeof(uint32_t)) {
+		out->memref.size = sizeof(uint32_t);
+		return SKS_SHORT_BUFFER;
+	}
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	token = get_token(token_id);
+	if (!token)
+		return SKS_CKR_SLOT_ID_INVALID;
+
+	if (!readonly && token->state == PKCS11_TOKEN_READ_ONLY) {
+		return SKS_CKR_TOKEN_WRITE_PROTECTED;
+	}
+
+	client = tee_session2client(tee_session);
+	if (!client) {
+		EMSG("Unexpected invlaid TEE session handle");
+		return SKS_FAILED;
+	}
+
+	if (readonly) {
+		TAILQ_FOREACH(session, &client->session_list, link) {
+			if (session->state == PKCS11_SESSION_SO_READ_WRITE) {
+				return SKS_CKR_SESSION_READ_WRITE_SO_EXISTS;
+			}
+		}
+	}
+
+	session = TEE_Malloc(sizeof(*session), TEE_MALLOC_FILL_ZERO);
+	if (!session)
+		return SKS_MEMORY;
+
+	session->handle = handle_get(&client->session_handle_db, session);
+	if (!session->handle) {
+		TEE_Free(session);
+		return SKS_MEMORY;
+	}
+
+	session->tee_session = tee_session;
+	session->token = token;
+	session->client = client;
+
+	LIST_INIT(&session->object_list);
+	handle_db_init(&session->object_handle_db);
+
+	set_session_state(client, session, readonly);
+
+	TAILQ_INSERT_HEAD(&client->session_list, session, link);
+
+	session->token->session_count++;
+	if (!readonly)
+		session->token->rw_session_count++;
+
+	*(uint32_t *)out->memref.buffer = session->handle;
+	out->memref.size = sizeof(uint32_t);
+
+	IMSG("SKSs%" PRIu32 ": open", session->handle);
+
+	return SKS_OK;
+}
+
+/* ctrl=[slot-id], in=unused, out=[session-handle] */
+uint32_t entry_ck_token_ro_session(uintptr_t tee_session, TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out)
+{
+	return open_ck_session(tee_session, ctrl, in, out, true);
+}
+
+/* ctrl=[slot-id], in=unused, out=[session-handle] */
+uint32_t entry_ck_token_rw_session(uintptr_t tee_session, TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out)
+{
+	return open_ck_session(tee_session, ctrl, in, out, false);
+}
+
+static void close_ck_session(struct pkcs11_session *session)
+{
+	release_active_processing(session);
+
+	/* No need to put object handles, the whole database is destroyed */
+	while (!LIST_EMPTY(&session->object_list)) {
+		destroy_object(session, LIST_FIRST(&session->object_list),
+				true);
+	}
+
+	release_session_find_obj_context(session);
+
+	TAILQ_REMOVE(&session->client->session_list, session, link);
+	handle_put(&session->client->session_handle_db, session->handle);
+	handle_db_destroy(&session->object_handle_db);
+
+	// If no more session, next opened one will simply be Public loggin
+
+	session->token->session_count--;
+	if (pkcs11_session_is_read_write(session))
+		session->token->rw_session_count--;
+
+	TEE_Free(session);
+
+	IMSG("SKSs%" PRIu32 ": close", session->handle);
+}
+
+/* ctrl=[session-handle], in=unused, out=unused */
+uint32_t entry_ck_token_close_session(uintptr_t tee_session, TEE_Param *ctrl,
+				      TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out || ctrl->memref.size < sizeof(uint32_t))
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	close_ck_session(session);
+
+	return SKS_OK;
+}
+
+uint32_t entry_ck_token_close_all(uintptr_t tee_session, TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t token_id = 0;
+	struct ck_token *token = NULL;
+	struct pkcs11_session *session = NULL;
+	struct pkcs11_session *next = NULL;
+	struct pkcs11_client *client = tee_session2client(tee_session);
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	token = get_token(token_id);
+	if (!token)
+		return SKS_CKR_SLOT_ID_INVALID;
+
+	IMSG("SKSt%" PRIu32 ": close sessions", token_id);
+
+	TAILQ_FOREACH_SAFE(session, &client->session_list, link, next) {
+		if (session->token == token)
+			close_ck_session(session);
+	}
+
+	return SKS_OK;
+}
+
+/* ctrl=[session-handle], in=unused, out=[session-info] */
+uint32_t entry_ck_token_session_info(uintptr_t tee_session, TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_session_info info;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+	TEE_MemFill(&info, 0, sizeof(info));
+
+	if (!ctrl || in || !out || ctrl->memref.size < sizeof(uint32_t))
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	if (out->memref.size < sizeof(struct sks_session_info)) {
+		out->memref.size = sizeof(struct sks_session_info);
+		return SKS_SHORT_BUFFER;
+	}
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	info.slot_id = get_token_id(session->token);
+	switch (session->state) {
+	case PKCS11_SESSION_PUBLIC_READ_WRITE:
+		info.state = SKS_CKSS_RW_PUBLIC_SESSION;
+		break;
+	case PKCS11_SESSION_PUBLIC_READ_ONLY:
+		info.state = SKS_CKSS_RO_PUBLIC_SESSION;
+		break;
+	case PKCS11_SESSION_USER_READ_WRITE:
+		info.state = SKS_CKSS_RW_USER_FUNCTIONS;
+		break;
+	case PKCS11_SESSION_USER_READ_ONLY:
+		info.state = SKS_CKSS_RO_USER_FUNCTIONS;
+		break;
+	case PKCS11_SESSION_SO_READ_WRITE:
+		info.state = SKS_CKSS_RW_SO_FUNCTIONS;
+		break;
+	default:
+		TEE_Panic(0);
+	}
+	info.flags = SKS_CKFS_SERIAL_SESSION;
+	if (session->state == PKCS11_SESSION_USER_READ_WRITE ||
+			session->state == PKCS11_SESSION_PUBLIC_READ_WRITE)
+		info.flags |= SKS_CKFS_RW_SESSION;
+	info.error_code = 0;
+
+	/* Return to caller with data */
+	TEE_MemMove(out->memref.buffer, &info, sizeof(info));
+
+	return SKS_OK;
+}
+
+static uint32_t set_pin(struct pkcs11_session *session,
+			uint8_t *new_pin, size_t new_pin_size,
+			uint32_t user_type)
+{
+	uint8_t *cpin = NULL;
+	uint32_t *pin_count = NULL;
+	uint32_t *pin_size = NULL;
+	uint8_t *pin = NULL;
+	TEE_ObjectHandle pin_key_hdl;
+	uint32_t flag_mask = 0;
+
+	TEE_MemFill(&pin_key_hdl, 0, sizeof(pin_key_hdl));
+
+	if (session->token->db_main->flags & SKS_CKFT_WRITE_PROTECTED)
+		return SKS_CKR_TOKEN_WRITE_PROTECTED;
+
+	if (!pkcs11_session_is_read_write(session))
+		return SKS_CKR_SESSION_READ_ONLY;
+
+	if (new_pin_size < 8 || new_pin_size > SKS_TOKEN_PIN_SIZE)
+		return SKS_CKR_PIN_LEN_RANGE;
+
+	switch (user_type) {
+	case SKS_CKU_SO:
+		pin = session->token->db_main->so_pin;
+		pin_size = &session->token->db_main->so_pin_size;
+		pin_count = &session->token->db_main->so_pin_count;
+		pin_key_hdl = session->token->pin_hdl[0];
+		flag_mask = SKS_CKFT_SO_PIN_COUNT_LOW |
+				SKS_CKFT_SO_PIN_FINAL_TRY |
+				SKS_CKFT_SO_PIN_LOCKED |
+				SKS_CKFT_SO_PIN_TO_BE_CHANGED;
+		break;
+	case SKS_CKU_USER:
+		pin = session->token->db_main->user_pin;
+		pin_size = &session->token->db_main->user_pin_size;
+		pin_count = &session->token->db_main->user_pin_count;
+		pin_key_hdl = session->token->pin_hdl[1];
+		flag_mask = SKS_CKFT_USER_PIN_COUNT_LOW |
+				SKS_CKFT_USER_PIN_FINAL_TRY |
+				SKS_CKFT_USER_PIN_LOCKED |
+				SKS_CKFT_USER_PIN_TO_BE_CHANGED;
+		break;
+	default:
+		return SKS_FAILED;
+	}
+
+	cpin = TEE_Malloc(SKS_TOKEN_PIN_SIZE, TEE_MALLOC_FILL_ZERO);
+	if (!cpin)
+		return SKS_MEMORY;
+
+	TEE_MemMove(cpin, new_pin, new_pin_size);
+
+	cipher_pin(pin_key_hdl, cpin, SKS_TOKEN_PIN_SIZE);
+
+	TEE_MemMove(pin, cpin, SKS_TOKEN_PIN_SIZE);
+	*pin_size = new_pin_size;
+	*pin_count = 0;
+
+	session->token->db_main->flags &= ~flag_mask;
+
+	if (user_type == SKS_CKU_USER)
+		session->token->db_main->flags |= SKS_CKFT_USER_PIN_INITIALIZED;
+
+	// Paranoia: Check unmodified old content is still valid
+	update_persistent_db(session->token,
+			     0, sizeof(*session->token->db_main));
+
+	TEE_Free(cpin);
+
+	return SKS_OK;
+}
+
+/* ctrl=[session-handle][pin-size]{pin-arrays], in=unused, out=unused */
+uint32_t entry_init_pin(uintptr_t tee_session, TEE_Param *ctrl,
+			TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	uint32_t pin_size = 0;
+	void *pin = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	if (!pkcs11_session_is_security_officer(session))
+		return SKS_CKR_USER_NOT_LOGGED_IN;
+
+	rv = serialargs_get(&ctrlargs, &pin_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get_ptr(&ctrlargs, &pin, pin_size);
+	if (rv)
+		return rv;
+
+	assert(session->token->db_main->flags & SKS_CKFT_TOKEN_INITIALIZED);
+
+	IMSG("SKSs%" PRIu32 ": init PIN", session_handle);
+
+	return set_pin(session, pin, pin_size, SKS_CKU_USER);
+}
+
+static uint32_t check_so_pin(struct pkcs11_session *session,
+			     uint8_t *pin, size_t pin_size)
+{
+	struct ck_token *token = session->token;
+	uint8_t *cpin = NULL;
+	int pin_rc = 0;
+
+	/* Note: intentional return code USER_PIN_NOT_INITIALIZED */
+	if (!token->db_main->so_pin_size ||
+	    !(token->db_main->flags & SKS_CKFT_TOKEN_INITIALIZED))
+		return SKS_CKR_USER_PIN_NOT_INITIALIZED;
+
+	if (token->db_main->flags & SKS_CKFT_SO_PIN_LOCKED)
+		return SKS_CKR_PIN_LOCKED;
+
+	cpin = TEE_Malloc(SKS_TOKEN_PIN_SIZE, TEE_MALLOC_FILL_ZERO);
+	if (!cpin)
+		return SKS_MEMORY;
+
+	TEE_MemMove(cpin, pin, pin_size);
+	cipher_pin(token->pin_hdl[0], cpin, SKS_TOKEN_PIN_SIZE);
+
+	pin_rc = 0;
+
+	if (token->db_main->so_pin_size != pin_size)
+		pin_rc = 1;
+
+	if (buf_compare_ct(token->db_main->so_pin, cpin, SKS_TOKEN_PIN_SIZE))
+		pin_rc = 1;
+
+	TEE_Free(cpin);
+
+	if (pin_rc) {
+		token->db_main->flags |= SKS_CKFT_SO_PIN_COUNT_LOW;
+		token->db_main->so_pin_count++;
+
+		if (token->db_main->so_pin_count == 6)
+			token->db_main->flags |= SKS_CKFT_SO_PIN_FINAL_TRY;
+		if (token->db_main->so_pin_count == 7)
+			token->db_main->flags |= SKS_CKFT_SO_PIN_LOCKED;
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      flags),
+				     sizeof(token->db_main->flags));
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      so_pin_count),
+				     sizeof(token->db_main->so_pin_count));
+
+		if (token->db_main->flags & SKS_CKFT_SO_PIN_LOCKED)
+			return SKS_CKR_PIN_LOCKED;
+
+		return SKS_CKR_PIN_INCORRECT;
+	}
+
+	if (token->db_main->so_pin_count) {
+		token->db_main->so_pin_count = 0;
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      so_pin_count),
+				     sizeof(token->db_main->so_pin_count));
+	}
+
+	if (token->db_main->flags & (SKS_CKFT_SO_PIN_COUNT_LOW |
+					SKS_CKFT_SO_PIN_FINAL_TRY)) {
+		token->db_main->flags &= ~(SKS_CKFT_SO_PIN_COUNT_LOW |
+					   SKS_CKFT_SO_PIN_FINAL_TRY);
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      flags),
+				     sizeof(token->db_main->flags));
+	}
+
+	return SKS_OK;
+}
+
+static uint32_t check_user_pin(struct pkcs11_session *session,
+				uint8_t *pin, size_t pin_size)
+{
+	struct ck_token *token = session->token;
+	uint8_t *cpin = NULL;
+	int pin_rc = 0;
+
+	if (!token->db_main->user_pin_size ||
+	    !(token->db_main->flags & SKS_CKFT_USER_PIN_INITIALIZED))
+		return SKS_CKR_USER_PIN_NOT_INITIALIZED;
+
+	if (token->db_main->flags & SKS_CKFT_USER_PIN_LOCKED)
+		return SKS_CKR_PIN_LOCKED;
+
+	cpin = TEE_Malloc(SKS_TOKEN_PIN_SIZE, TEE_MALLOC_FILL_ZERO);
+	if (!cpin)
+		return SKS_MEMORY;
+
+	TEE_MemMove(cpin, pin, pin_size);
+	cipher_pin(token->pin_hdl[1], cpin, SKS_TOKEN_PIN_SIZE);
+
+	pin_rc = 0;
+
+	if (token->db_main->user_pin_size != pin_size)
+		pin_rc = 1;
+
+	if (buf_compare_ct(token->db_main->user_pin, cpin, SKS_TOKEN_PIN_SIZE))
+		pin_rc = 1;
+
+	TEE_Free(cpin);
+
+	if (pin_rc) {
+		token->db_main->flags |= SKS_CKFT_USER_PIN_COUNT_LOW;
+		token->db_main->user_pin_count++;
+
+		if (token->db_main->user_pin_count == 6)
+			token->db_main->flags |= SKS_CKFT_USER_PIN_FINAL_TRY;
+		if (token->db_main->user_pin_count == 7)
+			token->db_main->flags |= SKS_CKFT_USER_PIN_LOCKED;
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      flags),
+				     sizeof(token->db_main->flags));
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      user_pin_count),
+				     sizeof(token->db_main->user_pin_count));
+
+		if (token->db_main->flags & SKS_CKFT_USER_PIN_LOCKED)
+			return SKS_CKR_PIN_LOCKED;
+
+		return SKS_CKR_PIN_INCORRECT;
+	}
+
+	if (token->db_main->user_pin_count) {
+		token->db_main->user_pin_count = 0;
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      user_pin_count),
+				     sizeof(token->db_main->user_pin_count));
+	}
+
+	if (token->db_main->flags & (SKS_CKFT_USER_PIN_COUNT_LOW |
+					SKS_CKFT_USER_PIN_FINAL_TRY)) {
+		token->db_main->flags &= ~(SKS_CKFT_USER_PIN_COUNT_LOW |
+				   SKS_CKFT_USER_PIN_FINAL_TRY);
+
+		update_persistent_db(token,
+				     offsetof(struct token_persistent_main,
+					      flags),
+				     sizeof(token->db_main->flags));
+	}
+
+	return SKS_OK;
+}
+
+/* ctrl=[session][old-size]{old-pin][pin-size]{pin], in=unused, out=unused */
+uint32_t entry_set_pin(uintptr_t tee_session, TEE_Param *ctrl,
+			TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	uint32_t old_pin_size = 0;
+	uint32_t pin_size = 0;
+	void *old_pin = NULL;
+	void *pin = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &old_pin_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get_ptr(&ctrlargs, &old_pin, old_pin_size);
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &pin_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get_ptr(&ctrlargs, &pin, pin_size);
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	if (!pkcs11_session_is_read_write(session))
+		return SKS_CKR_SESSION_READ_ONLY;
+
+	if (pkcs11_session_is_security_officer(session)) {
+		if (!(session->token->db_main->flags &
+		      SKS_CKFT_TOKEN_INITIALIZED))
+			return SKS_ERROR;
+
+		rv = check_so_pin(session, old_pin, old_pin_size);
+		if (rv)
+			return rv;
+
+		return set_pin(session, pin, pin_size, SKS_CKU_SO);
+	}
+
+	if (!(session->token->db_main->flags & SKS_CKFT_USER_PIN_INITIALIZED))
+		return SKS_ERROR;
+
+	rv = check_user_pin(session, old_pin, old_pin_size);
+	if (rv)
+		return rv;
+
+	IMSG("SKSs%" PRIu32 ": set PIN", session_handle);
+
+	return set_pin(session, pin, pin_size, SKS_CKU_USER);
+}
+
+/* ctrl=[session][user_type][pin-size]{pin], in=unused, out=unused */
+uint32_t entry_login(uintptr_t tee_session, TEE_Param *ctrl,
+		     TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct pkcs11_session *sess = NULL;
+	struct pkcs11_client *client = NULL;
+	uint32_t user_type = 0;
+	uint32_t pin_size = 0;
+	void *pin = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	rv = serialargs_get(&ctrlargs, &user_type, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &pin_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get_ptr(&ctrlargs, &pin, pin_size);
+	if (rv)
+		return rv;
+
+	client = tee_session2client(tee_session);
+
+	switch (user_type) {
+	case SKS_CKU_SO:
+		if (pkcs11_session_is_security_officer(session))
+			return SKS_CKR_USER_ALREADY_LOGGED_IN;
+
+		if (pkcs11_session_is_user(session))
+			return SKS_CKR_USER_ANOTHER_ALREADY_LOGGED_IN;
+
+		TAILQ_FOREACH(sess, &client->session_list, link)
+			if (sess->token == session->token &&
+			    !pkcs11_session_is_read_write(sess))
+				return SKS_CKR_SESSION_READ_ONLY_EXISTS;
+
+		TAILQ_FOREACH(client, &pkcs11_client_list, link) {
+			TAILQ_FOREACH(sess, &client->session_list, link) {
+				if (sess->token == session->token &&
+				    !pkcs11_session_is_public(sess))
+					return SKS_CKR_USER_TOO_MANY_TYPES;
+			}
+		}
+
+		rv = check_so_pin(session, pin, pin_size);
+		if (rv == SKS_OK)
+			session_login_so(session);
+
+		break;
+
+	case SKS_CKU_USER:
+		if (pkcs11_session_is_security_officer(session))
+			return SKS_CKR_USER_ANOTHER_ALREADY_LOGGED_IN;
+
+		if (pkcs11_session_is_user(session))
+			return SKS_CKR_USER_ALREADY_LOGGED_IN;
+
+		// TODO: check all client: if SO or user logged, we can return
+		// CKR_USER_TOO_MANY_TYPES.
+
+		rv = check_user_pin(session, pin, pin_size);
+		if (rv == SKS_OK)
+			session_login_user(session);
+
+		break;
+
+	case SKS_CKU_CONTEXT_SPECIFIC:
+		if (!session_is_active(session) ||
+		    !session->processing->always_authen)
+			return SKS_CKR_OPERATION_NOT_INITIALIZED;
+
+		if (pkcs11_session_is_public(session))
+			return SKS_CKR_FUNCTION_FAILED;
+
+		assert(pkcs11_session_is_user(session) ||
+			pkcs11_session_is_security_officer(session));
+
+		if (pkcs11_session_is_security_officer(session))
+			rv = check_so_pin(session, pin, pin_size);
+		else
+			rv = check_user_pin(session, pin, pin_size);
+
+		session->processing->relogged = (rv == SKS_OK);
+
+		if (rv == SKS_CKR_PIN_LOCKED)
+			session_logout(session);
+
+		break;
+
+	default:
+		return SKS_CKR_USER_TYPE_INVALID;
+	}
+
+	if (!rv)
+		IMSG("SKSs%" PRIu32 ": login", session_handle);
+
+	return rv;
+}
+
+/* ctrl=[session], in=unused, out=unused */
+uint32_t entry_logout(uintptr_t tee_session, TEE_Param *ctrl,
+		      TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	if (pkcs11_session_is_public(session))
+		return SKS_CKR_USER_NOT_LOGGED_IN;
+
+	session_logout(session);
+
+	IMSG("SKSs%" PRIu32 ": logout", session_handle);
+
+	return SKS_OK;
+}
+
diff --git a/ta/secure_key_services/src/pkcs11_token.h b/ta/secure_key_services/src/pkcs11_token.h
new file mode 100644
index 00000000..f7c84327
--- /dev/null
+++ b/ta/secure_key_services/src/pkcs11_token.h
@@ -0,0 +1,318 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+#ifndef __SKS_PKCS11_TOKEN_H__
+#define __SKS_PKCS11_TOKEN_H__
+
+#include <sys/queue.h>
+#include <tee_internal_api.h>
+
+#include "handle.h"
+#include "object.h"
+#include "pkcs11_attributes.h"
+
+/* Hard coded description */
+#define SKS_CRYPTOKI_TOKEN_LABEL		"op-tee pkcs#11 token (dev...)"
+#define SKS_CRYPTOKI_TOKEN_MANUFACTURER		"Linaro"
+#define SKS_CRYPTOKI_TOKEN_MODEL		"OP-TEE SKS TA"
+#define SKS_CRYPTOKI_TOKEN_SERIAL_NUMBER	"0000000000000000"
+#define SKS_CRYPTOKI_TOKEN_HW_VERSION		{ 0, 0 }
+#define SKS_CRYPTOKI_TOKEN_FW_VERSION		{ 0, 0 }
+
+#define SKS_CRYPTOKI_SLOT_DESCRIPTION		"OP-TEE SKS TA"
+#define SKS_CRYPTOKI_SLOT_MANUFACTURER		SKS_CRYPTOKI_TOKEN_MANUFACTURER
+#define SKS_CRYPTOKI_SLOT_HW_VERSION		SKS_CRYPTOKI_TOKEN_HW_VERSION
+#define SKS_CRYPTOKI_SLOT_FW_VERSION		SKS_CRYPTOKI_TOKEN_FW_VERSION
+
+#define PADDED_STRING_COPY(_dst, _src) \
+	do { \
+		TEE_MemFill((char *)(_dst), ' ', sizeof(_dst)); \
+		TEE_MemMove((char *)(_dst), (_src), \
+			    MIN(strlen((char *)(_src)), sizeof(_dst))); \
+	} while (0)
+
+enum pkcs11_token_state {
+	PKCS11_TOKEN_RESET = 0,
+	PKCS11_TOKEN_READ_WRITE,
+	PKCS11_TOKEN_READ_ONLY,
+};
+
+enum pkcs11_session_state {
+	PKCS11_SESSION_RESET = 0,
+	PKCS11_SESSION_PUBLIC_READ_WRITE,
+	PKCS11_SESSION_PUBLIC_READ_ONLY,
+	PKCS11_SESSION_USER_READ_WRITE,
+	PKCS11_SESSION_USER_READ_ONLY,
+	PKCS11_SESSION_SO_READ_WRITE,
+};
+
+TAILQ_HEAD(client_list, pkcs11_client);
+TAILQ_HEAD(session_list, pkcs11_session);
+
+#define SKS_MAX_USERS			2
+#define SKS_TOKEN_PIN_SIZE		128
+
+/*
+ * Persistent state of the token
+ *
+ * @version - currently unused...
+ * @label - pkcs11 formatted token label, set by client
+ * @flags - pkcs11 token flags
+ * @so_pin_count - counter on security officer login failure
+ * @so_pin_size - byte size of the provisionned SO PIN
+ * @so_pin - stores the SO PIN
+ * @user_pin_count - counter on user login failure
+ * @user_pin_size - byte size of the provisionned user PIN
+ * @user_pin - stores the user PIN
+ */
+struct token_persistent_main {
+	uint32_t version;
+
+	uint8_t label[SKS_TOKEN_LABEL_SIZE];
+	uint32_t flags;
+
+	uint32_t so_pin_count;
+	uint32_t so_pin_size;
+	uint8_t so_pin[SKS_TOKEN_PIN_SIZE];
+
+	uint32_t user_pin_count;
+	uint32_t user_pin_size;
+	uint8_t user_pin[SKS_TOKEN_PIN_SIZE];
+};
+
+/*
+ * Persistent objects in the token
+ *
+ * @count - number of object stored in the token
+ * @uudis - start of object references/UUIDs (@count items)
+ */
+struct token_persistent_objs {
+	uint32_t count;
+	TEE_UUID uuids[];
+};
+
+/*
+ * Runtime state of the token, complies with pkcs11
+ *
+ * @login_state - Pkcs11 login is public, user, SO or custom
+ * @db_hld - TEE handle on the persistent database object or TEE_HANDLE_NULL
+ * @pin_hld - TEE handles on PIN ciphering keys
+ * @db_main - Volatile copy of the persistent main database
+ * @session_count - Counter for opened Pkcs11 sessions
+ * @rw_session_count - Count for opened Pkcs11 read/write sessions
+ * @session_state - Login state of the token
+ * @session_list - Head of the list of the sessions owned by the token
+ */
+struct ck_token {
+	enum pkcs11_token_state state;
+	uint32_t session_count;
+	uint32_t rw_session_count;
+
+	struct object_list object_list;
+
+	TEE_ObjectHandle db_hdl;	/* Opened handle to persistent database */
+	TEE_ObjectHandle pin_hdl[SKS_MAX_USERS];	/* Opened handle to PIN keys */
+	struct token_persistent_main *db_main;		/* Copy persistent database */
+	struct token_persistent_objs *db_objs;		/* Copy persistent database */
+};
+
+/*
+ * A session can enter a processing state (encrypt, decrypt, disgest, ...
+ * only from the inited state. A sesion must return the the inited
+ * state (from a processing finalization request) before entering another
+ * processing state.
+ */
+enum pkcs11_proc_state {
+	PKCS11_SESSION_READY = 0,		/* No active processing/operation */
+	PKCS11_SESSION_ENCRYPTING,
+	PKCS11_SESSION_DECRYPTING,
+	PKCS11_SESSION_DIGESTING,
+	PKCS11_SESSION_DIGESTING_ENCRYPTING,	/* case C_DigestEncryptUpdate */
+	PKCS11_SESSION_DECRYPTING_DIGESTING,	/* case C_DecryptDigestUpdate */
+	PKCS11_SESSION_SIGNING,
+	PKCS11_SESSION_SIGNING_ENCRYPTING,	/* case C_SignEncryptUpdate */
+	PKCS11_SESSION_VERIFYING,
+	PKCS11_SESSION_DECRYPTING_VERIFYING,	/* case C_DecryptVerifyUpdate */
+	PKCS11_SESSION_SIGNING_RECOVER,
+	PKCS11_SESSION_VERIFYING_RECOVER,
+};
+
+/*
+ * Context of the active processing in the session
+ *
+ * @state - ongoing active processing function or ready state
+ * @mecha_type - mechanism type of the active processing
+ * @updated - true once an active operation is updated
+ * @relogged - true once client logged since last operation update
+ * @always_authen - true if user need to login before each use
+ * @tee_op_handle - handle on active crypto operation or TEE_HANDLE_NULL
+ * @extra_ctx - context for the active processing
+ */
+struct active_processing {
+	enum pkcs11_proc_state state;
+	uint32_t mecha_type;
+	bool always_authen;
+	bool relogged;
+	bool updated;
+	// TODO: end time for object usage
+	TEE_OperationHandle tee_op_handle;
+	void *extra_ctx;
+};
+
+/*
+ * Pkcs11 objects serach context
+ *
+ * @attributes - matching attributes list searched (null if no search)
+ * @count - number of matching handle found
+ * @handles - array of handle of matching objects (published handles)
+ * @next - index of the next object handle to return to FindObject
+ * @temp_start - index of the trailing not yet published handles
+ */
+struct pkcs11_find_objects {
+	void *attributes;
+	size_t count;
+	uint32_t *handles;
+	size_t next;
+	size_t temp_start;
+};
+
+/*
+ * Structure tracking client applications
+ *
+ * TODO: rename pkcs11_client into sks_client
+ *
+ * @link - chained list of registered client applications
+ * @sessions - list of the PKCS11 sessions opened by the client application
+ */
+struct pkcs11_client {
+	TAILQ_ENTRY(pkcs11_client) link;
+	struct session_list session_list;
+	struct handle_db session_handle_db;
+};
+
+/*
+ * Structure tracking the PKCS#11 sessions
+ *
+ * @link - list of the session belowing to a client
+ * @tee_session - TEE session handle used by PKCS11 session client
+ * @client - client the session belongs to (FIXME: redondant with tee_session)
+ * @token - token this session belongs to
+ * @handle - identifier of the session published to the client
+ * @object_list - entry of the session objects list
+ * @object_handle_db - database for object handles published by the session
+ * @state - R/W SO, R/W user, RO user, R/W public, RO public.
+ * @find_ctx - point to active search context (null if no active search)
+ */
+struct pkcs11_session {
+	TAILQ_ENTRY(pkcs11_session) link;
+	uintptr_t tee_session;
+	struct pkcs11_client *client;
+	struct ck_token *token;
+	uint32_t handle;
+	struct object_list object_list;
+	struct handle_db object_handle_db;
+	enum pkcs11_session_state state;
+	struct active_processing *processing;
+	struct pkcs11_find_objects *find_ctx;
+};
+
+/* Initialize static token instance(s) from default/persistent database */
+int pkcs11_init(void);
+void pkcs11_deinit(void);
+
+/* Return token instance from token identifier */
+struct ck_token *get_token(unsigned int token_id);
+
+/* Return token identified from token instance address */
+unsigned int get_token_id(struct ck_token *token);
+
+/* Initialize target token database */
+struct ck_token *init_token_db(unsigned int token_id);
+
+/* Persistent database update */
+int update_persistent_db(struct ck_token *token, size_t offset, size_t size);
+void close_persistent_db(struct ck_token *token);
+
+/* Token persistent objects */
+uint32_t create_object_uuid(struct ck_token *token, struct sks_object *obj);
+void destroy_object_uuid(struct ck_token *token, struct sks_object *obj);
+uint32_t unregister_persistent_object(struct ck_token *token, TEE_UUID *uuid);
+uint32_t register_persistent_object(struct ck_token *token, TEE_UUID *uuid);
+uint32_t get_persistent_objects_list(struct ck_token *token,
+				     TEE_UUID *array, size_t *size);
+
+/*
+ * Pkcs11 session support
+ */
+struct pkcs11_client *tee_session2client(uintptr_t tee_session);
+uintptr_t register_client(void);
+void unregister_client(uintptr_t tee_session);
+
+void ck_token_close_tee_session(uintptr_t tee_session);
+struct pkcs11_session *sks_handle2session(uint32_t handle,
+					  uintptr_t tee_session);
+
+static inline bool session_is_active(struct pkcs11_session *session)
+{
+	return session->processing != NULL;
+}
+
+int set_processing_state(struct pkcs11_session *session,
+			 enum processing_func function,
+			 struct sks_object *obj1, struct sks_object *obj2);
+
+bool pkcs11_session_is_read_write(struct pkcs11_session *session);
+bool pkcs11_session_is_public(struct pkcs11_session *session);
+bool pkcs11_session_is_user(struct pkcs11_session *session);
+bool pkcs11_session_is_security_officer(struct pkcs11_session *session);
+
+static inline
+struct object_list *pkcs11_get_session_objects(struct pkcs11_session *session)
+{
+	return &session->object_list;
+}
+
+static inline
+struct ck_token *pkcs11_session2token(struct pkcs11_session *session)
+{
+	return session->token;
+}
+
+/*
+ * Entry point for the TA commands
+ */
+uint32_t entry_ck_slot_list(TEE_Param *ctrl, TEE_Param *in, TEE_Param *out);
+uint32_t entry_ck_slot_info(TEE_Param *ctrl, TEE_Param *in, TEE_Param *out);
+uint32_t entry_ck_token_info(TEE_Param *ctrl, TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_ck_token_initialize(TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_ck_token_mecha_ids(TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_ck_token_mecha_info(TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_ck_token_ro_session(uintptr_t teesess, TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out);
+uint32_t entry_ck_token_rw_session(uintptr_t teesess, TEE_Param *ctrl,
+				   TEE_Param *in, TEE_Param *out);
+uint32_t entry_ck_token_close_session(uintptr_t teesess, TEE_Param *ctrl,
+				      TEE_Param *in, TEE_Param *out);
+uint32_t entry_ck_token_close_all(uintptr_t teesess, TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *out);
+uint32_t entry_ck_token_session_info(uintptr_t tee_session, TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_init_pin(uintptr_t tee_session, TEE_Param *ctrl,
+			TEE_Param *in, TEE_Param *out);
+uint32_t entry_set_pin(uintptr_t tee_session, TEE_Param *ctrl,
+		       TEE_Param *in, TEE_Param *out);
+uint32_t entry_login(uintptr_t tee_session, TEE_Param *ctrl,
+		     TEE_Param *in, TEE_Param *out);
+uint32_t entry_logout(uintptr_t tee_session, TEE_Param *ctrl,
+		      TEE_Param *in, TEE_Param *out);
+
+#endif /*__SKS_PKCS11_TOKEN_H__*/
diff --git a/ta/secure_key_services/src/processing.c b/ta/secure_key_services/src/processing.c
new file mode 100644
index 00000000..eb16af96
--- /dev/null
+++ b/ta/secure_key_services/src/processing.c
@@ -0,0 +1,1069 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <assert.h>
+#include <sks_internal_abi.h>
+#include <sks_ta.h>
+#include <string.h>
+#include <tee_api_defines.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include <util.h>
+
+#include "attributes.h"
+#include "object.h"
+#include "pkcs11_token.h"
+#include "pkcs11_attributes.h"
+#include "processing.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+static uint32_t get_ready_session(struct pkcs11_session **sess,
+				  uint32_t session_handle,
+				  uintptr_t tee_session)
+{
+	struct pkcs11_session *session = NULL;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	if (session_is_active(session))
+		return SKS_CKR_OPERATION_ACTIVE;
+
+	*sess = session;
+
+	return SKS_OK;
+}
+
+static bool func_matches_state(enum processing_func function,
+				enum pkcs11_proc_state state)
+{
+	switch (function) {
+	case SKS_FUNCTION_ENCRYPT:
+		return (state == PKCS11_SESSION_ENCRYPTING ||
+			state == PKCS11_SESSION_DIGESTING_ENCRYPTING ||
+			state == PKCS11_SESSION_SIGNING_ENCRYPTING);
+	case SKS_FUNCTION_DECRYPT:
+		return (state == PKCS11_SESSION_DECRYPTING ||
+			state == PKCS11_SESSION_DECRYPTING_DIGESTING ||
+			state == PKCS11_SESSION_DECRYPTING_VERIFYING);
+	case SKS_FUNCTION_DIGEST:
+		return (state == PKCS11_SESSION_DIGESTING ||
+			state == PKCS11_SESSION_DIGESTING_ENCRYPTING);
+	case SKS_FUNCTION_SIGN:
+		return (state == PKCS11_SESSION_SIGNING ||
+			state == PKCS11_SESSION_SIGNING_ENCRYPTING);
+	case SKS_FUNCTION_VERIFY:
+		return (state == PKCS11_SESSION_VERIFYING ||
+			state == PKCS11_SESSION_DECRYPTING_VERIFYING);
+	case SKS_FUNCTION_SIGN_RECOVER:
+		return state == PKCS11_SESSION_SIGNING_RECOVER;
+	case SKS_FUNCTION_VERIFY_RECOVER:
+		return state == PKCS11_SESSION_SIGNING_RECOVER;
+	default:
+		TEE_Panic(function);
+		return false;
+	}
+}
+
+static uint32_t get_active_session(struct pkcs11_session **sess,
+				  uint32_t session_handle,
+				  uintptr_t tee_session,
+				  enum processing_func function)
+{
+	struct pkcs11_session *session = NULL;
+	uint32_t rv = SKS_CKR_OPERATION_NOT_INITIALIZED;
+
+	session = sks_handle2session(session_handle, tee_session);
+	if (!session)
+		return SKS_CKR_SESSION_HANDLE_INVALID;
+
+	if (session->processing &&
+	    func_matches_state(function, session->processing->state)) {
+		*sess = session;
+		rv = SKS_OK;
+	}
+
+	return rv;
+}
+
+void release_active_processing(struct pkcs11_session *session)
+{
+	if (!session->processing)
+		return;
+
+	switch (session->processing->mecha_type) {
+	case SKS_CKM_AES_CTR:
+		tee_release_ctr_operation(session->processing);
+		break;
+	case SKS_CKM_AES_GCM:
+		tee_release_gcm_operation(session->processing);
+		break;
+	case SKS_CKM_AES_CCM:
+		tee_release_ccm_operation(session->processing);
+		break;
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+		tee_release_rsa_pss_operation(session->processing);
+		break;
+	default:
+		break;
+	}
+
+	if (session->processing->tee_op_handle != TEE_HANDLE_NULL) {
+		TEE_FreeOperation(session->processing->tee_op_handle);
+		session->processing->tee_op_handle = TEE_HANDLE_NULL;
+	}
+
+	TEE_Free(session->processing);
+	session->processing = NULL;
+}
+
+uint32_t entry_import_object(uintptr_t tee_session,
+			     TEE_Param *ctrl, TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_attrs_head *head = NULL;
+	struct sks_object_head *template = NULL;
+	size_t template_size = 0;
+	uint32_t obj_handle = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	/*
+	 * Collect the arguments of the request
+	 */
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < sizeof(uint32_t)) {
+		out->memref.size = sizeof(uint32_t);
+		return SKS_SHORT_BUFFER;
+	}
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = get_ready_session(&session, session_handle, tee_session);
+	if (rv)
+		return rv;
+
+	rv = serialargs_alloc_get_attributes(&ctrlargs, &template);
+	if (rv)
+		goto bail;
+
+	template_size = sizeof(*template) + template->attrs_size;
+
+	/*
+	 * Prepare a clean initial state for the requested object attributes.
+	 * Free temorary template once done.
+	 */
+	rv = create_attributes_from_template(&head, template, template_size,
+					     SKS_UNDEFINED_ID, NULL,
+					     SKS_FUNCTION_IMPORT);
+	TEE_Free(template);
+	template = NULL;
+	if (rv)
+		goto bail;
+
+	/*
+	 * Check target object attributes match target processing
+	 * Check target object attributes match token state
+	 */
+	rv = check_created_attrs_against_processing(SKS_PROCESSING_IMPORT,
+						    head);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_token(session, head);
+	if (rv)
+		goto bail;
+
+	/*
+	 * TODO: test object (will check all expected attributes are in place
+	 */
+
+	/*
+	 * At this stage the object is almost created: all its attributes are
+	 * referenced in @head, including the key value and are assume
+	 * reliable. Now need to register it and get a handle for it.
+	 */
+	rv = create_object(session, head, &obj_handle);
+	if (rv)
+		goto bail;
+
+	/*
+	 * Now obj_handle (through the related struct sks_object instance)
+	 * owns the serialised buffer that holds the object attributes.
+	 * We reset attrs->buffer to NULL as serializer object is no more
+	 * the attributes buffer owner.
+	 */
+	head = NULL;
+
+	TEE_MemMove(out->memref.buffer, &obj_handle, sizeof(uint32_t));
+	out->memref.size = sizeof(uint32_t);
+
+	IMSG("SKSs%" PRIu32 ": import object 0x%" PRIx32,
+	     session_handle, obj_handle);
+
+bail:
+	TEE_Free(template);
+	TEE_Free(head);
+
+	return rv;
+}
+
+size_t get_object_key_bit_size(struct sks_object *obj)
+{
+	void *a_ptr = NULL;
+	size_t a_size = 0;
+	struct sks_attrs_head *attrs = obj->attributes;
+
+	switch (get_type(attrs)) {
+	case SKS_CKK_AES:
+	case SKS_CKK_GENERIC_SECRET:
+	case SKS_CKK_MD5_HMAC:
+	case SKS_CKK_SHA_1_HMAC:
+	case SKS_CKK_SHA224_HMAC:
+	case SKS_CKK_SHA256_HMAC:
+	case SKS_CKK_SHA384_HMAC:
+	case SKS_CKK_SHA512_HMAC:
+		if (get_attribute_ptr(attrs, SKS_CKA_VALUE, NULL, &a_size))
+			return 0;
+
+		return a_size * 8;
+
+	case SKS_CKK_RSA:
+		if (get_attribute_ptr(attrs, SKS_CKA_MODULUS, NULL, &a_size))
+			return 0;
+
+		return a_size * 8;
+
+	case SKS_CKK_EC:
+		if (get_attribute_ptr(attrs, SKS_CKA_EC_PARAMS,
+					&a_ptr, &a_size))
+			return 0;
+
+		return ec_params2tee_keysize(a_ptr, a_size);
+
+	default:
+		TEE_Panic(0);
+		return 0;
+	}
+}
+
+static uint32_t generate_random_key_value(struct sks_attrs_head **head)
+{
+	uint32_t rv = 0;
+	void *data;
+	size_t data_size;
+	uint32_t value_len;
+	void *value;
+
+	if (!*head)
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+
+	rv = get_attribute_ptr(*head, SKS_CKA_VALUE_LEN, &data, &data_size);
+	if (rv || data_size != sizeof(uint32_t)) {
+		DMSG("%s", rv ? "No attribute value_len found" :
+			"Invalid size for attribute VALUE_LEN");
+		return SKS_CKR_ATTRIBUTE_VALUE_INVALID;
+	}
+	TEE_MemMove(&value_len, data, data_size);
+
+	if (get_type(*head) == SKS_CKK_GENERIC_SECRET)
+		value_len = (value_len + 7) / 8;
+
+	value = TEE_Malloc(value_len, TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!value)
+		return SKS_MEMORY;
+
+	TEE_GenerateRandom(value, value_len);
+
+	rv = add_attribute(head, SKS_CKA_VALUE, value, value_len);
+
+	TEE_Free(value);
+
+	return rv;
+}
+
+uint32_t entry_generate_secret(uintptr_t tee_session,
+			       TEE_Param *ctrl, TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_attribute_head *proc_params = NULL;
+	struct sks_attrs_head *head = NULL;
+	struct sks_object_head *template = NULL;
+	size_t template_size = 0;
+	uint32_t obj_handle = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < sizeof(uint32_t)) {
+		out->memref.size = sizeof(uint32_t);
+		return SKS_SHORT_BUFFER;
+	}
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = get_ready_session(&session, session_handle, tee_session);
+	if (rv)
+		return rv;
+
+	rv = serialargs_alloc_get_one_attribute(&ctrlargs, &proc_params);
+	if (rv)
+		goto bail;
+
+	switch (proc_params->id) {
+	case SKS_CKM_GENERIC_SECRET_KEY_GEN:
+	case SKS_CKM_AES_KEY_GEN:
+		break;
+	default:
+		rv = SKS_CKR_MECHANISM_INVALID;
+		goto bail;
+	}
+
+	rv = serialargs_alloc_get_attributes(&ctrlargs, &template);
+	if (rv)
+		goto bail;
+
+	template_size = sizeof(*template) + template->attrs_size;
+
+	rv = check_mechanism_against_processing(session, proc_params->id,
+						SKS_FUNCTION_GENERATE,
+						SKS_FUNC_STEP_INIT);
+	if (rv)
+		goto bail;
+
+	/*
+	 * Prepare a clean initial state for the requested object attributes.
+	 * Free temorary template once done.
+	 */
+	rv = create_attributes_from_template(&head, template, template_size,
+					     proc_params->id, NULL,
+					     SKS_FUNCTION_GENERATE);
+	if (rv)
+		goto bail;
+
+	TEE_Free(template);
+	template = NULL;
+
+	rv = check_created_attrs(head, NULL);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_processing(proc_params->id, head);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_token(session, head);
+	if (rv)
+		goto bail;
+
+	/*
+	 * Execute target processing and add value as attribute SKS_CKA_VALUE.
+	 * Symm key generation: depens on target processing to be used.
+	 */
+	switch (proc_params->id) {
+	case SKS_CKM_GENERIC_SECRET_KEY_GEN:
+	case SKS_CKM_AES_KEY_GEN:
+		/* Generate random of size specified by attribute VALUE_LEN */
+		rv = generate_random_key_value(&head);
+		if (rv)
+			goto bail;
+		break;
+
+	default:
+		rv = SKS_CKR_MECHANISM_INVALID;
+		goto bail;
+	}
+
+	TEE_Free(proc_params);
+	proc_params = NULL;
+
+	/*
+	 * Object is ready, register it and return a handle.
+	 */
+	rv = create_object(session, head, &obj_handle);
+	if (rv)
+		goto bail;
+
+	/*
+	 * Now obj_handle (through the related struct sks_object instance)
+	 * owns the serialized buffer that holds the object attributes.
+	 * We reset attrs->buffer to NULL as serializer object is no more
+	 * the attributes buffer owner.
+	 */
+	head = NULL;
+
+	TEE_MemMove(out->memref.buffer, &obj_handle, sizeof(uint32_t));
+	out->memref.size = sizeof(uint32_t);
+
+	IMSG("SKSs%" PRIu32 ": generate secret 0x%" PRIx32,
+	     session_handle, obj_handle);
+
+bail:
+	TEE_Free(proc_params);
+	TEE_Free(template);
+	TEE_Free(head);
+
+	return rv;
+}
+
+uint32_t alloc_get_tee_attribute_data(TEE_ObjectHandle tee_obj,
+					     uint32_t attribute,
+					     void **data, size_t *size)
+{
+	TEE_Result res = TEE_ERROR_GENERIC;
+	void *ptr = NULL;
+	uint32_t sz = 0;
+
+	res = TEE_GetObjectBufferAttribute(tee_obj, attribute, NULL, &sz);
+	if (res != TEE_ERROR_SHORT_BUFFER)
+		return SKS_FAILED;
+
+	ptr = TEE_Malloc(sz, TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!ptr)
+		return SKS_MEMORY;
+
+	res = TEE_GetObjectBufferAttribute(tee_obj, attribute, ptr, &sz);
+	if (res) {
+		TEE_Free(ptr);
+	} else {
+		*data = ptr;
+		*size = sz;
+	}
+
+	return tee2sks_error(res);
+}
+
+uint32_t tee2sks_add_attribute(struct sks_attrs_head **head, uint32_t sks_id,
+				TEE_ObjectHandle tee_obj, uint32_t tee_id)
+{
+	uint32_t rv = 0;
+	void *a_ptr = NULL;
+	size_t a_size = 0;
+
+	rv = alloc_get_tee_attribute_data(tee_obj, tee_id, &a_ptr, &a_size);
+	if (rv)
+		goto bail;
+
+	rv = add_attribute(head, sks_id, a_ptr, a_size);
+
+	TEE_Free(a_ptr);
+
+bail:
+	if (rv)
+		EMSG("Failed TEE attribute 0x%" PRIx32 "for %s (0x%" PRIx32 ")",
+				tee_id, sks2str_attr(sks_id), sks_id);
+	return rv;
+}
+
+uint32_t entry_generate_key_pair(uintptr_t teesess,
+				 TEE_Param *ctrl, TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_attribute_head *proc_params = NULL;
+	struct sks_attrs_head *pub_head = NULL;
+	struct sks_attrs_head *priv_head = NULL;
+	struct sks_object_head *template = NULL;
+	size_t template_size = 0;
+	uint32_t pubkey_handle = 0;
+	uint32_t privkey_handle = 0;
+	uint32_t *hdl_ptr = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < 2 * sizeof(uint32_t))
+		return SKS_SHORT_BUFFER;
+
+	// FIXME: cleaner way to test alignment of out buffer
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = get_ready_session(&session, session_handle, teesess);
+	if (rv)
+		return rv;
+
+	/* Get mechanism parameters */
+	rv = serialargs_alloc_get_one_attribute(&ctrlargs, &proc_params);
+	if (rv)
+		goto bail;
+
+	rv = check_mechanism_against_processing(session, proc_params->id,
+						SKS_FUNCTION_GENERATE_PAIR,
+						SKS_FUNC_STEP_INIT);
+	if (rv)
+		goto bail;
+
+	switch (proc_params->id) {
+	case SKS_CKM_EC_KEY_PAIR_GEN:
+	case SKS_CKM_RSA_PKCS_KEY_PAIR_GEN:
+		break;
+	default:
+		rv = SKS_CKR_MECHANISM_INVALID;
+		break;
+	}
+
+	/* Get and check public key attributes */
+	rv = serialargs_alloc_get_attributes(&ctrlargs, &template);
+	if (rv)
+		goto bail;
+
+	template_size = sizeof(*template) + template->attrs_size;
+
+	rv = create_attributes_from_template(&pub_head, template, template_size,
+					     proc_params->id, NULL,
+					     SKS_FUNCTION_GENERATE_PAIR);
+	if (rv)
+		goto bail;
+
+	TEE_Free(template);
+	template = NULL;
+
+	rv = serialargs_alloc_get_attributes(&ctrlargs, &template);
+	if (rv)
+		goto bail;
+
+	template_size = sizeof(*template) + template->attrs_size;
+
+	rv = create_attributes_from_template(&priv_head, template, template_size,
+					     proc_params->id, NULL,
+					     SKS_FUNCTION_GENERATE_PAIR);
+	if (rv)
+		goto bail;
+
+	TEE_Free(template);
+	template = NULL;
+
+	/* Generate CKA_ID for keys if not specified by the templates */
+	rv = add_missing_attribute_id(&pub_head, &priv_head);
+	if (rv)
+		goto bail;
+
+	/* Check created object against processing and token state */
+	rv = check_created_attrs(pub_head, priv_head);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_processing(proc_params->id, pub_head);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_processing(proc_params->id, priv_head);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_token(session, pub_head);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_token(session, priv_head);
+	if (rv)
+		goto bail;
+
+	/* Generate key pair */
+	switch (proc_params->id) {
+	case SKS_CKM_EC_KEY_PAIR_GEN:
+		rv = generate_ec_keys(proc_params, &pub_head, &priv_head);
+		break;
+
+	case SKS_CKM_RSA_PKCS_KEY_PAIR_GEN:
+		rv = generate_rsa_keys(proc_params, &pub_head, &priv_head);
+		break;
+	default:
+		rv = SKS_CKR_MECHANISM_INVALID;
+		break;
+	}
+	if (rv)
+		goto bail;
+
+	TEE_Free(proc_params);
+	proc_params = NULL;
+
+	/*
+	 * Object is ready, register it and return a handle.
+	 */
+	rv = create_object(session, pub_head, &pubkey_handle);
+	if (rv)
+		goto bail;
+
+	rv = create_object(session, priv_head, &privkey_handle);
+	if (rv)
+		goto bail;
+
+	/*
+	 * Now obj_handle (through the related struct sks_object instance)
+	 * owns the serialized buffer that holds the object attributes.
+	 * We reset attrs->buffer to NULL as serializer object is no more
+	 * the attributes buffer owner.
+	 */
+	pub_head = NULL;
+	priv_head = NULL;
+	hdl_ptr = (uint32_t *)out->memref.buffer;
+
+	TEE_MemMove(hdl_ptr, &pubkey_handle, sizeof(uint32_t));
+	TEE_MemMove(hdl_ptr + 1, &privkey_handle, sizeof(uint32_t));
+	out->memref.size = 2 * sizeof(uint32_t);
+
+	IMSG("SKSs%" PRIu32 ": create key pair 0x%" PRIx32 "/0x%" PRIx32,
+	     session_handle, privkey_handle, pubkey_handle);
+
+bail:
+	TEE_Free(proc_params);
+	TEE_Free(template);
+	TEE_Free(pub_head);
+	TEE_Free(priv_head);
+
+	return rv;
+}
+
+/*
+ * entry_processing_init - Generic entry for initializing a processing
+ *
+ * @ctrl = [session-handle]
+ * @in = input data or none
+ * @out = output data or none
+ * @function - encrypt, decrypt, sign, verify, disgest, ...
+ *
+ * The generic part come that all the commands uses the same
+ * input/output invocation parameters format (ctrl/in/out).
+ */
+uint32_t entry_processing_init(uintptr_t tee_session, TEE_Param *ctrl,
+				TEE_Param *in, TEE_Param *out,
+				enum processing_func function)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_attribute_head *proc_params = NULL;
+	uint32_t key_handle = 0;
+	struct sks_object *obj = NULL;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || out)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = get_ready_session(&session, session_handle, tee_session);
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&ctrlargs, &key_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	obj = sks_handle2object(key_handle, session);
+	if (!obj)
+		return SKS_CKR_KEY_HANDLE_INVALID;
+
+	rv = set_processing_state(session, function, obj, NULL);
+	if (rv)
+		return rv;
+
+	rv = serialargs_alloc_get_one_attribute(&ctrlargs, &proc_params);
+	if (rv)
+		goto bail;
+
+	rv = check_mechanism_against_processing(session, proc_params->id,
+						function, SKS_FUNC_STEP_INIT);
+	if (rv)
+		goto bail;
+
+	rv = check_parent_attrs_against_processing(proc_params->id, function,
+						   obj->attributes);
+	if (rv)
+		goto bail;
+
+	rv = check_access_attrs_against_token(session, obj->attributes);
+	if (rv)
+		goto bail;
+
+	rv = SKS_CKR_MECHANISM_INVALID;
+	if (processing_is_tee_symm(proc_params->id)) {
+		rv = init_symm_operation(session, function, proc_params, obj);
+	}
+	if (processing_is_tee_asymm(proc_params->id)) {
+		rv = init_asymm_operation(session, function, proc_params, obj);
+	}
+	if (rv == SKS_OK) {
+		session->processing->mecha_type = proc_params->id;
+		IMSG("SKSs%" PRIu32 ": init processing %s %s",
+		     session_handle, sks2str_proc(proc_params->id),
+		     sks2str_function(function));
+	}
+
+bail:
+	if (rv && session)
+		release_active_processing(session);
+
+	TEE_Free(proc_params);
+
+	return rv;
+}
+
+/*
+ * entry_processing_step - Generic entry on active processing
+ *
+ * @ctrl = [session-handle]
+ * @in = input data or none
+ * @out = output data or none
+ * @function - encrypt, decrypt, sign, verify, disgest, ...
+ * @step - update, oneshot, final
+ *
+ * The generic part come that all the commands uses the same
+ * input/output invocation parameters format (ctrl/in/out).
+ */
+uint32_t entry_processing_step(uintptr_t tee_session, TEE_Param *ctrl,
+				TEE_Param *in, TEE_Param *out,
+				enum processing_func function,
+				enum processing_step step)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	uint32_t mecha_type = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = get_active_session(&session, session_handle, tee_session,
+				function);
+	if (rv)
+		return rv;
+
+	// TODO: check user authen and object activiation dates
+	mecha_type = session->processing->mecha_type;
+	rv = check_mechanism_against_processing(session, mecha_type,
+						function, step);
+	if (rv)
+		goto bail;
+
+	rv = SKS_CKR_MECHANISM_INVALID;
+	if (processing_is_tee_symm(mecha_type)) {
+		rv = step_symm_operation(session, function, step, in, out);
+	}
+	if (processing_is_tee_asymm(mecha_type)) {
+		rv = step_asymm_operation(session, function, step, in, out);
+	}
+	if (rv == SKS_OK) {
+		session->processing->updated = true;
+		IMSG("SKSs%" PRIu32 ": processing %s %s",
+		     session_handle, sks2str_proc(mecha_type),
+		     sks2str_function(function));
+	}
+
+bail:
+	switch (step) {
+	case SKS_FUNC_STEP_UPDATE:
+		if (rv != SKS_OK && rv != SKS_SHORT_BUFFER)
+			release_active_processing(session);
+		break;
+	default:
+		/* ONESHOT and FINAL terminates procceesing on success */
+		if (rv != SKS_SHORT_BUFFER)
+			release_active_processing(session);
+		break;
+	}
+
+	return rv;
+}
+
+/*
+ * entry_verify_oneshot - Generic entry on active processing
+ *
+ * @ctrl = [session-handle]
+ * @in = input data or none
+ * @out = output data or none
+ * @function - encrypt, decrypt, sign, verify, disgest, ...
+ * @step - update, oneshot, final
+ *
+ * The generic part come that all the commands uses the same
+ * input/output invocation parameters format (ctrl/in/out).
+ */
+uint32_t entry_verify_oneshot(uintptr_t tee_session, TEE_Param *ctrl,
+				  TEE_Param *in, TEE_Param *in2,
+				  enum processing_func function,
+				  enum processing_step step)
+
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	uint32_t mecha_type = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	assert(function == SKS_FUNCTION_VERIFY);
+	if (!ctrl)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = get_active_session(&session, session_handle, tee_session,
+				function);
+	if (rv)
+		return rv;
+
+	// TODO: check user authen and object activiation dates
+	mecha_type = session->processing->mecha_type;
+	rv = check_mechanism_against_processing(session, mecha_type,
+						function, step);
+	if (rv)
+		goto bail;
+
+	rv = SKS_CKR_MECHANISM_INVALID;
+	if (processing_is_tee_symm(mecha_type)) {
+		rv = step_symm_operation(session, function, step, in, in2);
+	}
+	if (processing_is_tee_asymm(mecha_type)) {
+		rv = step_asymm_operation(session, function, step, in, in2);
+	}
+
+	IMSG("SKSs%" PRIu32 ": verify %s %s: %s", session_handle,
+	     sks2str_proc(mecha_type), sks2str_function(function),
+	     sks2str_rc(rv));
+
+bail:
+	if (rv != SKS_SHORT_BUFFER)
+		release_active_processing(session);
+
+	return rv;
+}
+
+uint32_t entry_derive_key(uintptr_t tee_session, TEE_Param *ctrl,
+			  TEE_Param *in, TEE_Param *out)
+{
+	uint32_t rv = 0;
+	struct serialargs ctrlargs;
+	uint32_t session_handle = 0;
+	struct pkcs11_session *session = NULL;
+	struct sks_attribute_head *proc_params = NULL;
+	uint32_t parent_handle = 0;
+	struct sks_object *parent_obj;
+	struct sks_attrs_head *head = NULL;
+	struct sks_object_head *template = NULL;
+	size_t template_size = 0;
+	uint32_t out_handle = 0;
+	uint32_t __maybe_unused mecha_id = 0;
+
+	TEE_MemFill(&ctrlargs, 0, sizeof(ctrlargs));
+
+	if (!ctrl || in || !out)
+		return SKS_BAD_PARAM;
+
+	if (out->memref.size < sizeof(uint32_t)) {
+		out->memref.size = sizeof(uint32_t);
+		return SKS_SHORT_BUFFER;
+	}
+
+	if ((uintptr_t)out->memref.buffer & 0x3UL)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&ctrlargs, ctrl->memref.buffer, ctrl->memref.size);
+
+	rv = serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = get_ready_session(&session, session_handle, tee_session);
+	if (rv)
+		return rv;
+
+	rv = serialargs_alloc_get_one_attribute(&ctrlargs, &proc_params);
+	if (rv)
+		goto bail;
+
+	rv = serialargs_get(&ctrlargs, &parent_handle, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	parent_obj = sks_handle2object(parent_handle, session);
+	if (!parent_obj) {
+		rv = SKS_CKR_KEY_HANDLE_INVALID;
+		goto bail;
+	}
+
+	rv = set_processing_state(session, SKS_FUNCTION_DERIVE,
+				  parent_obj, NULL);
+	if (rv)
+		goto bail;
+
+	rv = serialargs_alloc_get_attributes(&ctrlargs, &template);
+	if (rv)
+		goto bail;
+
+	template_size = sizeof(*template) + template->attrs_size;
+
+	rv = check_mechanism_against_processing(session, proc_params->id,
+						SKS_FUNCTION_DERIVE,
+						SKS_FUNC_STEP_INIT);
+	if (rv)
+		goto bail;
+
+	rv = create_attributes_from_template(&head, template, template_size,
+					     proc_params->id, parent_obj->attributes,
+					     SKS_FUNCTION_DERIVE);
+	if (rv)
+		goto bail;
+
+	TEE_Free(template);
+	template = NULL;
+
+	rv = check_created_attrs(head, NULL);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_processing(proc_params->id, head);
+	if (rv)
+		goto bail;
+
+	rv = check_created_attrs_against_token(session, head);
+	if (rv)
+		goto bail;
+
+	// TODO: check_created_against_parent(session, parent, child);
+	// This can handle DERVIE_TEMPLATE attributes from the parent key.
+
+	rv = SKS_CKR_MECHANISM_INVALID;
+	if (processing_is_tee_symm(proc_params->id)) {
+		rv = init_symm_operation(session, SKS_FUNCTION_DERIVE,
+					 proc_params, parent_obj);
+		if (rv)
+			goto bail;
+
+		rv = do_symm_derivation(session, proc_params,
+					parent_obj, &head);
+	}
+	if (processing_is_tee_asymm(proc_params->id)) {
+		rv = init_asymm_operation(session, SKS_FUNCTION_DERIVE,
+					  proc_params, parent_obj);
+		if (rv)
+			goto bail;
+
+		rv = do_asymm_derivation(session, proc_params, &head);
+	}
+	if (rv)
+		goto bail;
+
+#if 0
+	/* Exaustive list */
+	switch (proc_params->id) {
+	case SKS_CKM_ECDH1_DERIVE:	<--------------------------- TODO
+	//case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+	case SKS_CKM_DH_PKCS_DERIVE:	<--------------------------- TODO
+	case SKS_CKM_X9_42_DH_DERIVE:
+	case SKS_CKM_X9_42_DH_HYBRID_DERIVE:
+	case SKS_CKM_X9_42_MQV_DERIVE:
+	case SKS_CKM_AES_GMAC
+	case SKS_CKM_AES_ECB_ENCRYPT_DATA	<------------------- TODO
+	case SKS_CKM_AES_CBC_ENCRYPT_DATA	<------------------- TODO
+	case SKS_CKM_SHA1_KEY_DERIVATION
+	case SKS_CKM_SHA224_KEY_DERIVATION
+	case SKS_CKM_SHA256_KEY_DERIVATION
+	case SKS_CKM_SHA384_KEY_DERIVATION
+	case SKS_CKM_SHA512_KEY_DERIVATION
+	case SKS_CKM_SHA512_224_KEY_DERIVATION
+	case SKS_CKM_SHA512_256_KEY_DERIVATION
+	case SKS_CKM_SHA512_T_KEY_DERIVATION
+	// Exhaustive list is made of Camelia, Aria, Seed, KIP, GOSTR3410,
+	// DES, 3DES, SSL3, TLS12, TLS-KDF, WTLS and concatenate  mechanisms.
+	case SKS_CKM_ECMQV_DERIVE:
+	}
+#endif
+
+	mecha_id = proc_params->id;
+	TEE_Free(proc_params);
+	proc_params = NULL;
+
+	/*
+	 * Object is ready, register it and return a handle.
+	 */
+	rv = create_object(session, head, &out_handle);
+	if (rv)
+		goto bail;
+
+	/*
+	 * Now out_handle (through the related struct sks_object instance)
+	 * owns the serialized buffer that holds the object attributes.
+	 * We reset attrs->buffer to NULL as serializer object is no more
+	 * the attributes buffer owner.
+	 */
+	head = NULL;
+
+	TEE_MemMove(out->memref.buffer, &out_handle, sizeof(uint32_t));
+	out->memref.size = sizeof(uint32_t);
+
+	IMSG("SKSs%" PRIu32 ": derive key Ox%" PRIx32 ", %s",
+	     session_handle, out_handle, sks2str_proc(mecha_id));
+
+bail:
+	release_active_processing(session);
+	TEE_Free(proc_params);
+	TEE_Free(template);
+	TEE_Free(head);
+
+	return rv;
+}
diff --git a/ta/secure_key_services/src/processing.h b/ta/secure_key_services/src/processing.h
new file mode 100644
index 00000000..dfba2532
--- /dev/null
+++ b/ta/secure_key_services/src/processing.h
@@ -0,0 +1,170 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#ifndef __SKS_PROCESSING_H__
+#define __SKS_PROCESSING_H__
+
+#include <tee_internal_api.h>
+#include <pkcs11_attributes.h>
+
+struct pkcs11_session;
+struct sks_object;
+struct active_processing;
+
+/*
+ * Entry points frpom SKS TA invocation commands
+ */
+
+uint32_t entry_import_object(uintptr_t teesess, TEE_Param *ctrl,
+			     TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_generate_secret(uintptr_t teesess, TEE_Param *ctrl,
+			       TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_generate_key_pair(uintptr_t teesess, TEE_Param *ctrl,
+				 TEE_Param *in, TEE_Param *out);
+
+uint32_t entry_processing_init(uintptr_t tee_session, TEE_Param *ctrl,
+				TEE_Param *in, TEE_Param *out,
+				enum processing_func function);
+
+uint32_t entry_processing_step(uintptr_t tee_session, TEE_Param *ctrl,
+				TEE_Param *in, TEE_Param *out,
+				enum processing_func function,
+				enum processing_step step);
+
+/* verify_oneshot is specific since it get 2 input data buffers */
+uint32_t entry_verify_oneshot(uintptr_t tee_session, TEE_Param *ctrl,
+				  TEE_Param *in1, TEE_Param *in2,
+				  enum processing_func function,
+				  enum processing_step step);
+
+uint32_t entry_derive_key(uintptr_t teesess, TEE_Param *ctrl,
+			  TEE_Param *in, TEE_Param *out);
+
+/*
+ * Util
+ */
+size_t get_object_key_bit_size(struct sks_object *obj);
+
+void release_active_processing(struct pkcs11_session *session);
+
+uint32_t alloc_get_tee_attribute_data(TEE_ObjectHandle tee_obj,
+					     uint32_t attribute,
+					     void **data, size_t *size);
+
+uint32_t tee2sks_add_attribute(struct sks_attrs_head **head, uint32_t sks_id,
+				TEE_ObjectHandle tee_obj, uint32_t tee_id);
+
+/*
+ * Symmetric crypto algorithm specific functions
+ */
+bool processing_is_tee_symm(uint32_t proc_id);
+
+uint32_t init_symm_operation(struct pkcs11_session *session,
+				enum processing_func function,
+				struct sks_attribute_head *proc_params,
+				struct sks_object *key);
+
+uint32_t step_symm_operation(struct pkcs11_session *session,
+				enum processing_func function,
+				enum processing_step step,
+				TEE_Param *io1, TEE_Param *io2);
+
+void tee_release_ctr_operation(struct active_processing *processing);
+uint32_t tee_init_ctr_operation(struct active_processing *processing,
+				    void *proc_params, size_t params_size);
+
+uint32_t tee_ae_decrypt_update(struct active_processing *processing,
+			       void *in, size_t in_size);
+
+uint32_t tee_ae_decrypt_final(struct active_processing *processing,
+			      void *out, uint32_t *out_size);
+
+uint32_t tee_ae_encrypt_final(struct active_processing *processing,
+			      void *out, uint32_t *out_size);
+
+void tee_release_ccm_operation(struct active_processing *processing);
+uint32_t tee_init_ccm_operation(struct active_processing *processing,
+				    void *proc_params, size_t params_size);
+
+void tee_release_gcm_operation(struct active_processing *processing);
+uint32_t tee_init_gcm_operation(struct active_processing *processing,
+				    void *proc_params, size_t params_size);
+
+/*  Asymmetric key operations util */
+bool processing_is_tee_asymm(uint32_t proc_id);
+
+uint32_t init_asymm_operation(struct pkcs11_session *session,
+				enum processing_func function,
+				struct sks_attribute_head *proc_params,
+				struct sks_object *obj);
+
+uint32_t do_symm_derivation(struct pkcs11_session *session,
+			     struct sks_attribute_head *proc_params,
+			     struct sks_object *parent_key,
+			     struct sks_attrs_head **head);
+
+uint32_t step_asymm_operation(struct pkcs11_session *session,
+			      enum processing_func function,
+			      enum processing_step step,
+			      TEE_Param *io1, TEE_Param *io2);
+
+uint32_t do_asymm_derivation(struct pkcs11_session *session,
+			     struct sks_attribute_head *proc_params,
+			     struct sks_attrs_head **head);
+
+
+/*
+ * Elliptic curve crypto algorithm specific functions
+ */
+uint32_t load_tee_ec_key_attrs(TEE_Attribute **tee_attrs, size_t *tee_count,
+				struct sks_object *obj);
+
+size_t ec_params2tee_keysize(void *attr, size_t size);
+
+uint32_t ec_params2tee_curve(void *attr, size_t size);
+
+uint32_t sks2tee_algo_ecdh(uint32_t *tee_id,
+			   struct sks_attribute_head *proc_params,
+			   struct sks_object *obj);
+
+uint32_t sks2tee_ecdh_param_pub(struct sks_attribute_head *proc_params,
+			        void **pub_data, size_t *pub_size);
+
+uint32_t sks2tee_algo_ecdsa(uint32_t *tee_id,
+			   struct sks_attribute_head *proc_params,
+			   struct sks_object *obj);
+
+uint32_t generate_ec_keys(struct sks_attribute_head *proc_params,
+			  struct sks_attrs_head **pub_head,
+			  struct sks_attrs_head **priv_head);
+
+/*
+ * RSA crypto algorithm specific functions
+ */
+uint32_t load_tee_rsa_key_attrs(TEE_Attribute **tee_attrs, size_t *tee_count,
+				struct sks_object *obj);
+
+uint32_t sks2tee_proc_params_rsa_pss(struct active_processing *processing,
+				     struct sks_attribute_head *proc_params);
+
+void tee_release_rsa_pss_operation(struct active_processing *processing);
+
+uint32_t sks2tee_algo_rsa_pss(uint32_t *tee_id,
+				struct sks_attribute_head *proc_params);
+
+uint32_t sks2tee_algo_rsa_oaep(uint32_t *tee_id,
+				struct sks_attribute_head *proc_params);
+
+uint32_t tee_init_rsa_aes_key_wrap_operation(struct active_processing *proc,
+					     void *proc_params,
+					     size_t params_size);
+
+uint32_t generate_rsa_keys(struct sks_attribute_head *proc_params,
+			   struct sks_attrs_head **pub_head,
+			   struct sks_attrs_head **priv_head);
+
+#endif /*__SKS_PROCESSING_H__*/
diff --git a/ta/secure_key_services/src/processing_aes.c b/ta/secure_key_services/src/processing_aes.c
new file mode 100644
index 00000000..6a4097f4
--- /dev/null
+++ b/ta/secure_key_services/src/processing_aes.c
@@ -0,0 +1,658 @@
+/*
+ * Copyright (c) 2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <assert.h>
+#include <compiler.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+#include "pkcs11_token.h"
+#include "processing.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+uint32_t tee_init_ctr_operation(struct active_processing *processing,
+				    void *proc_params, size_t params_size)
+{
+	struct serialargs args;
+	uint32_t rv = 0;
+	/* CTR parameters */
+	uint32_t incr_counter = 0;
+	void *counter_bits = NULL;
+
+	TEE_MemFill(&args, 0, sizeof(args));
+
+	if (!proc_params)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&args, proc_params, params_size);
+
+	rv = serialargs_get(&args, &incr_counter, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	rv = serialargs_get_ptr(&args, &counter_bits, 16);
+	if (rv)
+		goto bail;
+
+	if (incr_counter != 1) {
+		DMSG("Supports only 1 bit increment counter: %d",
+						incr_counter);
+		rv = SKS_CKR_MECHANISM_PARAM_INVALID;
+		goto bail;
+	}
+
+	TEE_CipherInit(processing->tee_op_handle, counter_bits, 16);
+
+	rv = SKS_OK;
+
+bail:
+	return rv;
+}
+
+void tee_release_ctr_operation(struct active_processing *processing __unused)
+{
+}
+
+/*
+ * Authenticated ciphering: (CCM / GCM)
+ *
+ * As per PKCS#11, CCM/GCM decrypt shall not revealed the data until the
+ * decryption is completed and the mac verified. The SKS TA must retain the
+ * ciphered data until the CCM finalization. To do so, arrays of decrypted
+ * data are allocated during AE update processing and copied into client
+ * buffer at AE finalization.
+ *
+ * As per PKCS#11, CCM/GCM decrypt expect the tag/mac data to be provided
+ * inside the input data for DecryptUpdate() and friends. But the DecryptFinal
+ * API does not provide input data reference hence we do not know which is the
+ * last call to DecryptUpdate() where last bytes are not ciphered data but the
+ * requested tag/mac byte. To handle this, the TA saves the last input data
+ * bytes (length is defined by the tag byte size) in the AE context and
+ * waits the DecryptFinal() to either treat these as data bytes or tag/mac
+ * bytes. Refer to pending_tag and pending_size in struct ae_aes_context.
+ */
+
+/*
+ * @size - byte size of the allocated buffer
+ * @data - pointer to allocated data
+ */
+struct out_data_ref {
+	size_t size;
+	void *data;
+};
+
+/*
+ * @tag_byte_len - tag size in byte
+ * @pending_tag - Input data that could be the appended tag
+ * @pending_size - Size of pending input data that could be the tag
+ * @out_data - Pointer to an array of output data references.
+ * @out_count - Number of buffer references in out_data
+ */
+struct ae_aes_context {
+	size_t tag_byte_len;
+	char *pending_tag;
+	size_t pending_size;
+	struct out_data_ref *out_data;
+	size_t out_count;
+};
+
+static void release_ae_aes_context(struct ae_aes_context *ctx)
+{
+	size_t n = 0;
+
+	for (n = 0; n < ctx->out_count; n++) {
+		TEE_Free(ctx->out_data[n].data);
+	}
+
+	TEE_Free(ctx->out_data);
+	ctx->out_data = NULL;
+	ctx->out_count = 0;
+
+	TEE_Free(ctx->pending_tag);
+	ctx->pending_tag = NULL;
+}
+
+uint32_t tee_ae_decrypt_update(struct active_processing *processing,
+			       void *in, size_t in_size)
+{
+	struct ae_aes_context *ctx = processing->extra_ctx;
+	size_t data_len = 0;
+	uint32_t size = 0;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint32_t rv = 0;
+	char *ct = NULL;
+	uint32_t ct_size = 0;
+	void *ptr = NULL;
+
+	if (!in_size)
+		return SKS_OK;
+
+	if (!in)
+		return SKS_BAD_PARAM;
+
+	/*
+	 * Save the last input bytes in case they are the tag
+	 * bytes and not ciphered data bytes to be decrypted.
+	 */
+
+	if (ctx->pending_size + in_size <= ctx->tag_byte_len) {
+		/*
+		 * Data bytes are all potential tag bytes.
+		 * We only need to update the pending_tag buffer,
+		 * and cannot treat any byte as data byte.
+		 */
+		TEE_MemMove(ctx->pending_tag + ctx->pending_size, in, in_size);
+
+		ctx->pending_size += in_size;
+
+		return SKS_OK;
+	}
+
+	/* Size of data that are not potential tag in pendings and input data */
+	data_len = in_size + ctx->pending_size - ctx->tag_byte_len;
+
+	if (ctx->pending_size &&
+	    (ctx->pending_size + in_size) >= ctx->tag_byte_len) {
+		/* Process pending tag bytes that are effective data byte */
+		uint32_t len = MIN(data_len, ctx->pending_size);
+
+		res = TEE_AEUpdate(processing->tee_op_handle,
+				   ctx->pending_tag, len, NULL, &ct_size);
+
+		// TODO: explain this
+		if (res != TEE_ERROR_SHORT_BUFFER &&
+		    (res != TEE_SUCCESS || ct_size)) {
+			rv = SKS_ERROR;
+			goto bail;
+		}
+
+		/*
+		 * If output data to store (not revealed yet), redo with
+		 * an allocated temporary reference.
+		 */
+		if (ct_size) {
+			ct = TEE_Malloc(ct_size, TEE_USER_MEM_HINT_NO_FILL_ZERO);
+			if (!ct) {
+				rv = SKS_MEMORY;
+				goto bail;
+			}
+
+			res = TEE_AEUpdate(processing->tee_op_handle,
+					   ctx->pending_tag, len, ct, &ct_size);
+			if (res) {
+				rv = tee2sks_error(res);
+				goto bail;
+			}
+
+			/* Finally, no out data? Release temp buffer. */
+			if (!ct_size) {
+				TEE_Free(ct);
+				ct = NULL;
+				DMSG_RAW("\nWe expected some data!\n\n");
+			}
+		}
+
+		/* Save pontential tag bytes for later */
+		TEE_MemMove(ctx->pending_tag, ctx->pending_tag + len,
+			    ctx->pending_size - len);
+
+		ctx->pending_size -= len;
+		data_len -= len;
+	}
+
+	if (data_len) {
+		/* Process input data that are not potential tag bytes */
+		size = 0;
+		res = TEE_AEUpdate(processing->tee_op_handle,
+				   in, data_len, NULL, &size);
+
+		if (res != TEE_ERROR_SHORT_BUFFER &&
+		    (res != TEE_SUCCESS || size)) {
+			rv = SKS_ERROR;
+			goto bail;
+		}
+
+		if (size) {
+			ptr = TEE_Realloc(ct, ct_size + size);
+			if (!ptr) {
+				rv = SKS_MEMORY;
+				goto bail;
+			}
+			ct = ptr;
+
+			res = TEE_AEUpdate(processing->tee_op_handle,
+					   in, data_len, ct + ct_size, &size);
+			if (res) {
+				rv = tee2sks_error(res);
+				goto bail;
+			}
+
+			ct_size += size;
+		}
+	}
+
+	/* Update pending tag in context if any */
+	data_len = in_size - data_len;
+	if (data_len > (ctx->tag_byte_len - ctx->pending_size)) {
+		/* This could be asserted */
+		rv = SKS_ERROR;
+		goto bail;
+	}
+
+	if (data_len) {
+		TEE_MemMove(ctx->pending_tag + ctx->pending_size,
+			    (char *)in + in_size - data_len, data_len);
+
+		ctx->pending_size += data_len;
+	}
+
+	/* Save output data reference in the context */
+	if (ct_size) {
+		ptr = TEE_Realloc(ctx->out_data, (ctx->out_count + 1) *
+				  sizeof(struct out_data_ref));
+		if (!ptr) {
+			rv = SKS_MEMORY;
+			goto bail;
+		}
+		ctx->out_data = ptr;
+		ctx->out_data[ctx->out_count].size = ct_size;
+		ctx->out_data[ctx->out_count].data = ct;
+		ctx->out_count++;
+	}
+
+	rv = SKS_OK;
+
+bail:
+	if (rv) {
+		TEE_Free(ct);
+	}
+
+	return rv;
+}
+
+static uint32_t reveale_ae_data(struct ae_aes_context *ctx,
+				void *out, uint32_t *out_size)
+{
+	size_t n = 0;
+	uint32_t req_size = 0;
+	char *out_ptr = out;
+
+	for (req_size = 0, n = 0; n < ctx->out_count; n++)
+		req_size += ctx->out_data[n].size;
+
+	if (*out_size < req_size) {
+		*out_size = req_size;
+		return SKS_SHORT_BUFFER;
+	}
+
+	if (!out_ptr)
+		return SKS_BAD_PARAM;
+
+	for (n = 0; n < ctx->out_count; n++) {
+		TEE_MemMove(out_ptr,
+			    ctx->out_data[n].data, ctx->out_data[n].size);
+
+		TEE_Free(ctx->out_data[n].data);
+		out_ptr += ctx->out_data[n].size;
+	}
+
+	TEE_Free(ctx->out_data);
+	ctx->out_data = NULL;
+	ctx->out_count = 0;
+
+	*out_size = req_size;
+
+	return SKS_OK;
+}
+
+uint32_t tee_ae_decrypt_final(struct active_processing *processing,
+			      void *out, uint32_t *out_size)
+{
+	struct ae_aes_context *ctx = processing->extra_ctx;
+	uint32_t rv = 0;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint32_t data_size = 0;
+	void *data_ptr = NULL;
+
+	if (!out_size) {
+		DMSG("Expect at least a buffer for the output data");
+		return SKS_BAD_PARAM;
+	}
+
+	/* Final is already completed, only need to output the data */
+	if (!ctx->pending_tag)
+		return reveale_ae_data(ctx, out, out_size);
+
+	if (ctx->pending_size != ctx->tag_byte_len) {
+		DMSG("Not enougth samples: %lu/%lu",
+			ctx->pending_size, ctx->tag_byte_len);
+		return SKS_FAILED;	// FIXME: CKR_ENCRYPTED_DATA_LEN_RANGE
+	}
+
+	data_size = 0;
+	res = TEE_AEDecryptFinal(processing->tee_op_handle,
+				 NULL, 0, NULL, &data_size,
+				 ctx->pending_tag, ctx->tag_byte_len);
+
+	if (res == TEE_ERROR_SHORT_BUFFER) {
+		data_ptr = TEE_Malloc(data_size,
+				      TEE_USER_MEM_HINT_NO_FILL_ZERO);
+		if (!data_ptr) {
+			rv = SKS_MEMORY;
+			goto bail;
+		}
+
+		res = TEE_AEDecryptFinal(processing->tee_op_handle,
+					 NULL, 0, data_ptr, &data_size,
+					 ctx->pending_tag, ctx->tag_byte_len);
+
+		if (!data_size) {
+			TEE_Free(data_ptr);
+			data_ptr = NULL;
+			DMSG_RAW("\nIs this expected from the Core API?\n\n");
+		}
+	}
+
+	/* AE decryption is completed */
+	TEE_Free(ctx->pending_tag);
+	ctx->pending_tag = NULL;
+
+	rv = tee2sks_error(res);
+	if (rv)
+		goto bail;
+
+	if (data_ptr) {
+		void *tmp_ptr = NULL;
+
+		tmp_ptr = TEE_Realloc(ctx->out_data,
+					(ctx->out_count + 1) *
+					sizeof(struct out_data_ref));
+		if (!tmp_ptr) {
+			rv = SKS_MEMORY;
+			goto bail;
+		}
+		ctx->out_data = tmp_ptr;
+		ctx->out_data[ctx->out_count].size = data_size;
+		ctx->out_data[ctx->out_count].data = data_ptr;
+		ctx->out_count++;
+
+		data_ptr = NULL;
+	}
+
+	rv = reveale_ae_data(ctx, out, out_size);
+
+bail:
+	TEE_Free(data_ptr);
+
+	return rv;
+}
+
+uint32_t tee_ae_encrypt_final(struct active_processing *processing,
+			      void *out, uint32_t *out_size)
+{
+	struct ae_aes_context *ctx = processing->extra_ctx;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint8_t *tag = NULL;
+	uint32_t tag_len = 0;
+	uint32_t size = 0;
+
+	if (!out || !out_size)
+		return SKS_BAD_PARAM;
+
+	/* Check the required sizes (warning: 2 output len: data + tag) */
+	res = TEE_AEEncryptFinal(processing->tee_op_handle,
+				 NULL, 0, NULL, &size,
+				 &tag, &tag_len);
+
+	if (tag_len != ctx->tag_byte_len ||
+	    (res != TEE_SUCCESS && res != TEE_ERROR_SHORT_BUFFER)) {
+		EMSG("Unexpected tag length %u/%zu or rc 0x%" PRIx32,
+			tag_len, ctx->tag_byte_len, res);
+		return SKS_ERROR;
+	}
+
+	if (*out_size < size + tag_len) {
+		*out_size = size + tag_len;
+		return SKS_SHORT_BUFFER;
+	}
+
+	/* Process data and tag input the client output buffer */
+	tag = (uint8_t *)out + size;
+
+	res = TEE_AEEncryptFinal(processing->tee_op_handle,
+				 NULL, 0, out, &size, tag, &tag_len);
+
+	if (tag_len != ctx->tag_byte_len) {
+		EMSG("Unexpected tag length");
+		return SKS_ERROR;
+	}
+
+	if (!res)
+		*out_size = size + tag_len;
+
+	return tee2sks_error(res);
+}
+
+uint32_t tee_init_ccm_operation(struct active_processing *processing,
+				void *proc_params, size_t params_size)
+{
+	uint32_t rv = 0;
+	struct ae_aes_context *params = NULL;
+	struct serialargs args;
+	/* CCM parameters */
+	uint32_t data_len = 0;
+	uint32_t nonce_len = 0;
+	void *nonce = NULL;
+	uint32_t aad_len = 0;
+	void *aad = NULL;
+	uint32_t mac_len = 0;
+
+	TEE_MemFill(&args, 0, sizeof(args));
+
+	if (!proc_params)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&args, proc_params, params_size);
+
+	rv = serialargs_get(&args, &data_len, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	rv = serialargs_get(&args, &nonce_len, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	// TODO: no need to copy nonce into secure world
+	rv = serialargs_alloc_and_get(&args, &nonce, nonce_len);
+	if (rv)
+		goto bail;
+
+	rv = serialargs_get(&args, &aad_len, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	// TODO: no need to copy aad into secure world
+	rv = serialargs_alloc_and_get(&args, &aad, aad_len);
+	if (rv)
+		goto bail;
+
+	rv = serialargs_get(&args, &mac_len, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	/* As per pkcs#11 mechanism specification */
+	if (data_len > 28 ||
+	    !nonce_len || nonce_len > 15 ||
+	    aad_len > 256 ||
+	    mac_len < 4 || mac_len > 16 || mac_len & 1) {
+		DMSG("Invalid parameters: data_len %" PRIu32
+			", nonce_len %" PRIu32 ", aad_len %" PRIu32
+			", mac_len %" PRIu32, data_len, nonce_len,
+			aad_len, mac_len);
+		rv = SKS_CKR_MECHANISM_PARAM_INVALID;
+		goto bail;
+	}
+
+	params = TEE_Malloc(sizeof(struct ae_aes_context),
+			    TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!params) {
+		rv = SKS_MEMORY;
+		goto bail;
+	}
+
+	params->tag_byte_len = mac_len;
+	params->out_count = 0;
+	params->pending_size = 0;
+	params->out_data = TEE_Malloc(sizeof(struct out_data_ref),
+				      TEE_MALLOC_FILL_ZERO);
+	params->pending_tag = TEE_Malloc(mac_len,
+					 TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!params->out_data || !params->pending_tag) {
+		rv = SKS_MEMORY;
+		goto bail;
+	}
+
+	TEE_AEInit(processing->tee_op_handle, nonce, nonce_len, mac_len * 8,
+					   aad_len, data_len);
+	if (aad_len)
+		TEE_AEUpdateAAD(processing->tee_op_handle, aad, aad_len);
+
+	/* Session processing owns the active processing params */
+	assert(!processing->extra_ctx);
+	processing->extra_ctx = params;
+
+	rv = SKS_OK;
+
+bail:
+	TEE_Free(nonce);
+	TEE_Free(aad);
+	if (rv && params) {
+		TEE_Free(params->out_data);
+		TEE_Free(params->pending_tag);
+		TEE_Free(params);
+	}
+	return rv;
+}
+
+void tee_release_ccm_operation(struct active_processing *processing)
+{
+	struct ae_aes_context *ctx = processing->extra_ctx;
+
+	release_ae_aes_context(ctx);
+	TEE_Free(processing->extra_ctx);
+	processing->extra_ctx = NULL;
+}
+
+/*
+ * GCM
+ */
+uint32_t tee_init_gcm_operation(struct active_processing *processing,
+				    void *proc_params, size_t params_size)
+{
+	struct serialargs args;
+	uint32_t rv = 0;
+	uint32_t tag_len = 0;
+	struct ae_aes_context *params = NULL;
+	/* GCM parameters */
+	uint32_t iv_len = 0;
+	void *iv = NULL;
+	uint32_t aad_len = 0;
+	void *aad = NULL;
+	uint32_t tag_bitlen = 0;
+
+	TEE_MemFill(&args, 0, sizeof(args));
+
+	if (!proc_params)
+		return SKS_BAD_PARAM;
+
+	serialargs_init(&args, proc_params, params_size);
+
+	rv = serialargs_get(&args, &iv_len, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	// TODO: no need to copy iv into secure world
+	rv = serialargs_alloc_and_get(&args, &iv, iv_len);
+	if (rv)
+		goto bail;
+
+	rv = serialargs_get(&args, &aad_len, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	// TODO: no need to copy aad into secure world
+	rv = serialargs_alloc_and_get(&args, &aad, aad_len);
+	if (rv)
+		goto bail;
+
+	rv = serialargs_get(&args, &tag_bitlen, sizeof(uint32_t));
+	if (rv)
+		goto bail;
+
+	tag_len = ROUNDUP(tag_bitlen, 8) / 8;
+
+	/* As per pkcs#11 mechanism specification */
+	if (tag_bitlen > 128 ||
+	    !iv_len || iv_len > 256) {
+		DMSG("Invalid parameters: tag_bit_len %" PRIu32
+			", iv_len %" PRIu32, tag_bitlen, iv_len);
+		rv = SKS_CKR_MECHANISM_PARAM_INVALID;
+		goto bail;
+	}
+
+	params = TEE_Malloc(sizeof(struct ae_aes_context),
+			    TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!params) {
+		rv = SKS_MEMORY;
+		goto bail;
+	}
+
+	/* Store the byte round up byte length for the tag */
+	params->tag_byte_len = tag_len;
+	params->out_count = 0;
+	params->pending_size = 0;
+	params->out_data = TEE_Malloc(sizeof(struct out_data_ref),
+				      TEE_MALLOC_FILL_ZERO);
+	params->pending_tag = TEE_Malloc(tag_len,
+					 TEE_USER_MEM_HINT_NO_FILL_ZERO);
+
+	if (!params->out_data || !params->pending_tag) {
+		rv = SKS_MEMORY;
+		goto bail;
+	}
+
+	/* Session processing owns the active processing params */
+	assert(!processing->extra_ctx);
+	processing->extra_ctx = params;
+
+	TEE_AEInit(processing->tee_op_handle, iv, iv_len, tag_bitlen, 0, 0);
+
+	if (aad_len)
+		TEE_AEUpdateAAD(processing->tee_op_handle, aad, aad_len);
+
+	rv = SKS_OK;
+
+bail:
+	TEE_Free(iv);
+	TEE_Free(aad);
+	if (rv && params) {
+		TEE_Free(params->out_data);
+		TEE_Free(params->pending_tag);
+		TEE_Free(params);
+	}
+
+	return rv;
+}
+
+void tee_release_gcm_operation(struct active_processing *processing)
+{
+	struct ae_aes_context *ctx = processing->extra_ctx;
+
+	release_ae_aes_context(ctx);
+	TEE_Free(processing->extra_ctx);
+	processing->extra_ctx = NULL;
+}
diff --git a/ta/secure_key_services/src/processing_asymm.c b/ta/secure_key_services/src/processing_asymm.c
new file mode 100644
index 00000000..dd58513c
--- /dev/null
+++ b/ta/secure_key_services/src/processing_asymm.c
@@ -0,0 +1,682 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2018, Linaro Limited
+ */
+
+#include <assert.h>
+#include <compiler.h>
+#include <tee_api_defines.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+#include "attributes.h"
+#include "pkcs11_token.h"
+#include "processing.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+bool processing_is_tee_asymm(uint32_t proc_id)
+{
+	switch (proc_id) {
+	/* RSA flavors */
+	case SKS_CKM_RSA_PKCS:
+	case SKS_CKM_RSA_PKCS_OAEP:
+	case SKS_CKM_SHA1_RSA_PKCS:
+	case SKS_CKM_SHA224_RSA_PKCS:
+	case SKS_CKM_SHA256_RSA_PKCS:
+	case SKS_CKM_SHA384_RSA_PKCS:
+	case SKS_CKM_SHA512_RSA_PKCS:
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+	/* EC flavors */
+	case SKS_CKM_ECDSA:
+	case SKS_CKM_ECDSA_SHA1:
+	case SKS_CKM_ECDSA_SHA224:
+	case SKS_CKM_ECDSA_SHA256:
+	case SKS_CKM_ECDSA_SHA384:
+	case SKS_CKM_ECDSA_SHA512:
+	case SKS_CKM_ECDH1_DERIVE:
+	case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static uint32_t sks2tee_algorithm(uint32_t *tee_id,
+				  enum processing_func function,
+				  struct sks_attribute_head *proc_params,
+				  struct sks_object *obj)
+{
+	static const uint32_t sks2tee_algo[][2] = {
+		/* RSA flavors */
+		{ SKS_CKM_RSA_PKCS, TEE_ALG_RSAES_PKCS1_V1_5
+				/* TEE_ALG_RSASSA_PKCS1_V1_5 on signatures */ },
+		{ SKS_CKM_RSA_PKCS_OAEP, 1 }, /* Need to look into params */
+		{ SKS_CKM_SHA1_RSA_PKCS, TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 },
+		{ SKS_CKM_SHA224_RSA_PKCS, TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 },
+		{ SKS_CKM_SHA256_RSA_PKCS, TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 },
+		{ SKS_CKM_SHA384_RSA_PKCS, TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 },
+		{ SKS_CKM_SHA512_RSA_PKCS, TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 },
+		{ SKS_CKM_SHA1_RSA_PKCS_PSS,
+					TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 },
+		{ SKS_CKM_SHA224_RSA_PKCS_PSS,
+					TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 },
+		{ SKS_CKM_SHA256_RSA_PKCS_PSS,
+					TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 },
+		{ SKS_CKM_SHA384_RSA_PKCS_PSS,
+					TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 },
+		{ SKS_CKM_SHA512_RSA_PKCS_PSS,
+					TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 },
+		/* EC flavors (Must find key size from the object) */
+		{ SKS_CKM_ECDSA, 1 },
+		{ SKS_CKM_ECDSA_SHA1, 1 },
+		{ SKS_CKM_ECDSA_SHA224, 1 },
+		{ SKS_CKM_ECDSA_SHA256, 1 },
+		{ SKS_CKM_ECDSA_SHA384, 1 },
+		{ SKS_CKM_ECDSA_SHA512, 1 },
+		{ SKS_CKM_ECDH1_DERIVE, 1 },
+		{ SKS_CKM_ECDH1_COFACTOR_DERIVE, 1 },
+	};
+	size_t end = sizeof(sks2tee_algo) / (2 * sizeof(uint32_t));
+	size_t n = 0;
+	uint32_t rv = 0;
+
+	for (n = 0; n < end; n++) {
+		if (proc_params->id == sks2tee_algo[n][0]) {
+			*tee_id = sks2tee_algo[n][1];
+			break;
+		}
+	}
+
+	switch (proc_params->id) {
+	case SKS_CKM_RSA_X_509:
+	case SKS_CKM_RSA_9796:
+	case SKS_CKM_RSA_PKCS_PSS:
+		EMSG("%s not supported by GPD TEE, need an alternative...",
+			sks2str_proc(proc_params->id));
+		break;
+	default:
+		break;
+	}
+
+	if (n == end)
+		return SKS_NOT_IMPLEMENTED;
+
+	switch (proc_params->id) {
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+		rv = sks2tee_algo_rsa_pss(tee_id, proc_params);
+		break;
+	case SKS_CKM_RSA_PKCS_OAEP:
+		rv = sks2tee_algo_rsa_oaep(tee_id, proc_params);
+		break;
+	case SKS_CKM_ECDH1_DERIVE:
+		rv = sks2tee_algo_ecdh(tee_id, proc_params, obj);
+		break;
+	case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+		return SKS_NOT_IMPLEMENTED;
+	case SKS_CKM_ECDSA:
+	case SKS_CKM_ECDSA_SHA1:
+	case SKS_CKM_ECDSA_SHA224:
+	case SKS_CKM_ECDSA_SHA256:
+	case SKS_CKM_ECDSA_SHA384:
+	case SKS_CKM_ECDSA_SHA512:
+		rv = sks2tee_algo_ecdsa(tee_id, proc_params, obj);
+		break;
+	default:
+		rv = SKS_OK;
+		break;
+	}
+
+	if (*tee_id == TEE_ALG_RSAES_PKCS1_V1_5 &&
+	    (function == SKS_FUNCTION_SIGN || function == SKS_FUNCTION_VERIFY))
+		*tee_id = TEE_ALG_RSASSA_PKCS1_V1_5;
+
+	return rv;
+}
+
+static uint32_t sks2tee_key_type(uint32_t *tee_type, struct sks_object *obj,
+				 enum processing_func function)
+{
+	uint32_t class = get_class(obj->attributes);
+	uint32_t type = get_type(obj->attributes);
+
+	switch (class) {
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+		break;
+	default:
+		TEE_Panic(class);
+		break;
+	}
+
+	switch (type) {
+	case SKS_CKK_EC:
+		if (class == SKS_CKO_PRIVATE_KEY) {
+			*tee_type = (function == SKS_FUNCTION_DERIVE) ?
+					TEE_TYPE_ECDH_KEYPAIR :
+					TEE_TYPE_ECDSA_KEYPAIR;
+		} else {
+			*tee_type = (function == SKS_FUNCTION_DERIVE) ?
+					TEE_TYPE_ECDH_PUBLIC_KEY :
+					TEE_TYPE_ECDSA_PUBLIC_KEY;
+		}
+		break;
+	case SKS_CKK_RSA:
+		if (class == SKS_CKO_PRIVATE_KEY) {
+			*tee_type = TEE_TYPE_RSA_KEYPAIR;
+		} else {
+			*tee_type = TEE_TYPE_RSA_PUBLIC_KEY;
+		}
+		break;
+	default:
+		TEE_Panic(type);
+		break;
+	}
+
+	return SKS_OK;
+}
+
+static uint32_t allocate_tee_operation(struct pkcs11_session *session,
+					enum processing_func function,
+					struct sks_attribute_head *proc_params,
+					struct sks_object *obj)
+{
+	uint32_t size = (uint32_t)get_object_key_bit_size(obj);
+	uint32_t algo = 0;
+	uint32_t mode = 0;
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	assert(session->processing->tee_op_handle == TEE_HANDLE_NULL);
+
+	if (sks2tee_algorithm(&algo, function, proc_params, obj))
+		return SKS_FAILED;
+
+	sks2tee_mode(&mode, function);
+
+	res = TEE_AllocateOperation(&session->processing->tee_op_handle,
+				    algo, mode, size);
+	if (res) {
+		EMSG("TEE_AllocateOp. failed %" PRIx32 " %" PRIx32 " %" PRIx32,
+			algo, mode, size);
+	}
+
+	return tee2sks_error(res);
+}
+
+static uint32_t load_tee_key(struct pkcs11_session *session,
+				struct sks_object *obj,
+				enum processing_func function)
+{
+	TEE_Attribute *tee_attrs = NULL;
+	size_t tee_attrs_count = 0;
+	size_t object_size = 0;
+	uint32_t rv = 0;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	uint32_t __maybe_unused class = get_class(obj->attributes);
+	uint32_t type = get_type(obj->attributes);
+
+	assert(class == SKS_CKO_PUBLIC_KEY || class == SKS_CKO_PRIVATE_KEY);
+
+	if (obj->key_handle != TEE_HANDLE_NULL) {
+		switch (type) {
+		case SKS_CKK_RSA:
+			/* RSA loaded keys can be reused */
+			assert((obj->key_type == TEE_TYPE_RSA_PUBLIC_KEY &&
+				class == SKS_CKO_PUBLIC_KEY) ||
+			       (obj->key_type == TEE_TYPE_RSA_KEYPAIR &&
+				class == SKS_CKO_PRIVATE_KEY));
+			goto key_ready;
+		case SKS_CKK_EC:
+			/* Reuse EC TEE key only if already DSA or DH */
+			switch (obj->key_type) {
+			case TEE_TYPE_ECDSA_PUBLIC_KEY:
+			case TEE_TYPE_ECDSA_KEYPAIR:
+				if (function != SKS_FUNCTION_DERIVE)
+					goto key_ready;
+				break;
+			case TEE_TYPE_ECDH_PUBLIC_KEY:
+			case TEE_TYPE_ECDH_KEYPAIR:
+				if (function == SKS_FUNCTION_DERIVE)
+					goto key_ready;
+				break;
+			default:
+				assert(0);
+				break;
+			}
+			break;
+		default:
+			assert(0);
+			break;
+		}
+
+		TEE_FreeTransientObject(obj->key_handle);
+		obj->key_handle = TEE_HANDLE_NULL;
+	}
+
+	rv = sks2tee_key_type(&obj->key_type, obj, function);
+	if (rv)
+		return rv;
+
+	object_size = get_object_key_bit_size(obj);
+	if (!object_size)
+		return SKS_ERROR;
+
+	switch (type) {
+	case SKS_CKK_RSA:
+		rv = load_tee_rsa_key_attrs(&tee_attrs, &tee_attrs_count, obj);
+		break;
+	case SKS_CKK_EC:
+		rv = load_tee_ec_key_attrs(&tee_attrs, &tee_attrs_count, obj);
+		break;
+	default:
+		break;
+	}
+	if (rv)
+		return rv;
+
+	res = TEE_AllocateTransientObject(obj->key_type, object_size,
+					  &obj->key_handle);
+	if (res) {
+		DMSG("TEE_AllocateTransientObject failed, 0x%" PRIx32, res);
+		return tee2sks_error(res);
+	}
+
+	res = TEE_PopulateTransientObject(obj->key_handle,
+					  tee_attrs, tee_attrs_count);
+
+	TEE_Free(tee_attrs);
+
+	if (res) {
+		DMSG("TEE_PopulateTransientObject failed, 0x%" PRIx32, res);
+		goto error;
+	}
+
+key_ready:
+	res = TEE_SetOperationKey(session->processing->tee_op_handle,
+				  obj->key_handle);
+	if (res) {
+		DMSG("TEE_SetOperationKey failed, 0x%" PRIx32, res);
+		goto error;
+	}
+
+	return tee2sks_error(res);
+
+error:
+	TEE_FreeTransientObject(obj->key_handle);
+	obj->key_handle = TEE_HANDLE_NULL;
+	return tee2sks_error(res);
+}
+
+static uint32_t init_tee_operation(struct pkcs11_session *session,
+				   struct sks_attribute_head *proc_params)
+{
+	uint32_t rv = SKS_OK;
+
+	switch (proc_params->id) {
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+		rv = sks2tee_proc_params_rsa_pss(session->processing,
+						 proc_params);
+		break;
+	default:
+		break;
+	}
+
+	return rv;
+}
+
+uint32_t init_asymm_operation(struct pkcs11_session *session,
+				enum processing_func function,
+				struct sks_attribute_head *proc_params,
+				struct sks_object *obj)
+{
+	uint32_t rv = 0;
+
+	assert(processing_is_tee_asymm(proc_params->id));
+
+	rv = allocate_tee_operation(session, function, proc_params, obj);
+	if (rv)
+		return rv;
+
+	rv = load_tee_key(session, obj, function);
+	if (rv)
+		return rv;
+
+	return init_tee_operation(session, proc_params);
+}
+
+/*
+ * step_sym_step - step (update/oneshot/final) on a symmetric crypto operation
+ *
+ * @session - current session
+ * @function -
+ * @step - step ID in the processing (oneshot, update,final)
+ * @in - input data reference #1
+ * @io2 - nput/output data reference #2 (direction depends on function)
+ */
+uint32_t step_asymm_operation(struct pkcs11_session *session,
+			      enum processing_func function,
+			      enum processing_step step,
+			      TEE_Param *in, TEE_Param *io2)
+{
+	uint32_t rv = SKS_ERROR;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	void *in_buf = in ? in->memref.buffer : NULL;
+	size_t in_size = in ? in->memref.size : 0;
+	void *out_buf = io2 ? io2->memref.buffer : NULL;
+	uint32_t out_size = io2 ? io2->memref.size : 0;
+	void *in2_buf = io2 ? io2->memref.buffer : NULL;
+	uint32_t in2_size = io2 ? io2->memref.size : 0;
+	TEE_Attribute *tee_attrs = NULL;
+	size_t tee_attrs_count = 0;
+	uint32_t data32 = 0;
+	bool output_data = false;
+	struct active_processing *proc = session->processing;
+	TEE_OperationInfo opinfo;
+
+	switch (step) {
+	case SKS_FUNC_STEP_ONESHOT:
+	case SKS_FUNC_STEP_UPDATE:
+	case SKS_FUNC_STEP_FINAL:
+		break;
+	default:
+		return SKS_ERROR;
+	}
+
+	/* TEE attribute(s) required by the operation */
+	switch (proc->mecha_type) {
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+		tee_attrs = TEE_Malloc(sizeof(TEE_Attribute),
+					TEE_USER_MEM_HINT_NO_FILL_ZERO);
+		if (!tee_attrs) {
+			rv = SKS_MEMORY;
+			goto bail;
+		}
+
+		data32 = *(uint32_t *)proc->extra_ctx;
+		TEE_InitValueAttribute(&tee_attrs[tee_attrs_count],
+					TEE_ATTR_RSA_PSS_SALT_LENGTH,
+					data32, 0);
+		tee_attrs_count++;
+		break;
+	default:
+		break;
+	}
+
+	/* TEE attribute(s) required by the operation */
+	switch (proc->mecha_type) {
+	case SKS_CKM_ECDSA_SHA1:
+	case SKS_CKM_ECDSA_SHA224:
+	case SKS_CKM_ECDSA_SHA256:
+	case SKS_CKM_ECDSA_SHA384:
+	case SKS_CKM_ECDSA_SHA512:
+		if (step == SKS_FUNC_STEP_FINAL)
+			break;
+
+		EMSG("TODO: compute hash for later authentication");
+		rv = SKS_NOT_IMPLEMENTED;
+		goto bail;
+	default:
+		/* Other mechanism do not expect multi stage operation */
+		rv = SKS_ERROR;
+		break;
+	}
+
+	if (step == SKS_FUNC_STEP_UPDATE)
+		goto bail;
+
+	/*
+	 * Finalize
+	 */
+
+	/* These ECDSA need to use the computed hash as input data */
+	switch (proc->mecha_type) {
+	case SKS_CKM_ECDSA:
+		/* Input size depends on the key size */
+		if (!in_size) {
+			rv = SKS_FAILED;
+			goto bail;
+		}
+		TEE_GetOperationInfo(proc->tee_op_handle, &opinfo);
+		switch (opinfo.algorithm) {
+		case TEE_ALG_ECDSA_P192:
+			if (in_size > 24)
+				in_size = 24;
+			break;
+		case TEE_ALG_ECDSA_P224:
+			if (in_size > 28)
+				in_size = 28;
+			break;
+		case TEE_ALG_ECDSA_P256:
+			if (in_size > 32)
+				in_size = 32;
+			break;
+		case TEE_ALG_ECDSA_P384:
+			if (in_size > 48)
+				in_size = 48;
+			break;
+		case TEE_ALG_ECDSA_P521:
+			if (in_size > 64)
+				in_size = 64;
+			break;
+		default:
+			rv = SKS_FAILED;
+			goto bail;
+		}
+		/* Validate second input buffer size if verify */
+		if (function == SKS_FUNCTION_VERIFY &&
+				in2_size != 2 * in_size) {
+			rv = SKS_CKR_SIGNATURE_LEN_RANGE;
+			goto bail;
+		}
+		break;
+	case SKS_CKM_ECDSA_SHA1:
+		in_buf = proc->extra_ctx;
+		in_size = 192;
+		break;
+	case SKS_CKM_ECDSA_SHA224:
+		in_buf = proc->extra_ctx;
+		in_size = 224;
+		break;
+	case SKS_CKM_ECDSA_SHA256:
+		in_buf = proc->extra_ctx;
+		in_size = 256;
+		break;
+	case SKS_CKM_ECDSA_SHA384:
+		in_buf = proc->extra_ctx;
+		in_size = 384;
+		break;
+	case SKS_CKM_ECDSA_SHA512:
+		in_buf = proc->extra_ctx;
+		in_size = 512;
+		break;
+	default:
+		if (step != SKS_FUNC_STEP_ONESHOT) {
+			rv = SKS_ERROR;
+			goto bail;
+		}
+		break;
+	}
+
+	switch (proc->mecha_type) {
+	case SKS_CKM_ECDSA:
+	case SKS_CKM_ECDSA_SHA1:
+	case SKS_CKM_ECDSA_SHA224:
+	case SKS_CKM_ECDSA_SHA256:
+	case SKS_CKM_ECDSA_SHA384:
+	case SKS_CKM_ECDSA_SHA512:
+	case SKS_CKM_RSA_PKCS:
+	case SKS_CKM_RSA_9796:
+	case SKS_CKM_RSA_X_509:
+	case SKS_CKM_SHA1_RSA_PKCS:
+	case SKS_CKM_RSA_PKCS_OAEP:
+	case SKS_CKM_RSA_PKCS_PSS:
+	case SKS_CKM_SHA1_RSA_PKCS_PSS:
+	case SKS_CKM_SHA256_RSA_PKCS_PSS:
+	case SKS_CKM_SHA384_RSA_PKCS_PSS:
+	case SKS_CKM_SHA512_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS_PSS:
+	case SKS_CKM_SHA224_RSA_PKCS:
+	case SKS_CKM_SHA256_RSA_PKCS:
+	case SKS_CKM_SHA384_RSA_PKCS:
+	case SKS_CKM_SHA512_RSA_PKCS:
+		switch (function) {
+		case SKS_FUNCTION_ENCRYPT:
+			// TODO: TEE_ALG_RSAES_PKCS1_OAEP_MGF1_xxx takes an
+			// optional argument TEE_ATTR_RSA_OAEP_LABEL.
+			res = TEE_AsymmetricEncrypt(proc->tee_op_handle,
+						    tee_attrs, tee_attrs_count,
+						    in_buf, in_size,
+						    out_buf, &out_size);
+			output_data = true;
+			rv = tee2sks_error(res);
+			break;
+
+		case SKS_FUNCTION_DECRYPT:
+			res = TEE_AsymmetricDecrypt(proc->tee_op_handle,
+						    tee_attrs, tee_attrs_count,
+						    in_buf, in_size,
+						    out_buf, &out_size);
+			output_data = true;
+			rv = tee2sks_error(res);
+			break;
+
+		case SKS_FUNCTION_SIGN:
+			res = TEE_AsymmetricSignDigest(proc->tee_op_handle,
+							tee_attrs,
+							tee_attrs_count,
+							in_buf, in_size,
+							out_buf, &out_size);
+			output_data = true;
+			rv = tee2sks_error(res);
+			break;
+
+		case SKS_FUNCTION_VERIFY:
+			res = TEE_AsymmetricVerifyDigest(proc->tee_op_handle,
+							 tee_attrs,
+							 tee_attrs_count,
+							 in_buf, in_size,
+							 in2_buf, in2_size);
+			rv = tee2sks_error(res);
+			break;
+
+		default:
+			TEE_Panic(function);
+			break;
+		}
+		break;
+	default:
+		TEE_Panic(proc->mecha_type);
+		break;
+	}
+bail:
+	if (output_data && (rv == SKS_OK || rv == SKS_SHORT_BUFFER)) {
+		if (io2)
+			io2->memref.size = out_size;
+		else
+			rv = SKS_ERROR;
+	}
+
+	TEE_Free(tee_attrs);
+
+	return rv;
+}
+
+uint32_t do_asymm_derivation(struct pkcs11_session *session,
+			     struct sks_attribute_head *proc_params,
+			     struct sks_attrs_head **head)
+{
+	uint32_t rv = SKS_ERROR;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	TEE_Attribute tee_attrs[2];
+	size_t tee_attrs_count = 0;
+	TEE_ObjectHandle out_handle = TEE_HANDLE_NULL;
+	void *a_ptr = NULL;
+	size_t a_size = 0;
+	uint32_t key_bit_size = 0;
+	uint32_t key_byte_size = 0;
+
+	TEE_MemFill(tee_attrs, 0, sizeof(tee_attrs));
+
+	rv = get_u32_attribute(*head, SKS_CKA_VALUE_LEN, &key_bit_size);
+	if (rv)
+		return rv;
+
+	if (get_type(*head) != SKS_CKK_GENERIC_SECRET)
+		key_bit_size *= 8;
+
+	key_byte_size = (key_bit_size + 7) / 8;
+
+	res = TEE_AllocateTransientObject(TEE_TYPE_GENERIC_SECRET,
+					  key_byte_size * 8, &out_handle);
+	if (res) {
+		DMSG("TEE_AllocateTransientObject failed, 0x%" PRIx32, res);
+		return tee2sks_error(res);
+	}
+
+	switch (proc_params->id) {
+	case SKS_CKM_ECDH1_DERIVE:
+	case SKS_CKM_ECDH1_COFACTOR_DERIVE:
+		rv = sks2tee_ecdh_param_pub(proc_params, &a_ptr, &a_size);
+		if (rv)
+			goto bail;
+
+		// TODO: check size is the expected one (active proc key)
+		TEE_InitRefAttribute(&tee_attrs[tee_attrs_count],
+						TEE_ATTR_ECC_PUBLIC_VALUE_X,
+						a_ptr, a_size / 2);
+		tee_attrs_count++;
+
+		TEE_InitRefAttribute(&tee_attrs[tee_attrs_count],
+						TEE_ATTR_ECC_PUBLIC_VALUE_Y,
+						(char *)a_ptr + a_size / 2,
+						a_size / 2);
+		tee_attrs_count++;
+		break;
+	case SKS_CKM_DH_PKCS_DERIVE:
+		TEE_InitRefAttribute(&tee_attrs[tee_attrs_count],
+						TEE_ATTR_DH_PUBLIC_VALUE,
+						proc_params->data,
+						proc_params->size);
+		tee_attrs_count++;
+		break;
+	default:
+		TEE_Panic(proc_params->id);
+		break;
+	}
+
+	TEE_DeriveKey(session->processing->tee_op_handle,
+			&tee_attrs[0], tee_attrs_count, out_handle);
+
+	rv = alloc_get_tee_attribute_data(out_handle, TEE_ATTR_SECRET_VALUE,
+					  &a_ptr, &a_size);
+	if (rv)
+		goto bail;
+
+	if (a_size * 8 < key_bit_size) {
+		rv = SKS_CKR_KEY_SIZE_RANGE;
+	} else {
+		rv = add_attribute(head, SKS_CKA_VALUE, a_ptr, key_byte_size);
+	}
+
+	TEE_Free(a_ptr);
+bail:
+	release_active_processing(session);
+	TEE_FreeTransientObject(out_handle);
+	return rv;
+}
diff --git a/ta/secure_key_services/src/processing_ec.c b/ta/secure_key_services/src/processing_ec.c
new file mode 100644
index 00000000..680bafd5
--- /dev/null
+++ b/ta/secure_key_services/src/processing_ec.c
@@ -0,0 +1,1297 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <assert.h>
+#include <sks_internal_abi.h>
+#include <sks_ta.h>
+#include <string.h>
+#include <tee_api_defines.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include <util.h>
+
+#include "attributes.h"
+#include "object.h"
+#include "pkcs11_token.h"
+#include "pkcs11_attributes.h"
+#include "processing.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+/*
+ * DER encoded EC parameters, dumped from openssl tools using something like
+ * openssl ecparam -name secp224r1 -param-enc [explicit]|
+ *    openssl asn1parse -noout -out /dev/stdout | od -t x1
+ */
+static const uint8_t prime192v1_name_der[] = {
+	0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x01,
+};
+static const uint8_t secp224r1_name_der[] = {
+	0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x21,
+};
+static const uint8_t prime256v1_name_der[] = {
+	0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07,
+};
+static const uint8_t secp384r1_name_der[] = {
+	0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22,
+};
+static const uint8_t secp521r1_name_der[] = {
+	0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x23,
+};
+static const uint8_t brainpoolP160r1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x01,
+};
+static const uint8_t brainpoolP160t1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x02,
+};
+static const uint8_t brainpoolP192r1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x03,
+};
+static const uint8_t brainpoolP192t1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x04,
+};
+static const uint8_t brainpoolP224r1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x05,
+};
+static const uint8_t brainpoolP224t1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x06,
+};
+static const uint8_t brainpoolP256r1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07,
+};
+static const uint8_t brainpoolP256t1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x08,
+};
+static const uint8_t brainpoolP320r1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x09,
+};
+static const uint8_t brainpoolP320t1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0A,
+};
+static const uint8_t brainpoolP384r1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B,
+};
+static const uint8_t brainpoolP384t1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0C,
+};
+static const uint8_t brainpoolP512r1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D,
+};
+static const uint8_t brainpoolP512t1_name_der[] = {
+	0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0E,
+};
+
+static const uint8_t secp224r1_oid_der[] = {
+	0x30, 0x81, 0xDF, 0x02, 0x01, 0x01, 0x30, 0x28,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x1D, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+	0x30, 0x53, 0x04, 0x1C, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
+	0x04, 0x1C, 0xB4, 0x05, 0x0A, 0x85, 0x0C, 0x04,
+	0xB3, 0xAB, 0xF5, 0x41, 0x32, 0x56, 0x50, 0x44,
+	0xB0, 0xB7, 0xD7, 0xBF, 0xD8, 0xBA, 0x27, 0x0B,
+	0x39, 0x43, 0x23, 0x55, 0xFF, 0xB4, 0x03, 0x15,
+	0x00, 0xBD, 0x71, 0x34, 0x47, 0x99, 0xD5, 0xC7,
+	0xFC, 0xDC, 0x45, 0xB5, 0x9F, 0xA3, 0xB9, 0xAB,
+	0x8F, 0x6A, 0x94, 0x8B, 0xC5, 0x04, 0x39, 0x04,
+	0xB7, 0x0E, 0x0C, 0xBD, 0x6B, 0xB4, 0xBF, 0x7F,
+	0x32, 0x13, 0x90, 0xB9, 0x4A, 0x03, 0xC1, 0xD3,
+	0x56, 0xC2, 0x11, 0x22, 0x34, 0x32, 0x80, 0xD6,
+	0x11, 0x5C, 0x1D, 0x21, 0xBD, 0x37, 0x63, 0x88,
+	0xB5, 0xF7, 0x23, 0xFB, 0x4C, 0x22, 0xDF, 0xE6,
+	0xCD, 0x43, 0x75, 0xA0, 0x5A, 0x07, 0x47, 0x64,
+	0x44, 0xD5, 0x81, 0x99, 0x85, 0x00, 0x7E, 0x34,
+	0x02, 0x1D, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0x16, 0xA2, 0xE0, 0xB8, 0xF0, 0x3E, 0x13,
+	0xDD, 0x29, 0x45, 0x5C, 0x5C, 0x2A, 0x3D, 0x02,
+	0x01, 0x01,
+};
+
+static const uint8_t secp384r1_oid_der[] = {
+	0x30, 0x82, 0x01, 0x57, 0x02, 0x01, 0x01, 0x30,
+	0x3C, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
+	0x01, 0x01, 0x02, 0x31, 0x00, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
+	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x7B, 0x04,
+	0x30, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
+	0xFC, 0x04, 0x30, 0xB3, 0x31, 0x2F, 0xA7, 0xE2,
+	0x3E, 0xE7, 0xE4, 0x98, 0x8E, 0x05, 0x6B, 0xE3,
+	0xF8, 0x2D, 0x19, 0x18, 0x1D, 0x9C, 0x6E, 0xFE,
+	0x81, 0x41, 0x12, 0x03, 0x14, 0x08, 0x8F, 0x50,
+	0x13, 0x87, 0x5A, 0xC6, 0x56, 0x39, 0x8D, 0x8A,
+	0x2E, 0xD1, 0x9D, 0x2A, 0x85, 0xC8, 0xED, 0xD3,
+	0xEC, 0x2A, 0xEF, 0x03, 0x15, 0x00, 0xA3, 0x35,
+	0x92, 0x6A, 0xA3, 0x19, 0xA2, 0x7A, 0x1D, 0x00,
+	0x89, 0x6A, 0x67, 0x73, 0xA4, 0x82, 0x7A, 0xCD,
+	0xAC, 0x73, 0x04, 0x61, 0x04, 0xAA, 0x87, 0xCA,
+	0x22, 0xBE, 0x8B, 0x05, 0x37, 0x8E, 0xB1, 0xC7,
+	0x1E, 0xF3, 0x20, 0xAD, 0x74, 0x6E, 0x1D, 0x3B,
+	0x62, 0x8B, 0xA7, 0x9B, 0x98, 0x59, 0xF7, 0x41,
+	0xE0, 0x82, 0x54, 0x2A, 0x38, 0x55, 0x02, 0xF2,
+	0x5D, 0xBF, 0x55, 0x29, 0x6C, 0x3A, 0x54, 0x5E,
+	0x38, 0x72, 0x76, 0x0A, 0xB7, 0x36, 0x17, 0xDE,
+	0x4A, 0x96, 0x26, 0x2C, 0x6F, 0x5D, 0x9E, 0x98,
+	0xBF, 0x92, 0x92, 0xDC, 0x29, 0xF8, 0xF4, 0x1D,
+	0xBD, 0x28, 0x9A, 0x14, 0x7C, 0xE9, 0xDA, 0x31,
+	0x13, 0xB5, 0xF0, 0xB8, 0xC0, 0x0A, 0x60, 0xB1,
+	0xCE, 0x1D, 0x7E, 0x81, 0x9D, 0x7A, 0x43, 0x1D,
+	0x7C, 0x90, 0xEA, 0x0E, 0x5F, 0x02, 0x31, 0x00,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xC7, 0x63, 0x4D, 0x81, 0xF4, 0x37, 0x2D, 0xDF,
+	0x58, 0x1A, 0x0D, 0xB2, 0x48, 0xB0, 0xA7, 0x7A,
+	0xEC, 0xEC, 0x19, 0x6A, 0xCC, 0xC5, 0x29, 0x73,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t secp521r1_oid_der[] = {
+	0x30, 0x82, 0x01, 0xC2, 0x02, 0x01, 0x01, 0x30,
+	0x4D, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
+	0x01, 0x01, 0x02, 0x42, 0x01, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x81,
+	0x9E, 0x04, 0x42, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x04, 0x41, 0x51,
+	0x95, 0x3E, 0xB9, 0x61, 0x8E, 0x1C, 0x9A, 0x1F,
+	0x92, 0x9A, 0x21, 0xA0, 0xB6, 0x85, 0x40, 0xEE,
+	0xA2, 0xDA, 0x72, 0x5B, 0x99, 0xB3, 0x15, 0xF3,
+	0xB8, 0xB4, 0x89, 0x91, 0x8E, 0xF1, 0x09, 0xE1,
+	0x56, 0x19, 0x39, 0x51, 0xEC, 0x7E, 0x93, 0x7B,
+	0x16, 0x52, 0xC0, 0xBD, 0x3B, 0xB1, 0xBF, 0x07,
+	0x35, 0x73, 0xDF, 0x88, 0x3D, 0x2C, 0x34, 0xF1,
+	0xEF, 0x45, 0x1F, 0xD4, 0x6B, 0x50, 0x3F, 0x00,
+	0x03, 0x15, 0x00, 0xD0, 0x9E, 0x88, 0x00, 0x29,
+	0x1C, 0xB8, 0x53, 0x96, 0xCC, 0x67, 0x17, 0x39,
+	0x32, 0x84, 0xAA, 0xA0, 0xDA, 0x64, 0xBA, 0x04,
+	0x81, 0x85, 0x04, 0x00, 0xC6, 0x85, 0x8E, 0x06,
+	0xB7, 0x04, 0x04, 0xE9, 0xCD, 0x9E, 0x3E, 0xCB,
+	0x66, 0x23, 0x95, 0xB4, 0x42, 0x9C, 0x64, 0x81,
+	0x39, 0x05, 0x3F, 0xB5, 0x21, 0xF8, 0x28, 0xAF,
+	0x60, 0x6B, 0x4D, 0x3D, 0xBA, 0xA1, 0x4B, 0x5E,
+	0x77, 0xEF, 0xE7, 0x59, 0x28, 0xFE, 0x1D, 0xC1,
+	0x27, 0xA2, 0xFF, 0xA8, 0xDE, 0x33, 0x48, 0xB3,
+	0xC1, 0x85, 0x6A, 0x42, 0x9B, 0xF9, 0x7E, 0x7E,
+	0x31, 0xC2, 0xE5, 0xBD, 0x66, 0x01, 0x18, 0x39,
+	0x29, 0x6A, 0x78, 0x9A, 0x3B, 0xC0, 0x04, 0x5C,
+	0x8A, 0x5F, 0xB4, 0x2C, 0x7D, 0x1B, 0xD9, 0x98,
+	0xF5, 0x44, 0x49, 0x57, 0x9B, 0x44, 0x68, 0x17,
+	0xAF, 0xBD, 0x17, 0x27, 0x3E, 0x66, 0x2C, 0x97,
+	0xEE, 0x72, 0x99, 0x5E, 0xF4, 0x26, 0x40, 0xC5,
+	0x50, 0xB9, 0x01, 0x3F, 0xAD, 0x07, 0x61, 0x35,
+	0x3C, 0x70, 0x86, 0xA2, 0x72, 0xC2, 0x40, 0x88,
+	0xBE, 0x94, 0x76, 0x9F, 0xD1, 0x66, 0x50, 0x02,
+	0x42, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFA, 0x51, 0x86, 0x87, 0x83, 0xBF,
+	0x2F, 0x96, 0x6B, 0x7F, 0xCC, 0x01, 0x48, 0xF7,
+	0x09, 0xA5, 0xD0, 0x3B, 0xB5, 0xC9, 0xB8, 0x89,
+	0x9C, 0x47, 0xAE, 0xBB, 0x6F, 0xB7, 0x1E, 0x91,
+	0x38, 0x64, 0x09, 0x02, 0x01, 0x01,
+};
+static const uint8_t prime192v1_oid_der[] = {
+	0x30, 0x81, 0xC7, 0x02, 0x01, 0x01, 0x30, 0x24,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x19, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x4B, 0x04, 0x18,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
+	0x04, 0x18, 0x64, 0x21, 0x05, 0x19, 0xE5, 0x9C,
+	0x80, 0xE7, 0x0F, 0xA7, 0xE9, 0xAB, 0x72, 0x24,
+	0x30, 0x49, 0xFE, 0xB8, 0xDE, 0xEC, 0xC1, 0x46,
+	0xB9, 0xB1, 0x03, 0x15, 0x00, 0x30, 0x45, 0xAE,
+	0x6F, 0xC8, 0x42, 0x2F, 0x64, 0xED, 0x57, 0x95,
+	0x28, 0xD3, 0x81, 0x20, 0xEA, 0xE1, 0x21, 0x96,
+	0xD5, 0x04, 0x31, 0x04, 0x18, 0x8D, 0xA8, 0x0E,
+	0xB0, 0x30, 0x90, 0xF6, 0x7C, 0xBF, 0x20, 0xEB,
+	0x43, 0xA1, 0x88, 0x00, 0xF4, 0xFF, 0x0A, 0xFD,
+	0x82, 0xFF, 0x10, 0x12, 0x07, 0x19, 0x2B, 0x95,
+	0xFF, 0xC8, 0xDA, 0x78, 0x63, 0x10, 0x11, 0xED,
+	0x6B, 0x24, 0xCD, 0xD5, 0x73, 0xF9, 0x77, 0xA1,
+	0x1E, 0x79, 0x48, 0x11, 0x02, 0x19, 0x00, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0x99, 0xDE, 0xF8, 0x36, 0x14,
+	0x6B, 0xC9, 0xB1, 0xB4, 0xD2, 0x28, 0x31, 0x02,
+	0x01, 0x01,
+};
+static const uint8_t __unused prime192v2_oid_der[] = {
+	0x30, 0x81, 0xC7, 0x02, 0x01, 0x01, 0x30, 0x24,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x19, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x4B, 0x04, 0x18,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
+	0x04, 0x18, 0xCC, 0x22, 0xD6, 0xDF, 0xB9, 0x5C,
+	0x6B, 0x25, 0xE4, 0x9C, 0x0D, 0x63, 0x64, 0xA4,
+	0xE5, 0x98, 0x0C, 0x39, 0x3A, 0xA2, 0x16, 0x68,
+	0xD9, 0x53, 0x03, 0x15, 0x00, 0x31, 0xA9, 0x2E,
+	0xE2, 0x02, 0x9F, 0xD1, 0x0D, 0x90, 0x1B, 0x11,
+	0x3E, 0x99, 0x07, 0x10, 0xF0, 0xD2, 0x1A, 0xC6,
+	0xB6, 0x04, 0x31, 0x04, 0xEE, 0xA2, 0xBA, 0xE7,
+	0xE1, 0x49, 0x78, 0x42, 0xF2, 0xDE, 0x77, 0x69,
+	0xCF, 0xE9, 0xC9, 0x89, 0xC0, 0x72, 0xAD, 0x69,
+	0x6F, 0x48, 0x03, 0x4A, 0x65, 0x74, 0xD1, 0x1D,
+	0x69, 0xB6, 0xEC, 0x7A, 0x67, 0x2B, 0xB8, 0x2A,
+	0x08, 0x3D, 0xF2, 0xF2, 0xB0, 0x84, 0x7D, 0xE9,
+	0x70, 0xB2, 0xDE, 0x15, 0x02, 0x19, 0x00, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFE, 0x5F, 0xB1, 0xA7, 0x24, 0xDC,
+	0x80, 0x41, 0x86, 0x48, 0xD8, 0xDD, 0x31, 0x02,
+	0x01, 0x01,
+};
+static const uint8_t __unused prime192v3_oid_der[] = {
+	0x30, 0x81, 0xC7, 0x02, 0x01, 0x01, 0x30, 0x24,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x19, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x4B, 0x04, 0x18,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
+	0x04, 0x18, 0x22, 0x12, 0x3D, 0xC2, 0x39, 0x5A,
+	0x05, 0xCA, 0xA7, 0x42, 0x3D, 0xAE, 0xCC, 0xC9,
+	0x47, 0x60, 0xA7, 0xD4, 0x62, 0x25, 0x6B, 0xD5,
+	0x69, 0x16, 0x03, 0x15, 0x00, 0xC4, 0x69, 0x68,
+	0x44, 0x35, 0xDE, 0xB3, 0x78, 0xC4, 0xB6, 0x5C,
+	0xA9, 0x59, 0x1E, 0x2A, 0x57, 0x63, 0x05, 0x9A,
+	0x2E, 0x04, 0x31, 0x04, 0x7D, 0x29, 0x77, 0x81,
+	0x00, 0xC6, 0x5A, 0x1D, 0xA1, 0x78, 0x37, 0x16,
+	0x58, 0x8D, 0xCE, 0x2B, 0x8B, 0x4A, 0xEE, 0x8E,
+	0x22, 0x8F, 0x18, 0x96, 0x38, 0xA9, 0x0F, 0x22,
+	0x63, 0x73, 0x37, 0x33, 0x4B, 0x49, 0xDC, 0xB6,
+	0x6A, 0x6D, 0xC8, 0xF9, 0x97, 0x8A, 0xCA, 0x76,
+	0x48, 0xA9, 0x43, 0xB0, 0x02, 0x19, 0x00, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0x7A, 0x62, 0xD0, 0x31, 0xC8,
+	0x3F, 0x42, 0x94, 0xF6, 0x40, 0xEC, 0x13, 0x02,
+	0x01, 0x01,
+};
+static const uint8_t prime256v1_oid_der[] = {
+	0x30, 0x81, 0xF7, 0x02, 0x01, 0x01, 0x30, 0x2C,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x21, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x5B, 0x04, 0x20,
+	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
+	0x04, 0x20, 0x5A, 0xC6, 0x35, 0xD8, 0xAA, 0x3A,
+	0x93, 0xE7, 0xB3, 0xEB, 0xBD, 0x55, 0x76, 0x98,
+	0x86, 0xBC, 0x65, 0x1D, 0x06, 0xB0, 0xCC, 0x53,
+	0xB0, 0xF6, 0x3B, 0xCE, 0x3C, 0x3E, 0x27, 0xD2,
+	0x60, 0x4B, 0x03, 0x15, 0x00, 0xC4, 0x9D, 0x36,
+	0x08, 0x86, 0xE7, 0x04, 0x93, 0x6A, 0x66, 0x78,
+	0xE1, 0x13, 0x9D, 0x26, 0xB7, 0x81, 0x9F, 0x7E,
+	0x90, 0x04, 0x41, 0x04, 0x6B, 0x17, 0xD1, 0xF2,
+	0xE1, 0x2C, 0x42, 0x47, 0xF8, 0xBC, 0xE6, 0xE5,
+	0x63, 0xA4, 0x40, 0xF2, 0x77, 0x03, 0x7D, 0x81,
+	0x2D, 0xEB, 0x33, 0xA0, 0xF4, 0xA1, 0x39, 0x45,
+	0xD8, 0x98, 0xC2, 0x96, 0x4F, 0xE3, 0x42, 0xE2,
+	0xFE, 0x1A, 0x7F, 0x9B, 0x8E, 0xE7, 0xEB, 0x4A,
+	0x7C, 0x0F, 0x9E, 0x16, 0x2B, 0xCE, 0x33, 0x57,
+	0x6B, 0x31, 0x5E, 0xCE, 0xCB, 0xB6, 0x40, 0x68,
+	0x37, 0xBF, 0x51, 0xF5, 0x02, 0x21, 0x00, 0xFF,
+	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBC,
+	0xE6, 0xFA, 0xAD, 0xA7, 0x17, 0x9E, 0x84, 0xF3,
+	0xB9, 0xCA, 0xC2, 0xFC, 0x63, 0x25, 0x51, 0x02,
+	0x01, 0x01,
+};
+static const uint8_t brainpoolP160r1_oid_der[] = {
+	0x30, 0x81, 0x98, 0x02, 0x01, 0x01, 0x30, 0x20,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x15, 0x00, 0xE9, 0x5E, 0x4A, 0x5F,
+	0x73, 0x70, 0x59, 0xDC, 0x60, 0xDF, 0xC7, 0xAD,
+	0x95, 0xB3, 0xD8, 0x13, 0x95, 0x15, 0x62, 0x0F,
+	0x30, 0x2C, 0x04, 0x14, 0x34, 0x0E, 0x7B, 0xE2,
+	0xA2, 0x80, 0xEB, 0x74, 0xE2, 0xBE, 0x61, 0xBA,
+	0xDA, 0x74, 0x5D, 0x97, 0xE8, 0xF7, 0xC3, 0x00,
+	0x04, 0x14, 0x1E, 0x58, 0x9A, 0x85, 0x95, 0x42,
+	0x34, 0x12, 0x13, 0x4F, 0xAA, 0x2D, 0xBD, 0xEC,
+	0x95, 0xC8, 0xD8, 0x67, 0x5E, 0x58, 0x04, 0x29,
+	0x04, 0xBE, 0xD5, 0xAF, 0x16, 0xEA, 0x3F, 0x6A,
+	0x4F, 0x62, 0x93, 0x8C, 0x46, 0x31, 0xEB, 0x5A,
+	0xF7, 0xBD, 0xBC, 0xDB, 0xC3, 0x16, 0x67, 0xCB,
+	0x47, 0x7A, 0x1A, 0x8E, 0xC3, 0x38, 0xF9, 0x47,
+	0x41, 0x66, 0x9C, 0x97, 0x63, 0x16, 0xDA, 0x63,
+	0x21, 0x02, 0x15, 0x00, 0xE9, 0x5E, 0x4A, 0x5F,
+	0x73, 0x70, 0x59, 0xDC, 0x60, 0xDF, 0x59, 0x91,
+	0xD4, 0x50, 0x29, 0x40, 0x9E, 0x60, 0xFC, 0x09,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP160t1_oid_der[] = {
+	0x30, 0x81, 0x98, 0x02, 0x01, 0x01, 0x30, 0x20,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x15, 0x00, 0xE9, 0x5E, 0x4A, 0x5F,
+	0x73, 0x70, 0x59, 0xDC, 0x60, 0xDF, 0xC7, 0xAD,
+	0x95, 0xB3, 0xD8, 0x13, 0x95, 0x15, 0x62, 0x0F,
+	0x30, 0x2C, 0x04, 0x14, 0xE9, 0x5E, 0x4A, 0x5F,
+	0x73, 0x70, 0x59, 0xDC, 0x60, 0xDF, 0xC7, 0xAD,
+	0x95, 0xB3, 0xD8, 0x13, 0x95, 0x15, 0x62, 0x0C,
+	0x04, 0x14, 0x7A, 0x55, 0x6B, 0x6D, 0xAE, 0x53,
+	0x5B, 0x7B, 0x51, 0xED, 0x2C, 0x4D, 0x7D, 0xAA,
+	0x7A, 0x0B, 0x5C, 0x55, 0xF3, 0x80, 0x04, 0x29,
+	0x04, 0xB1, 0x99, 0xB1, 0x3B, 0x9B, 0x34, 0xEF,
+	0xC1, 0x39, 0x7E, 0x64, 0xBA, 0xEB, 0x05, 0xAC,
+	0xC2, 0x65, 0xFF, 0x23, 0x78, 0xAD, 0xD6, 0x71,
+	0x8B, 0x7C, 0x7C, 0x19, 0x61, 0xF0, 0x99, 0x1B,
+	0x84, 0x24, 0x43, 0x77, 0x21, 0x52, 0xC9, 0xE0,
+	0xAD, 0x02, 0x15, 0x00, 0xE9, 0x5E, 0x4A, 0x5F,
+	0x73, 0x70, 0x59, 0xDC, 0x60, 0xDF, 0x59, 0x91,
+	0xD4, 0x50, 0x29, 0x40, 0x9E, 0x60, 0xFC, 0x09,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP192r1_oid_der[] = {
+	0x30, 0x81, 0xB0, 0x02, 0x01, 0x01, 0x30, 0x24,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x19, 0x00, 0xC3, 0x02, 0xF4, 0x1D,
+	0x93, 0x2A, 0x36, 0xCD, 0xA7, 0xA3, 0x46, 0x30,
+	0x93, 0xD1, 0x8D, 0xB7, 0x8F, 0xCE, 0x47, 0x6D,
+	0xE1, 0xA8, 0x62, 0x97, 0x30, 0x34, 0x04, 0x18,
+	0x6A, 0x91, 0x17, 0x40, 0x76, 0xB1, 0xE0, 0xE1,
+	0x9C, 0x39, 0xC0, 0x31, 0xFE, 0x86, 0x85, 0xC1,
+	0xCA, 0xE0, 0x40, 0xE5, 0xC6, 0x9A, 0x28, 0xEF,
+	0x04, 0x18, 0x46, 0x9A, 0x28, 0xEF, 0x7C, 0x28,
+	0xCC, 0xA3, 0xDC, 0x72, 0x1D, 0x04, 0x4F, 0x44,
+	0x96, 0xBC, 0xCA, 0x7E, 0xF4, 0x14, 0x6F, 0xBF,
+	0x25, 0xC9, 0x04, 0x31, 0x04, 0xC0, 0xA0, 0x64,
+	0x7E, 0xAA, 0xB6, 0xA4, 0x87, 0x53, 0xB0, 0x33,
+	0xC5, 0x6C, 0xB0, 0xF0, 0x90, 0x0A, 0x2F, 0x5C,
+	0x48, 0x53, 0x37, 0x5F, 0xD6, 0x14, 0xB6, 0x90,
+	0x86, 0x6A, 0xBD, 0x5B, 0xB8, 0x8B, 0x5F, 0x48,
+	0x28, 0xC1, 0x49, 0x00, 0x02, 0xE6, 0x77, 0x3F,
+	0xA2, 0xFA, 0x29, 0x9B, 0x8F, 0x02, 0x19, 0x00,
+	0xC3, 0x02, 0xF4, 0x1D, 0x93, 0x2A, 0x36, 0xCD,
+	0xA7, 0xA3, 0x46, 0x2F, 0x9E, 0x9E, 0x91, 0x6B,
+	0x5B, 0xE8, 0xF1, 0x02, 0x9A, 0xC4, 0xAC, 0xC1,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP192t1_oid_der[] = {
+	0x30, 0x81, 0xB0, 0x02, 0x01, 0x01, 0x30, 0x24,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x19, 0x00, 0xC3, 0x02, 0xF4, 0x1D,
+	0x93, 0x2A, 0x36, 0xCD, 0xA7, 0xA3, 0x46, 0x30,
+	0x93, 0xD1, 0x8D, 0xB7, 0x8F, 0xCE, 0x47, 0x6D,
+	0xE1, 0xA8, 0x62, 0x97, 0x30, 0x34, 0x04, 0x18,
+	0xC3, 0x02, 0xF4, 0x1D, 0x93, 0x2A, 0x36, 0xCD,
+	0xA7, 0xA3, 0x46, 0x30, 0x93, 0xD1, 0x8D, 0xB7,
+	0x8F, 0xCE, 0x47, 0x6D, 0xE1, 0xA8, 0x62, 0x94,
+	0x04, 0x18, 0x13, 0xD5, 0x6F, 0xFA, 0xEC, 0x78,
+	0x68, 0x1E, 0x68, 0xF9, 0xDE, 0xB4, 0x3B, 0x35,
+	0xBE, 0xC2, 0xFB, 0x68, 0x54, 0x2E, 0x27, 0x89,
+	0x7B, 0x79, 0x04, 0x31, 0x04, 0x3A, 0xE9, 0xE5,
+	0x8C, 0x82, 0xF6, 0x3C, 0x30, 0x28, 0x2E, 0x1F,
+	0xE7, 0xBB, 0xF4, 0x3F, 0xA7, 0x2C, 0x44, 0x6A,
+	0xF6, 0xF4, 0x61, 0x81, 0x29, 0x09, 0x7E, 0x2C,
+	0x56, 0x67, 0xC2, 0x22, 0x3A, 0x90, 0x2A, 0xB5,
+	0xCA, 0x44, 0x9D, 0x00, 0x84, 0xB7, 0xE5, 0xB3,
+	0xDE, 0x7C, 0xCC, 0x01, 0xC9, 0x02, 0x19, 0x00,
+	0xC3, 0x02, 0xF4, 0x1D, 0x93, 0x2A, 0x36, 0xCD,
+	0xA7, 0xA3, 0x46, 0x2F, 0x9E, 0x9E, 0x91, 0x6B,
+	0x5B, 0xE8, 0xF1, 0x02, 0x9A, 0xC4, 0xAC, 0xC1,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP224r1_oid_der[] = {
+	0x30, 0x81, 0xC8, 0x02, 0x01, 0x01, 0x30, 0x28,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x1D, 0x00, 0xD7, 0xC1, 0x34, 0xAA,
+	0x26, 0x43, 0x66, 0x86, 0x2A, 0x18, 0x30, 0x25,
+	0x75, 0xD1, 0xD7, 0x87, 0xB0, 0x9F, 0x07, 0x57,
+	0x97, 0xDA, 0x89, 0xF5, 0x7E, 0xC8, 0xC0, 0xFF,
+	0x30, 0x3C, 0x04, 0x1C, 0x68, 0xA5, 0xE6, 0x2C,
+	0xA9, 0xCE, 0x6C, 0x1C, 0x29, 0x98, 0x03, 0xA6,
+	0xC1, 0x53, 0x0B, 0x51, 0x4E, 0x18, 0x2A, 0xD8,
+	0xB0, 0x04, 0x2A, 0x59, 0xCA, 0xD2, 0x9F, 0x43,
+	0x04, 0x1C, 0x25, 0x80, 0xF6, 0x3C, 0xCF, 0xE4,
+	0x41, 0x38, 0x87, 0x07, 0x13, 0xB1, 0xA9, 0x23,
+	0x69, 0xE3, 0x3E, 0x21, 0x35, 0xD2, 0x66, 0xDB,
+	0xB3, 0x72, 0x38, 0x6C, 0x40, 0x0B, 0x04, 0x39,
+	0x04, 0x0D, 0x90, 0x29, 0xAD, 0x2C, 0x7E, 0x5C,
+	0xF4, 0x34, 0x08, 0x23, 0xB2, 0xA8, 0x7D, 0xC6,
+	0x8C, 0x9E, 0x4C, 0xE3, 0x17, 0x4C, 0x1E, 0x6E,
+	0xFD, 0xEE, 0x12, 0xC0, 0x7D, 0x58, 0xAA, 0x56,
+	0xF7, 0x72, 0xC0, 0x72, 0x6F, 0x24, 0xC6, 0xB8,
+	0x9E, 0x4E, 0xCD, 0xAC, 0x24, 0x35, 0x4B, 0x9E,
+	0x99, 0xCA, 0xA3, 0xF6, 0xD3, 0x76, 0x14, 0x02,
+	0xCD, 0x02, 0x1D, 0x00, 0xD7, 0xC1, 0x34, 0xAA,
+	0x26, 0x43, 0x66, 0x86, 0x2A, 0x18, 0x30, 0x25,
+	0x75, 0xD0, 0xFB, 0x98, 0xD1, 0x16, 0xBC, 0x4B,
+	0x6D, 0xDE, 0xBC, 0xA3, 0xA5, 0xA7, 0x93, 0x9F,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP224t1_oid_der[] = {
+	0x30, 0x81, 0xC8, 0x02, 0x01, 0x01, 0x30, 0x28,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x1D, 0x00, 0xD7, 0xC1, 0x34, 0xAA,
+	0x26, 0x43, 0x66, 0x86, 0x2A, 0x18, 0x30, 0x25,
+	0x75, 0xD1, 0xD7, 0x87, 0xB0, 0x9F, 0x07, 0x57,
+	0x97, 0xDA, 0x89, 0xF5, 0x7E, 0xC8, 0xC0, 0xFF,
+	0x30, 0x3C, 0x04, 0x1C, 0xD7, 0xC1, 0x34, 0xAA,
+	0x26, 0x43, 0x66, 0x86, 0x2A, 0x18, 0x30, 0x25,
+	0x75, 0xD1, 0xD7, 0x87, 0xB0, 0x9F, 0x07, 0x57,
+	0x97, 0xDA, 0x89, 0xF5, 0x7E, 0xC8, 0xC0, 0xFC,
+	0x04, 0x1C, 0x4B, 0x33, 0x7D, 0x93, 0x41, 0x04,
+	0xCD, 0x7B, 0xEF, 0x27, 0x1B, 0xF6, 0x0C, 0xED,
+	0x1E, 0xD2, 0x0D, 0xA1, 0x4C, 0x08, 0xB3, 0xBB,
+	0x64, 0xF1, 0x8A, 0x60, 0x88, 0x8D, 0x04, 0x39,
+	0x04, 0x6A, 0xB1, 0xE3, 0x44, 0xCE, 0x25, 0xFF,
+	0x38, 0x96, 0x42, 0x4E, 0x7F, 0xFE, 0x14, 0x76,
+	0x2E, 0xCB, 0x49, 0xF8, 0x92, 0x8A, 0xC0, 0xC7,
+	0x60, 0x29, 0xB4, 0xD5, 0x80, 0x03, 0x74, 0xE9,
+	0xF5, 0x14, 0x3E, 0x56, 0x8C, 0xD2, 0x3F, 0x3F,
+	0x4D, 0x7C, 0x0D, 0x4B, 0x1E, 0x41, 0xC8, 0xCC,
+	0x0D, 0x1C, 0x6A, 0xBD, 0x5F, 0x1A, 0x46, 0xDB,
+	0x4C, 0x02, 0x1D, 0x00, 0xD7, 0xC1, 0x34, 0xAA,
+	0x26, 0x43, 0x66, 0x86, 0x2A, 0x18, 0x30, 0x25,
+	0x75, 0xD0, 0xFB, 0x98, 0xD1, 0x16, 0xBC, 0x4B,
+	0x6D, 0xDE, 0xBC, 0xA3, 0xA5, 0xA7, 0x93, 0x9F,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP256r1_oid_der[] = {
+	0x30, 0x81, 0xE0, 0x02, 0x01, 0x01, 0x30, 0x2C,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x21, 0x00, 0xA9, 0xFB, 0x57, 0xDB,
+	0xA1, 0xEE, 0xA9, 0xBC, 0x3E, 0x66, 0x0A, 0x90,
+	0x9D, 0x83, 0x8D, 0x72, 0x6E, 0x3B, 0xF6, 0x23,
+	0xD5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1D,
+	0x1F, 0x6E, 0x53, 0x77, 0x30, 0x44, 0x04, 0x20,
+	0x7D, 0x5A, 0x09, 0x75, 0xFC, 0x2C, 0x30, 0x57,
+	0xEE, 0xF6, 0x75, 0x30, 0x41, 0x7A, 0xFF, 0xE7,
+	0xFB, 0x80, 0x55, 0xC1, 0x26, 0xDC, 0x5C, 0x6C,
+	0xE9, 0x4A, 0x4B, 0x44, 0xF3, 0x30, 0xB5, 0xD9,
+	0x04, 0x20, 0x26, 0xDC, 0x5C, 0x6C, 0xE9, 0x4A,
+	0x4B, 0x44, 0xF3, 0x30, 0xB5, 0xD9, 0xBB, 0xD7,
+	0x7C, 0xBF, 0x95, 0x84, 0x16, 0x29, 0x5C, 0xF7,
+	0xE1, 0xCE, 0x6B, 0xCC, 0xDC, 0x18, 0xFF, 0x8C,
+	0x07, 0xB6, 0x04, 0x41, 0x04, 0x8B, 0xD2, 0xAE,
+	0xB9, 0xCB, 0x7E, 0x57, 0xCB, 0x2C, 0x4B, 0x48,
+	0x2F, 0xFC, 0x81, 0xB7, 0xAF, 0xB9, 0xDE, 0x27,
+	0xE1, 0xE3, 0xBD, 0x23, 0xC2, 0x3A, 0x44, 0x53,
+	0xBD, 0x9A, 0xCE, 0x32, 0x62, 0x54, 0x7E, 0xF8,
+	0x35, 0xC3, 0xDA, 0xC4, 0xFD, 0x97, 0xF8, 0x46,
+	0x1A, 0x14, 0x61, 0x1D, 0xC9, 0xC2, 0x77, 0x45,
+	0x13, 0x2D, 0xED, 0x8E, 0x54, 0x5C, 0x1D, 0x54,
+	0xC7, 0x2F, 0x04, 0x69, 0x97, 0x02, 0x21, 0x00,
+	0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+	0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x71,
+	0x8C, 0x39, 0x7A, 0xA3, 0xB5, 0x61, 0xA6, 0xF7,
+	0x90, 0x1E, 0x0E, 0x82, 0x97, 0x48, 0x56, 0xA7,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP256t1_oid_der[] = {
+	0x30, 0x81, 0xE0, 0x02, 0x01, 0x01, 0x30, 0x2C,
+	0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x01,
+	0x01, 0x02, 0x21, 0x00, 0xA9, 0xFB, 0x57, 0xDB,
+	0xA1, 0xEE, 0xA9, 0xBC, 0x3E, 0x66, 0x0A, 0x90,
+	0x9D, 0x83, 0x8D, 0x72, 0x6E, 0x3B, 0xF6, 0x23,
+	0xD5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1D,
+	0x1F, 0x6E, 0x53, 0x77, 0x30, 0x44, 0x04, 0x20,
+	0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+	0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x72,
+	0x6E, 0x3B, 0xF6, 0x23, 0xD5, 0x26, 0x20, 0x28,
+	0x20, 0x13, 0x48, 0x1D, 0x1F, 0x6E, 0x53, 0x74,
+	0x04, 0x20, 0x66, 0x2C, 0x61, 0xC4, 0x30, 0xD8,
+	0x4E, 0xA4, 0xFE, 0x66, 0xA7, 0x73, 0x3D, 0x0B,
+	0x76, 0xB7, 0xBF, 0x93, 0xEB, 0xC4, 0xAF, 0x2F,
+	0x49, 0x25, 0x6A, 0xE5, 0x81, 0x01, 0xFE, 0xE9,
+	0x2B, 0x04, 0x04, 0x41, 0x04, 0xA3, 0xE8, 0xEB,
+	0x3C, 0xC1, 0xCF, 0xE7, 0xB7, 0x73, 0x22, 0x13,
+	0xB2, 0x3A, 0x65, 0x61, 0x49, 0xAF, 0xA1, 0x42,
+	0xC4, 0x7A, 0xAF, 0xBC, 0x2B, 0x79, 0xA1, 0x91,
+	0x56, 0x2E, 0x13, 0x05, 0xF4, 0x2D, 0x99, 0x6C,
+	0x82, 0x34, 0x39, 0xC5, 0x6D, 0x7F, 0x7B, 0x22,
+	0xE1, 0x46, 0x44, 0x41, 0x7E, 0x69, 0xBC, 0xB6,
+	0xDE, 0x39, 0xD0, 0x27, 0x00, 0x1D, 0xAB, 0xE8,
+	0xF3, 0x5B, 0x25, 0xC9, 0xBE, 0x02, 0x21, 0x00,
+	0xA9, 0xFB, 0x57, 0xDB, 0xA1, 0xEE, 0xA9, 0xBC,
+	0x3E, 0x66, 0x0A, 0x90, 0x9D, 0x83, 0x8D, 0x71,
+	0x8C, 0x39, 0x7A, 0xA3, 0xB5, 0x61, 0xA6, 0xF7,
+	0x90, 0x1E, 0x0E, 0x82, 0x97, 0x48, 0x56, 0xA7,
+	0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP320r1_oid_der[] = {
+	0x30, 0x82, 0x01, 0x10, 0x02, 0x01, 0x01, 0x30,
+	0x34, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
+	0x01, 0x01, 0x02, 0x29, 0x00, 0xD3, 0x5E, 0x47,
+	0x20, 0x36, 0xBC, 0x4F, 0xB7, 0xE1, 0x3C, 0x78,
+	0x5E, 0xD2, 0x01, 0xE0, 0x65, 0xF9, 0x8F, 0xCF,
+	0xA6, 0xF6, 0xF4, 0x0D, 0xEF, 0x4F, 0x92, 0xB9,
+	0xEC, 0x78, 0x93, 0xEC, 0x28, 0xFC, 0xD4, 0x12,
+	0xB1, 0xF1, 0xB3, 0x2E, 0x27, 0x30, 0x54, 0x04,
+	0x28, 0x3E, 0xE3, 0x0B, 0x56, 0x8F, 0xBA, 0xB0,
+	0xF8, 0x83, 0xCC, 0xEB, 0xD4, 0x6D, 0x3F, 0x3B,
+	0xB8, 0xA2, 0xA7, 0x35, 0x13, 0xF5, 0xEB, 0x79,
+	0xDA, 0x66, 0x19, 0x0E, 0xB0, 0x85, 0xFF, 0xA9,
+	0xF4, 0x92, 0xF3, 0x75, 0xA9, 0x7D, 0x86, 0x0E,
+	0xB4, 0x04, 0x28, 0x52, 0x08, 0x83, 0x94, 0x9D,
+	0xFD, 0xBC, 0x42, 0xD3, 0xAD, 0x19, 0x86, 0x40,
+	0x68, 0x8A, 0x6F, 0xE1, 0x3F, 0x41, 0x34, 0x95,
+	0x54, 0xB4, 0x9A, 0xCC, 0x31, 0xDC, 0xCD, 0x88,
+	0x45, 0x39, 0x81, 0x6F, 0x5E, 0xB4, 0xAC, 0x8F,
+	0xB1, 0xF1, 0xA6, 0x04, 0x51, 0x04, 0x43, 0xBD,
+	0x7E, 0x9A, 0xFB, 0x53, 0xD8, 0xB8, 0x52, 0x89,
+	0xBC, 0xC4, 0x8E, 0xE5, 0xBF, 0xE6, 0xF2, 0x01,
+	0x37, 0xD1, 0x0A, 0x08, 0x7E, 0xB6, 0xE7, 0x87,
+	0x1E, 0x2A, 0x10, 0xA5, 0x99, 0xC7, 0x10, 0xAF,
+	0x8D, 0x0D, 0x39, 0xE2, 0x06, 0x11, 0x14, 0xFD,
+	0xD0, 0x55, 0x45, 0xEC, 0x1C, 0xC8, 0xAB, 0x40,
+	0x93, 0x24, 0x7F, 0x77, 0x27, 0x5E, 0x07, 0x43,
+	0xFF, 0xED, 0x11, 0x71, 0x82, 0xEA, 0xA9, 0xC7,
+	0x78, 0x77, 0xAA, 0xAC, 0x6A, 0xC7, 0xD3, 0x52,
+	0x45, 0xD1, 0x69, 0x2E, 0x8E, 0xE1, 0x02, 0x29,
+	0x00, 0xD3, 0x5E, 0x47, 0x20, 0x36, 0xBC, 0x4F,
+	0xB7, 0xE1, 0x3C, 0x78, 0x5E, 0xD2, 0x01, 0xE0,
+	0x65, 0xF9, 0x8F, 0xCF, 0xA5, 0xB6, 0x8F, 0x12,
+	0xA3, 0x2D, 0x48, 0x2E, 0xC7, 0xEE, 0x86, 0x58,
+	0xE9, 0x86, 0x91, 0x55, 0x5B, 0x44, 0xC5, 0x93,
+	0x11, 0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP320t1_oid_der[] = {
+	0x30, 0x82, 0x01, 0x10, 0x02, 0x01, 0x01, 0x30,
+	0x34, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
+	0x01, 0x01, 0x02, 0x29, 0x00, 0xD3, 0x5E, 0x47,
+	0x20, 0x36, 0xBC, 0x4F, 0xB7, 0xE1, 0x3C, 0x78,
+	0x5E, 0xD2, 0x01, 0xE0, 0x65, 0xF9, 0x8F, 0xCF,
+	0xA6, 0xF6, 0xF4, 0x0D, 0xEF, 0x4F, 0x92, 0xB9,
+	0xEC, 0x78, 0x93, 0xEC, 0x28, 0xFC, 0xD4, 0x12,
+	0xB1, 0xF1, 0xB3, 0x2E, 0x27, 0x30, 0x54, 0x04,
+	0x28, 0xD3, 0x5E, 0x47, 0x20, 0x36, 0xBC, 0x4F,
+	0xB7, 0xE1, 0x3C, 0x78, 0x5E, 0xD2, 0x01, 0xE0,
+	0x65, 0xF9, 0x8F, 0xCF, 0xA6, 0xF6, 0xF4, 0x0D,
+	0xEF, 0x4F, 0x92, 0xB9, 0xEC, 0x78, 0x93, 0xEC,
+	0x28, 0xFC, 0xD4, 0x12, 0xB1, 0xF1, 0xB3, 0x2E,
+	0x24, 0x04, 0x28, 0xA7, 0xF5, 0x61, 0xE0, 0x38,
+	0xEB, 0x1E, 0xD5, 0x60, 0xB3, 0xD1, 0x47, 0xDB,
+	0x78, 0x20, 0x13, 0x06, 0x4C, 0x19, 0xF2, 0x7E,
+	0xD2, 0x7C, 0x67, 0x80, 0xAA, 0xF7, 0x7F, 0xB8,
+	0xA5, 0x47, 0xCE, 0xB5, 0xB4, 0xFE, 0xF4, 0x22,
+	0x34, 0x03, 0x53, 0x04, 0x51, 0x04, 0x92, 0x5B,
+	0xE9, 0xFB, 0x01, 0xAF, 0xC6, 0xFB, 0x4D, 0x3E,
+	0x7D, 0x49, 0x90, 0x01, 0x0F, 0x81, 0x34, 0x08,
+	0xAB, 0x10, 0x6C, 0x4F, 0x09, 0xCB, 0x7E, 0xE0,
+	0x78, 0x68, 0xCC, 0x13, 0x6F, 0xFF, 0x33, 0x57,
+	0xF6, 0x24, 0xA2, 0x1B, 0xED, 0x52, 0x63, 0xBA,
+	0x3A, 0x7A, 0x27, 0x48, 0x3E, 0xBF, 0x66, 0x71,
+	0xDB, 0xEF, 0x7A, 0xBB, 0x30, 0xEB, 0xEE, 0x08,
+	0x4E, 0x58, 0xA0, 0xB0, 0x77, 0xAD, 0x42, 0xA5,
+	0xA0, 0x98, 0x9D, 0x1E, 0xE7, 0x1B, 0x1B, 0x9B,
+	0xC0, 0x45, 0x5F, 0xB0, 0xD2, 0xC3, 0x02, 0x29,
+	0x00, 0xD3, 0x5E, 0x47, 0x20, 0x36, 0xBC, 0x4F,
+	0xB7, 0xE1, 0x3C, 0x78, 0x5E, 0xD2, 0x01, 0xE0,
+	0x65, 0xF9, 0x8F, 0xCF, 0xA5, 0xB6, 0x8F, 0x12,
+	0xA3, 0x2D, 0x48, 0x2E, 0xC7, 0xEE, 0x86, 0x58,
+	0xE9, 0x86, 0x91, 0x55, 0x5B, 0x44, 0xC5, 0x93,
+	0x11, 0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP384r1_oid_der[] = {
+	0x30, 0x82, 0x01, 0x40, 0x02, 0x01, 0x01, 0x30,
+	0x3C, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
+	0x01, 0x01, 0x02, 0x31, 0x00, 0x8C, 0xB9, 0x1E,
+	0x82, 0xA3, 0x38, 0x6D, 0x28, 0x0F, 0x5D, 0x6F,
+	0x7E, 0x50, 0xE6, 0x41, 0xDF, 0x15, 0x2F, 0x71,
+	0x09, 0xED, 0x54, 0x56, 0xB4, 0x12, 0xB1, 0xDA,
+	0x19, 0x7F, 0xB7, 0x11, 0x23, 0xAC, 0xD3, 0xA7,
+	0x29, 0x90, 0x1D, 0x1A, 0x71, 0x87, 0x47, 0x00,
+	0x13, 0x31, 0x07, 0xEC, 0x53, 0x30, 0x64, 0x04,
+	0x30, 0x7B, 0xC3, 0x82, 0xC6, 0x3D, 0x8C, 0x15,
+	0x0C, 0x3C, 0x72, 0x08, 0x0A, 0xCE, 0x05, 0xAF,
+	0xA0, 0xC2, 0xBE, 0xA2, 0x8E, 0x4F, 0xB2, 0x27,
+	0x87, 0x13, 0x91, 0x65, 0xEF, 0xBA, 0x91, 0xF9,
+	0x0F, 0x8A, 0xA5, 0x81, 0x4A, 0x50, 0x3A, 0xD4,
+	0xEB, 0x04, 0xA8, 0xC7, 0xDD, 0x22, 0xCE, 0x28,
+	0x26, 0x04, 0x30, 0x04, 0xA8, 0xC7, 0xDD, 0x22,
+	0xCE, 0x28, 0x26, 0x8B, 0x39, 0xB5, 0x54, 0x16,
+	0xF0, 0x44, 0x7C, 0x2F, 0xB7, 0x7D, 0xE1, 0x07,
+	0xDC, 0xD2, 0xA6, 0x2E, 0x88, 0x0E, 0xA5, 0x3E,
+	0xEB, 0x62, 0xD5, 0x7C, 0xB4, 0x39, 0x02, 0x95,
+	0xDB, 0xC9, 0x94, 0x3A, 0xB7, 0x86, 0x96, 0xFA,
+	0x50, 0x4C, 0x11, 0x04, 0x61, 0x04, 0x1D, 0x1C,
+	0x64, 0xF0, 0x68, 0xCF, 0x45, 0xFF, 0xA2, 0xA6,
+	0x3A, 0x81, 0xB7, 0xC1, 0x3F, 0x6B, 0x88, 0x47,
+	0xA3, 0xE7, 0x7E, 0xF1, 0x4F, 0xE3, 0xDB, 0x7F,
+	0xCA, 0xFE, 0x0C, 0xBD, 0x10, 0xE8, 0xE8, 0x26,
+	0xE0, 0x34, 0x36, 0xD6, 0x46, 0xAA, 0xEF, 0x87,
+	0xB2, 0xE2, 0x47, 0xD4, 0xAF, 0x1E, 0x8A, 0xBE,
+	0x1D, 0x75, 0x20, 0xF9, 0xC2, 0xA4, 0x5C, 0xB1,
+	0xEB, 0x8E, 0x95, 0xCF, 0xD5, 0x52, 0x62, 0xB7,
+	0x0B, 0x29, 0xFE, 0xEC, 0x58, 0x64, 0xE1, 0x9C,
+	0x05, 0x4F, 0xF9, 0x91, 0x29, 0x28, 0x0E, 0x46,
+	0x46, 0x21, 0x77, 0x91, 0x81, 0x11, 0x42, 0x82,
+	0x03, 0x41, 0x26, 0x3C, 0x53, 0x15, 0x02, 0x31,
+	0x00, 0x8C, 0xB9, 0x1E, 0x82, 0xA3, 0x38, 0x6D,
+	0x28, 0x0F, 0x5D, 0x6F, 0x7E, 0x50, 0xE6, 0x41,
+	0xDF, 0x15, 0x2F, 0x71, 0x09, 0xED, 0x54, 0x56,
+	0xB3, 0x1F, 0x16, 0x6E, 0x6C, 0xAC, 0x04, 0x25,
+	0xA7, 0xCF, 0x3A, 0xB6, 0xAF, 0x6B, 0x7F, 0xC3,
+	0x10, 0x3B, 0x88, 0x32, 0x02, 0xE9, 0x04, 0x65,
+	0x65, 0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP384t1_oid_der[] = {
+	0x30, 0x82, 0x01, 0x40, 0x02, 0x01, 0x01, 0x30,
+	0x3C, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
+	0x01, 0x01, 0x02, 0x31, 0x00, 0x8C, 0xB9, 0x1E,
+	0x82, 0xA3, 0x38, 0x6D, 0x28, 0x0F, 0x5D, 0x6F,
+	0x7E, 0x50, 0xE6, 0x41, 0xDF, 0x15, 0x2F, 0x71,
+	0x09, 0xED, 0x54, 0x56, 0xB4, 0x12, 0xB1, 0xDA,
+	0x19, 0x7F, 0xB7, 0x11, 0x23, 0xAC, 0xD3, 0xA7,
+	0x29, 0x90, 0x1D, 0x1A, 0x71, 0x87, 0x47, 0x00,
+	0x13, 0x31, 0x07, 0xEC, 0x53, 0x30, 0x64, 0x04,
+	0x30, 0x8C, 0xB9, 0x1E, 0x82, 0xA3, 0x38, 0x6D,
+	0x28, 0x0F, 0x5D, 0x6F, 0x7E, 0x50, 0xE6, 0x41,
+	0xDF, 0x15, 0x2F, 0x71, 0x09, 0xED, 0x54, 0x56,
+	0xB4, 0x12, 0xB1, 0xDA, 0x19, 0x7F, 0xB7, 0x11,
+	0x23, 0xAC, 0xD3, 0xA7, 0x29, 0x90, 0x1D, 0x1A,
+	0x71, 0x87, 0x47, 0x00, 0x13, 0x31, 0x07, 0xEC,
+	0x50, 0x04, 0x30, 0x7F, 0x51, 0x9E, 0xAD, 0xA7,
+	0xBD, 0xA8, 0x1B, 0xD8, 0x26, 0xDB, 0xA6, 0x47,
+	0x91, 0x0F, 0x8C, 0x4B, 0x93, 0x46, 0xED, 0x8C,
+	0xCD, 0xC6, 0x4E, 0x4B, 0x1A, 0xBD, 0x11, 0x75,
+	0x6D, 0xCE, 0x1D, 0x20, 0x74, 0xAA, 0x26, 0x3B,
+	0x88, 0x80, 0x5C, 0xED, 0x70, 0x35, 0x5A, 0x33,
+	0xB4, 0x71, 0xEE, 0x04, 0x61, 0x04, 0x18, 0xDE,
+	0x98, 0xB0, 0x2D, 0xB9, 0xA3, 0x06, 0xF2, 0xAF,
+	0xCD, 0x72, 0x35, 0xF7, 0x2A, 0x81, 0x9B, 0x80,
+	0xAB, 0x12, 0xEB, 0xD6, 0x53, 0x17, 0x24, 0x76,
+	0xFE, 0xCD, 0x46, 0x2A, 0xAB, 0xFF, 0xC4, 0xFF,
+	0x19, 0x1B, 0x94, 0x6A, 0x5F, 0x54, 0xD8, 0xD0,
+	0xAA, 0x2F, 0x41, 0x88, 0x08, 0xCC, 0x25, 0xAB,
+	0x05, 0x69, 0x62, 0xD3, 0x06, 0x51, 0xA1, 0x14,
+	0xAF, 0xD2, 0x75, 0x5A, 0xD3, 0x36, 0x74, 0x7F,
+	0x93, 0x47, 0x5B, 0x7A, 0x1F, 0xCA, 0x3B, 0x88,
+	0xF2, 0xB6, 0xA2, 0x08, 0xCC, 0xFE, 0x46, 0x94,
+	0x08, 0x58, 0x4D, 0xC2, 0xB2, 0x91, 0x26, 0x75,
+	0xBF, 0x5B, 0x9E, 0x58, 0x29, 0x28, 0x02, 0x31,
+	0x00, 0x8C, 0xB9, 0x1E, 0x82, 0xA3, 0x38, 0x6D,
+	0x28, 0x0F, 0x5D, 0x6F, 0x7E, 0x50, 0xE6, 0x41,
+	0xDF, 0x15, 0x2F, 0x71, 0x09, 0xED, 0x54, 0x56,
+	0xB3, 0x1F, 0x16, 0x6E, 0x6C, 0xAC, 0x04, 0x25,
+	0xA7, 0xCF, 0x3A, 0xB6, 0xAF, 0x6B, 0x7F, 0xC3,
+	0x10, 0x3B, 0x88, 0x32, 0x02, 0xE9, 0x04, 0x65,
+	0x65, 0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP512r1_oid_der[] = {
+	0x30, 0x82, 0x01, 0xA2, 0x02, 0x01, 0x01, 0x30,
+	0x4C, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
+	0x01, 0x01, 0x02, 0x41, 0x00, 0xAA, 0xDD, 0x9D,
+	0xB8, 0xDB, 0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6,
+	0xAE, 0x33, 0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D,
+	0xB3, 0xB3, 0xC9, 0xD2, 0x0E, 0xD6, 0x63, 0x9C,
+	0xCA, 0x70, 0x33, 0x08, 0x71, 0x7D, 0x4D, 0x9B,
+	0x00, 0x9B, 0xC6, 0x68, 0x42, 0xAE, 0xCD, 0xA1,
+	0x2A, 0xE6, 0xA3, 0x80, 0xE6, 0x28, 0x81, 0xFF,
+	0x2F, 0x2D, 0x82, 0xC6, 0x85, 0x28, 0xAA, 0x60,
+	0x56, 0x58, 0x3A, 0x48, 0xF3, 0x30, 0x81, 0x84,
+	0x04, 0x40, 0x78, 0x30, 0xA3, 0x31, 0x8B, 0x60,
+	0x3B, 0x89, 0xE2, 0x32, 0x71, 0x45, 0xAC, 0x23,
+	0x4C, 0xC5, 0x94, 0xCB, 0xDD, 0x8D, 0x3D, 0xF9,
+	0x16, 0x10, 0xA8, 0x34, 0x41, 0xCA, 0xEA, 0x98,
+	0x63, 0xBC, 0x2D, 0xED, 0x5D, 0x5A, 0xA8, 0x25,
+	0x3A, 0xA1, 0x0A, 0x2E, 0xF1, 0xC9, 0x8B, 0x9A,
+	0xC8, 0xB5, 0x7F, 0x11, 0x17, 0xA7, 0x2B, 0xF2,
+	0xC7, 0xB9, 0xE7, 0xC1, 0xAC, 0x4D, 0x77, 0xFC,
+	0x94, 0xCA, 0x04, 0x40, 0x3D, 0xF9, 0x16, 0x10,
+	0xA8, 0x34, 0x41, 0xCA, 0xEA, 0x98, 0x63, 0xBC,
+	0x2D, 0xED, 0x5D, 0x5A, 0xA8, 0x25, 0x3A, 0xA1,
+	0x0A, 0x2E, 0xF1, 0xC9, 0x8B, 0x9A, 0xC8, 0xB5,
+	0x7F, 0x11, 0x17, 0xA7, 0x2B, 0xF2, 0xC7, 0xB9,
+	0xE7, 0xC1, 0xAC, 0x4D, 0x77, 0xFC, 0x94, 0xCA,
+	0xDC, 0x08, 0x3E, 0x67, 0x98, 0x40, 0x50, 0xB7,
+	0x5E, 0xBA, 0xE5, 0xDD, 0x28, 0x09, 0xBD, 0x63,
+	0x80, 0x16, 0xF7, 0x23, 0x04, 0x81, 0x81, 0x04,
+	0x81, 0xAE, 0xE4, 0xBD, 0xD8, 0x2E, 0xD9, 0x64,
+	0x5A, 0x21, 0x32, 0x2E, 0x9C, 0x4C, 0x6A, 0x93,
+	0x85, 0xED, 0x9F, 0x70, 0xB5, 0xD9, 0x16, 0xC1,
+	0xB4, 0x3B, 0x62, 0xEE, 0xF4, 0xD0, 0x09, 0x8E,
+	0xFF, 0x3B, 0x1F, 0x78, 0xE2, 0xD0, 0xD4, 0x8D,
+	0x50, 0xD1, 0x68, 0x7B, 0x93, 0xB9, 0x7D, 0x5F,
+	0x7C, 0x6D, 0x50, 0x47, 0x40, 0x6A, 0x5E, 0x68,
+	0x8B, 0x35, 0x22, 0x09, 0xBC, 0xB9, 0xF8, 0x22,
+	0x7D, 0xDE, 0x38, 0x5D, 0x56, 0x63, 0x32, 0xEC,
+	0xC0, 0xEA, 0xBF, 0xA9, 0xCF, 0x78, 0x22, 0xFD,
+	0xF2, 0x09, 0xF7, 0x00, 0x24, 0xA5, 0x7B, 0x1A,
+	0xA0, 0x00, 0xC5, 0x5B, 0x88, 0x1F, 0x81, 0x11,
+	0xB2, 0xDC, 0xDE, 0x49, 0x4A, 0x5F, 0x48, 0x5E,
+	0x5B, 0xCA, 0x4B, 0xD8, 0x8A, 0x27, 0x63, 0xAE,
+	0xD1, 0xCA, 0x2B, 0x2F, 0xA8, 0xF0, 0x54, 0x06,
+	0x78, 0xCD, 0x1E, 0x0F, 0x3A, 0xD8, 0x08, 0x92,
+	0x02, 0x41, 0x00, 0xAA, 0xDD, 0x9D, 0xB8, 0xDB,
+	0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6, 0xAE, 0x33,
+	0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D, 0xB3, 0xB3,
+	0xC9, 0xD2, 0x0E, 0xD6, 0x63, 0x9C, 0xCA, 0x70,
+	0x33, 0x08, 0x70, 0x55, 0x3E, 0x5C, 0x41, 0x4C,
+	0xA9, 0x26, 0x19, 0x41, 0x86, 0x61, 0x19, 0x7F,
+	0xAC, 0x10, 0x47, 0x1D, 0xB1, 0xD3, 0x81, 0x08,
+	0x5D, 0xDA, 0xDD, 0xB5, 0x87, 0x96, 0x82, 0x9C,
+	0xA9, 0x00, 0x69, 0x02, 0x01, 0x01,
+};
+static const uint8_t brainpoolP512t1_oid_der[] = {
+	0x30, 0x82, 0x01, 0xA2, 0x02, 0x01, 0x01, 0x30,
+	0x4C, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
+	0x01, 0x01, 0x02, 0x41, 0x00, 0xAA, 0xDD, 0x9D,
+	0xB8, 0xDB, 0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6,
+	0xAE, 0x33, 0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D,
+	0xB3, 0xB3, 0xC9, 0xD2, 0x0E, 0xD6, 0x63, 0x9C,
+	0xCA, 0x70, 0x33, 0x08, 0x71, 0x7D, 0x4D, 0x9B,
+	0x00, 0x9B, 0xC6, 0x68, 0x42, 0xAE, 0xCD, 0xA1,
+	0x2A, 0xE6, 0xA3, 0x80, 0xE6, 0x28, 0x81, 0xFF,
+	0x2F, 0x2D, 0x82, 0xC6, 0x85, 0x28, 0xAA, 0x60,
+	0x56, 0x58, 0x3A, 0x48, 0xF3, 0x30, 0x81, 0x84,
+	0x04, 0x40, 0xAA, 0xDD, 0x9D, 0xB8, 0xDB, 0xE9,
+	0xC4, 0x8B, 0x3F, 0xD4, 0xE6, 0xAE, 0x33, 0xC9,
+	0xFC, 0x07, 0xCB, 0x30, 0x8D, 0xB3, 0xB3, 0xC9,
+	0xD2, 0x0E, 0xD6, 0x63, 0x9C, 0xCA, 0x70, 0x33,
+	0x08, 0x71, 0x7D, 0x4D, 0x9B, 0x00, 0x9B, 0xC6,
+	0x68, 0x42, 0xAE, 0xCD, 0xA1, 0x2A, 0xE6, 0xA3,
+	0x80, 0xE6, 0x28, 0x81, 0xFF, 0x2F, 0x2D, 0x82,
+	0xC6, 0x85, 0x28, 0xAA, 0x60, 0x56, 0x58, 0x3A,
+	0x48, 0xF0, 0x04, 0x40, 0x7C, 0xBB, 0xBC, 0xF9,
+	0x44, 0x1C, 0xFA, 0xB7, 0x6E, 0x18, 0x90, 0xE4,
+	0x68, 0x84, 0xEA, 0xE3, 0x21, 0xF7, 0x0C, 0x0B,
+	0xCB, 0x49, 0x81, 0x52, 0x78, 0x97, 0x50, 0x4B,
+	0xEC, 0x3E, 0x36, 0xA6, 0x2B, 0xCD, 0xFA, 0x23,
+	0x04, 0x97, 0x65, 0x40, 0xF6, 0x45, 0x00, 0x85,
+	0xF2, 0xDA, 0xE1, 0x45, 0xC2, 0x25, 0x53, 0xB4,
+	0x65, 0x76, 0x36, 0x89, 0x18, 0x0E, 0xA2, 0x57,
+	0x18, 0x67, 0x42, 0x3E, 0x04, 0x81, 0x81, 0x04,
+	0x64, 0x0E, 0xCE, 0x5C, 0x12, 0x78, 0x87, 0x17,
+	0xB9, 0xC1, 0xBA, 0x06, 0xCB, 0xC2, 0xA6, 0xFE,
+	0xBA, 0x85, 0x84, 0x24, 0x58, 0xC5, 0x6D, 0xDE,
+	0x9D, 0xB1, 0x75, 0x8D, 0x39, 0xC0, 0x31, 0x3D,
+	0x82, 0xBA, 0x51, 0x73, 0x5C, 0xDB, 0x3E, 0xA4,
+	0x99, 0xAA, 0x77, 0xA7, 0xD6, 0x94, 0x3A, 0x64,
+	0xF7, 0xA3, 0xF2, 0x5F, 0xE2, 0x6F, 0x06, 0xB5,
+	0x1B, 0xAA, 0x26, 0x96, 0xFA, 0x90, 0x35, 0xDA,
+	0x5B, 0x53, 0x4B, 0xD5, 0x95, 0xF5, 0xAF, 0x0F,
+	0xA2, 0xC8, 0x92, 0x37, 0x6C, 0x84, 0xAC, 0xE1,
+	0xBB, 0x4E, 0x30, 0x19, 0xB7, 0x16, 0x34, 0xC0,
+	0x11, 0x31, 0x15, 0x9C, 0xAE, 0x03, 0xCE, 0xE9,
+	0xD9, 0x93, 0x21, 0x84, 0xBE, 0xEF, 0x21, 0x6B,
+	0xD7, 0x1D, 0xF2, 0xDA, 0xDF, 0x86, 0xA6, 0x27,
+	0x30, 0x6E, 0xCF, 0xF9, 0x6D, 0xBB, 0x8B, 0xAC,
+	0xE1, 0x98, 0xB6, 0x1E, 0x00, 0xF8, 0xB3, 0x32,
+	0x02, 0x41, 0x00, 0xAA, 0xDD, 0x9D, 0xB8, 0xDB,
+	0xE9, 0xC4, 0x8B, 0x3F, 0xD4, 0xE6, 0xAE, 0x33,
+	0xC9, 0xFC, 0x07, 0xCB, 0x30, 0x8D, 0xB3, 0xB3,
+	0xC9, 0xD2, 0x0E, 0xD6, 0x63, 0x9C, 0xCA, 0x70,
+	0x33, 0x08, 0x70, 0x55, 0x3E, 0x5C, 0x41, 0x4C,
+	0xA9, 0x26, 0x19, 0x41, 0x86, 0x61, 0x19, 0x7F,
+	0xAC, 0x10, 0x47, 0x1D, 0xB1, 0xD3, 0x81, 0x08,
+	0x5D, 0xDA, 0xDD, 0xB5, 0x87, 0x96, 0x82, 0x9C,
+	0xA9, 0x00, 0x69, 0x02, 0x01, 0x01,
+};
+
+struct supported_ecc_curve {
+	const uint8_t *oid_der;
+	size_t oid_size;
+	const uint8_t *name_der;
+	size_t name_size;
+	size_t key_size;
+	uint32_t tee_id;
+	const char *label;
+	size_t label_size;
+};
+
+#define ECC_CURVE(_tee_id, _key_size, _label)	\
+	{							\
+		.tee_id = _tee_id,				\
+		.key_size = _key_size,				\
+		.oid_der = _label ## _oid_der,			\
+		.oid_size = sizeof(_label ## _oid_der),		\
+		.name_der = _label ## _name_der,			\
+		.name_size = sizeof(_label ## _name_der),	\
+		.label = #_label,					\
+		.label_size = sizeof(#_label) - 1,		\
+	}
+
+/* These are introduced with GPD TEE Core Internal API v1.2 */
+#ifndef TEE_ECC_CURVE_BSI_P160r1
+#define TEE_ECC_CURVE_BSI_P160r1	0x00000101 /* 160 bits */
+#define TEE_ECC_CURVE_BSI_P192r1	0x00000102 /* 192 bits */
+#define TEE_ECC_CURVE_BSI_P224r1	0x00000103 /* 224 bits */
+#define TEE_ECC_CURVE_BSI_P256r1	0x00000104 /* 256 bits */
+#define TEE_ECC_CURVE_BSI_P320r1	0x00000105 /* 320 bits */
+#define TEE_ECC_CURVE_BSI_P384r1	0x00000106 /* 384 bits */
+#define TEE_ECC_CURVE_BSI_P512r1	0x00000107 /* 512 bits */
+#define TEE_ECC_CURVE_BSI_P160t1	0x00000201 /* 160 bits */
+#define TEE_ECC_CURVE_BSI_P192t1	0x00000202 /* 192 bits */
+#define TEE_ECC_CURVE_BSI_P224t1	0x00000203 /* 224 bits */
+#define TEE_ECC_CURVE_BSI_P256t1	0x00000204 /* 256 bits */
+#define TEE_ECC_CURVE_BSI_P320t1	0x00000205 /* 320 bits */
+#define TEE_ECC_CURVE_BSI_P384t1	0x00000206 /* 384 bits */
+#define TEE_ECC_CURVE_BSI_P512t1	0x00000207 /* 512 bits */
+#define TEE_ECC_CURVE_25519		0x00000300 /* 256 bits */
+#define TEE_ECC_CURVE_SM2		0x00000400 /* 256 bits */
+#endif
+
+static const struct supported_ecc_curve ec_curve_param[] = {
+	ECC_CURVE(TEE_ECC_CURVE_NIST_P192, 192, prime192v1),
+	ECC_CURVE(TEE_ECC_CURVE_NIST_P224, 224, secp224r1),
+	ECC_CURVE(TEE_ECC_CURVE_NIST_P256, 256, prime256v1),
+	ECC_CURVE(TEE_ECC_CURVE_NIST_P384, 384, secp384r1),
+	ECC_CURVE(TEE_ECC_CURVE_NIST_P521, 521, secp521r1),
+	/* Note: this will be for GPD TEE Core Internal API v1.2 */
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P160r1, 160, brainpoolP160r1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P160t1, 160, brainpoolP160t1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P192r1, 192, brainpoolP192r1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P192t1, 192, brainpoolP192t1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P224r1, 224, brainpoolP224r1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P224t1, 224, brainpoolP224t1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P256r1, 256, brainpoolP256r1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P256t1, 256, brainpoolP256t1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P320r1, 320, brainpoolP320r1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P320t1, 320, brainpoolP320t1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P384r1, 384, brainpoolP384r1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P384t1, 384, brainpoolP384t1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P512r1, 512, brainpoolP512r1),
+	ECC_CURVE(TEE_ECC_CURVE_BSI_P512t1, 512, brainpoolP512t1),
+};
+
+static const struct supported_ecc_curve *get_curve(void *attr, size_t size)
+{
+	size_t idx = 0;
+
+	/* Weak: not a real DER parser: try by params then by named curve */
+	for (idx = 0; idx < ARRAY_SIZE(ec_curve_param); idx++) {
+		const struct supported_ecc_curve *curve = &ec_curve_param[idx];
+
+		if (size == curve->oid_size &&
+		    !TEE_MemCompare(attr, curve->oid_der, curve->oid_size))
+			return curve;
+
+		if (size == curve->name_size &&
+		    !TEE_MemCompare(attr, curve->name_der, curve->name_size))
+			return curve;
+	}
+
+	return NULL;
+}
+
+size_t ec_params2tee_keysize(void *ec_params, size_t size)
+{
+	const struct supported_ecc_curve *curve = get_curve(ec_params, size);
+
+	if (!curve)
+		return 0;
+
+	return curve->key_size;
+}
+
+/*
+ * This function intentionnally panics if the curve is not found.
+ * Use ec_params2tee_keysize() to check the curve is supported by
+ * the internal core API.
+ */
+uint32_t ec_params2tee_curve(void *ec_params, size_t size)
+{
+	const struct supported_ecc_curve *curve = get_curve(ec_params, size);
+
+	assert(curve);
+
+	return curve->tee_id;
+}
+
+uint32_t load_tee_ec_key_attrs(TEE_Attribute **tee_attrs, size_t *tee_count,
+				struct sks_object *obj)
+{
+	TEE_Attribute *attrs = NULL;
+	size_t count = 0;
+	uint32_t rv = SKS_ERROR;
+
+	assert(get_type(obj->attributes) == SKS_CKK_EC);
+
+	switch (get_class(obj->attributes)) {
+	case SKS_CKO_PUBLIC_KEY:
+		attrs = TEE_Malloc(3 * sizeof(TEE_Attribute),
+				   TEE_USER_MEM_HINT_NO_FILL_ZERO);
+		if (!attrs)
+			return SKS_MEMORY;
+
+		if (sks2tee_load_attr(&attrs[count], TEE_ATTR_ECC_CURVE,
+					obj, SKS_CKA_EC_PARAMS))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_ECC_PUBLIC_VALUE_X,
+					obj, SKS_CKA_EC_POINT))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_ECC_PUBLIC_VALUE_Y,
+					obj, SKS_CKA_EC_POINT))
+			count++;
+
+		if (count == 3)
+			rv = SKS_OK;
+
+		break;
+
+	case SKS_CKO_PRIVATE_KEY:
+		attrs = TEE_Malloc(4 * sizeof(TEE_Attribute),
+				   TEE_USER_MEM_HINT_NO_FILL_ZERO);
+		if (!attrs)
+			return SKS_MEMORY;
+
+		if (sks2tee_load_attr(&attrs[count], TEE_ATTR_ECC_CURVE,
+					obj, SKS_CKA_EC_PARAMS))
+			count++;
+
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_ECC_PRIVATE_VALUE,
+					obj, SKS_CKA_VALUE))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_ECC_PUBLIC_VALUE_X,
+					obj, SKS_CKA_EC_POINT))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_ECC_PUBLIC_VALUE_Y,
+					obj, SKS_CKA_EC_POINT))
+			count++;
+
+		if (count == 4)
+			rv = SKS_OK;
+
+		break;
+
+	default:
+		assert(0);
+		break;
+	}
+
+	if (rv == SKS_OK) {
+		*tee_attrs = attrs;
+		*tee_count = count;
+	}
+
+	return rv;
+}
+
+uint32_t sks2tee_algo_ecdh(uint32_t *tee_id,
+			   struct sks_attribute_head *proc_params,
+			   struct sks_object *obj)
+{
+	struct serialargs args;
+	uint32_t rv = 0;
+	uint32_t kdf = 0;
+
+	TEE_MemFill(&args, 0, sizeof(args));
+
+	serialargs_init(&args, proc_params->data, proc_params->size);
+
+	rv = serialargs_get(&args, &kdf, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	if (kdf != SKS_CKD_NULL) {
+		EMSG("Currently no support for hashed shared data");
+		return SKS_CKR_MECHANISM_PARAM_INVALID;
+	}
+
+	switch (get_object_key_bit_size(obj)) {
+	case 192:
+		*tee_id = TEE_ALG_ECDH_P192;
+		break;
+	case 224:
+		*tee_id = TEE_ALG_ECDH_P224;
+		break;
+	case 256:
+		*tee_id = TEE_ALG_ECDH_P256;
+		break;
+	case 384:
+		*tee_id = TEE_ALG_ECDH_P384;
+		break;
+	case 521:
+		*tee_id = TEE_ALG_ECDH_P521;
+		break;
+	default:
+		TEE_Panic(0);
+		break;
+	}
+
+	return SKS_OK;
+}
+
+uint32_t sks2tee_ecdh_param_pub(struct sks_attribute_head *proc_params,
+			        void **pub_data, size_t *pub_size)
+{
+	struct serialargs args;
+	uint32_t rv = 0;
+	uint32_t temp = 0;
+
+	TEE_MemFill(&args, 0, sizeof(args));
+
+	serialargs_init(&args, proc_params->data, proc_params->size);
+
+	/* Skip KDF */
+	rv = serialargs_get(&args, &temp, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	/* Shared data size, shall be 0 */
+	rv = serialargs_get(&args, &temp, sizeof(uint32_t));
+	if (rv || temp)
+		return rv;
+
+	/* Public data size and content */
+	rv = serialargs_get(&args, &temp, sizeof(uint32_t));
+	if (rv || !temp)
+		return rv;
+
+	*pub_size = temp;
+
+	return serialargs_get_ptr(&args, pub_data, temp);
+}
+
+uint32_t sks2tee_algo_ecdsa(uint32_t *tee_id,
+			   struct sks_attribute_head *proc_params,
+			   struct sks_object *obj)
+{
+	switch (proc_params->id) {
+	case SKS_CKM_ECDSA:
+	case SKS_CKM_ECDSA_SHA1:
+	case SKS_CKM_ECDSA_SHA224:
+	case SKS_CKM_ECDSA_SHA256:
+	case SKS_CKM_ECDSA_SHA384:
+	case SKS_CKM_ECDSA_SHA512:
+		break;
+	default:
+		return SKS_ERROR;
+	}
+
+	switch (get_object_key_bit_size(obj)) {
+	case 192:
+		*tee_id = TEE_ALG_ECDSA_P192;
+		break;
+	case 224:
+		*tee_id = TEE_ALG_ECDSA_P224;
+		break;
+	case 256:
+		*tee_id = TEE_ALG_ECDSA_P256;
+		break;
+	case 384:
+		*tee_id = TEE_ALG_ECDSA_P384;
+		break;
+	case 521:
+		*tee_id = TEE_ALG_ECDSA_P521;
+		break;
+	default:
+		TEE_Panic(0);
+		break;
+	}
+
+	return SKS_OK;
+}
+
+static uint32_t tee2sks_ec_attributes(struct sks_attrs_head **pub_head,
+				 struct sks_attrs_head **priv_head,
+				 TEE_ObjectHandle tee_obj, uint32_t tee_size)
+{
+	void *x_ptr = NULL;
+	void *y_ptr = NULL;
+	uint8_t *ecpoint = NULL;
+	size_t x_size = 0;
+	size_t y_size = 0;
+	size_t psize = 0;
+	size_t qsize = 0;
+	size_t dersize = 0;
+	size_t poffset = 0;
+	uint32_t rv = 0;
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_VALUE,
+				   tee_obj, TEE_ATTR_ECC_PRIVATE_VALUE);
+	if (rv)
+		goto bail;
+
+	rv = alloc_get_tee_attribute_data(tee_obj, TEE_ATTR_ECC_PUBLIC_VALUE_X,
+					&x_ptr, &x_size);
+	if (rv)
+		goto bail;
+
+	rv = alloc_get_tee_attribute_data(tee_obj, TEE_ATTR_ECC_PUBLIC_VALUE_Y,
+					&y_ptr, &y_size);
+	if (rv)
+		goto x_cleanup;
+
+	psize = (tee_size + 7) / 8;
+	if (x_size > psize || y_size > psize) {
+		rv = SKS_BAD_PARAM;
+		goto p_cleanup;
+	}
+
+	qsize = 1 + 2 * psize;
+	/* TODO: Support DER long definitive form, needed for 64 key size */
+	if (qsize < 0x80) {
+		dersize = qsize + 2;
+	} else {
+		EMSG("DER long definitive form not yet supported");
+		rv = SKS_CKR_MECHANISM_INVALID;
+		goto p_cleanup;
+	}
+
+	ecpoint = TEE_Malloc(dersize, TEE_MALLOC_FILL_ZERO);
+	if (!ecpoint) {
+		rv = SKS_MEMORY;
+		goto p_cleanup;
+	}
+
+	/* DER encoding */
+	ecpoint[0] = 0x04;
+	ecpoint[1] = qsize & 0x7f;
+	/* Only UNCOMPRESSED ECPOINT is currently supported */
+	ecpoint[2] = 0x04;
+
+	poffset = 0;
+	if (x_size < psize)
+		poffset = psize - x_size;
+	TEE_MemMove(ecpoint + 3 + poffset, x_ptr, x_size);
+
+	poffset = 0;
+	if (y_size < psize)
+		poffset = psize - y_size;
+	TEE_MemMove(ecpoint + 3 + psize + poffset, y_ptr, y_size);
+
+	/*
+	 * Add EC_POINT on both private and public key objects as
+	 * TEE_PopulateTransientObject requires public x/y values
+	 * for TEE_TYPE_ECDSA_KEYPAIR.
+	 */
+	rv = add_attribute(priv_head, SKS_CKA_EC_POINT, ecpoint, dersize);
+	if (rv)
+		goto priv_cleanup;
+
+	rv = add_attribute(pub_head, SKS_CKA_EC_POINT, ecpoint, dersize);
+
+priv_cleanup:
+	TEE_Free(ecpoint);
+p_cleanup:
+	TEE_Free(y_ptr);
+x_cleanup:
+	TEE_Free(x_ptr);
+bail:
+	return rv;
+}
+
+uint32_t generate_ec_keys(struct sks_attribute_head *proc_params,
+			  struct sks_attrs_head **pub_head,
+			  struct sks_attrs_head **priv_head)
+{
+	uint32_t rv = 0;
+	void *a_ptr = NULL;
+	size_t a_size = 0;
+	uint32_t tee_size = 0;
+	uint32_t tee_curve = 0;
+	TEE_ObjectHandle tee_obj = TEE_HANDLE_NULL;
+	TEE_Attribute tee_key_attr[1];
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	TEE_MemFill(tee_key_attr, 0, sizeof(tee_key_attr));
+
+	if (!proc_params || !*pub_head || !*priv_head)
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+
+	if (!get_attribute_ptr(*pub_head, SKS_CKA_EC_POINT, NULL, NULL) ||
+	    !get_attribute_ptr(*priv_head, SKS_CKA_VALUE, NULL, NULL) ||
+	    !get_attribute_ptr(*priv_head, SKS_CKA_EC_POINT, NULL, NULL)) {
+		EMSG("Unexpected attribute(s) found");
+		trace_attributes("public-key", *pub_head);
+		trace_attributes("privat-key", *priv_head);
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	if (get_attribute_ptr(*pub_head, SKS_CKA_EC_PARAMS, &a_ptr, &a_size)) {
+		EMSG("Not EC_PARAMS attribute found");
+		return SKS_CKR_ATTRIBUTE_TYPE_INVALID;
+	}
+
+	tee_size = ec_params2tee_keysize(a_ptr, a_size);
+	if (!tee_size)
+		return SKS_CKR_ATTRIBUTE_TYPE_INVALID;
+
+	tee_curve = ec_params2tee_curve(a_ptr, a_size);
+
+	TEE_InitValueAttribute(&tee_key_attr[0], TEE_ATTR_ECC_CURVE,
+				tee_curve, 0);
+
+	/* Create an ECDSA TEE key: will match PKCS11 ECDSA and ECDH */
+	res = TEE_AllocateTransientObject(TEE_TYPE_ECDSA_KEYPAIR,
+					  521/*tee_size*/, &tee_obj);
+	if (res) {
+		EMSG("TEE service failed, %" PRIx32, res);
+		return tee2sks_error(res);
+	}
+
+	res = TEE_RestrictObjectUsage1(tee_obj, TEE_USAGE_EXTRACTABLE);
+	if (res) {
+		rv = tee2sks_error(res);
+		goto bail;
+	}
+
+	res = TEE_GenerateKey(tee_obj, tee_size, &tee_key_attr[0], 1);
+	if (res) {
+		rv = tee2sks_error(res);
+		goto bail;
+	}
+
+	/*
+	 * Private key needs the same EC_PARAMS as used by the public key.
+	 * Since it is also common for userspace to provide an empty private
+	 * EC_PARAMS, make sure to remove before adding the correct one.
+	 */
+	remove_attribute(priv_head, SKS_CKA_EC_PARAMS);
+	rv = add_attribute(priv_head, SKS_CKA_EC_PARAMS, a_ptr, a_size);
+	if (rv)
+		goto bail;
+
+	rv = tee2sks_ec_attributes(pub_head, priv_head, tee_obj, tee_size);
+
+bail:
+	if (tee_obj != TEE_HANDLE_NULL)
+		TEE_FreeTransientObject(tee_obj);
+
+	return rv;
+}
+
diff --git a/ta/secure_key_services/src/processing_rsa.c b/ta/secure_key_services/src/processing_rsa.c
new file mode 100644
index 00000000..e22d569a
--- /dev/null
+++ b/ta/secure_key_services/src/processing_rsa.c
@@ -0,0 +1,515 @@
+/*
+ * Copyright (c) 2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <assert.h>
+#include <compiler.h>
+#include <tee_api_defines.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+#include "attributes.h"
+#include "pkcs11_token.h"
+#include "processing.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+uint32_t sks2tee_proc_params_rsa_pss(struct active_processing *processing,
+				     struct sks_attribute_head *proc_params)
+{
+	struct serialargs args;
+	uint32_t rv;
+	uint32_t data32;
+	uint32_t salt_len;
+
+	serialargs_init(&args, proc_params->data, proc_params->size);
+
+	rv = serialargs_get(&args, &data32, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &data32, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &salt_len, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	processing->extra_ctx = TEE_Malloc(sizeof(uint32_t),
+						TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!processing->extra_ctx)
+		return SKS_MEMORY;
+
+	*(uint32_t *)processing->extra_ctx = salt_len;
+
+	return SKS_OK;
+}
+
+void tee_release_rsa_pss_operation(struct active_processing *processing)
+{
+	TEE_Free(processing->extra_ctx);
+	processing->extra_ctx = NULL;
+}
+
+uint32_t sks2tee_algo_rsa_pss(uint32_t *tee_id,
+				struct sks_attribute_head *proc_params)
+{
+	struct serialargs args;
+	uint32_t rv;
+	uint32_t hash;
+	uint32_t mgf;
+	uint32_t salt_len;
+
+	serialargs_init(&args, proc_params->data, proc_params->size);
+
+	rv = serialargs_get(&args, &hash, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &mgf, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &salt_len, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	switch (*tee_id) {
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:
+		if (hash != SKS_CKM_SHA_1 || mgf != SKS_CKG_MGF1_SHA1)
+			return SKS_CKR_MECHANISM_PARAM_INVALID;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:
+		if (hash != SKS_CKM_SHA224 || mgf != SKS_CKG_MGF1_SHA224)
+			return SKS_CKR_MECHANISM_PARAM_INVALID;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:
+		if (hash != SKS_CKM_SHA256 || mgf != SKS_CKG_MGF1_SHA256)
+			return SKS_CKR_MECHANISM_PARAM_INVALID;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:
+		if (hash != SKS_CKM_SHA384 || mgf != SKS_CKG_MGF1_SHA384)
+			return SKS_CKR_MECHANISM_PARAM_INVALID;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:
+		if (hash != SKS_CKM_SHA512 || mgf != SKS_CKG_MGF1_SHA512)
+			return SKS_CKR_MECHANISM_PARAM_INVALID;
+		break;
+	default:
+		return SKS_ERROR;
+	}
+
+	return SKS_OK;
+}
+
+// Currently unused
+uint32_t tee_init_rsa_aes_key_wrap_operation(struct active_processing *proc,
+					     void *proc_params,
+					     size_t params_size)
+{
+	struct serialargs args;
+	uint32_t rv;
+	uint32_t aes_bit_size;
+	uint32_t hash;
+	uint32_t mgf;
+	uint32_t source_type;
+	void *source_data;
+	uint32_t source_size;
+
+	serialargs_init(&args, proc_params, params_size);
+
+	rv = serialargs_get(&args, &aes_bit_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &hash, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &mgf, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &source_type, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &source_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get_ptr(&args, &source_data, source_size);
+	if (rv)
+		return rv;
+
+	// TODO
+	(void)proc;
+	return SKS_ERROR;
+}
+
+uint32_t sks2tee_algo_rsa_oaep(uint32_t *tee_id,
+				struct sks_attribute_head *proc_params)
+{
+	struct serialargs args;
+	uint32_t rv;
+	uint32_t hash;
+	uint32_t mgf;
+	uint32_t source_type;
+	void *source_data;
+	uint32_t source_size;
+
+	serialargs_init(&args, proc_params->data, proc_params->size);
+
+	rv = serialargs_get(&args, &hash, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &mgf, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &source_type, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &source_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get_ptr(&args, &source_data, source_size);
+	if (rv)
+		return rv;
+
+	switch (proc_params->id) {
+	case SKS_CKM_RSA_PKCS_OAEP:
+		switch (hash) {
+		case SKS_CKM_SHA_1:
+			if (mgf != SKS_CKG_MGF1_SHA1 || source_size)
+				return SKS_CKR_MECHANISM_PARAM_INVALID;
+			*tee_id = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1;
+			break;
+		case SKS_CKM_SHA224:
+			if (mgf != SKS_CKG_MGF1_SHA224 || source_size)
+				return SKS_CKR_MECHANISM_PARAM_INVALID;
+			*tee_id = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224;
+			break;
+		case SKS_CKM_SHA256:
+			if (mgf != SKS_CKG_MGF1_SHA256 || source_size)
+				return SKS_CKR_MECHANISM_PARAM_INVALID;
+			*tee_id = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256;
+			break;
+		case SKS_CKM_SHA384:
+			if (mgf != SKS_CKG_MGF1_SHA384 || source_size)
+				return SKS_CKR_MECHANISM_PARAM_INVALID;
+			*tee_id = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384;
+			break;
+		case SKS_CKM_SHA512:
+			if (mgf != SKS_CKG_MGF1_SHA512 || source_size)
+				return SKS_CKR_MECHANISM_PARAM_INVALID;
+			*tee_id = TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512;
+			break;
+		default:
+			EMSG("Unexpected %s (0x%" PRIx32 ")",
+				sks2str_proc(hash), hash);
+			return SKS_ERROR;
+		}
+		break;
+	default:
+		EMSG("Unexpected %s (0x%" PRIx32 ")",
+			sks2str_proc(proc_params->id), proc_params->id);
+		return SKS_ERROR;
+	}
+
+	return SKS_OK;
+}
+
+// Unused yet...
+uint32_t tee_init_rsa_oaep_operation(struct active_processing *processing,
+				     void *proc_params, size_t params_size);
+
+uint32_t tee_init_rsa_oaep_operation(struct active_processing *processing,
+				     void *proc_params, size_t params_size)
+{
+	struct serialargs args;
+	uint32_t rv;
+	uint32_t hash;
+	uint32_t mgf;
+	uint32_t source_type;
+	void *source_data;
+	uint32_t source_size;
+
+	serialargs_init(&args, proc_params, params_size);
+
+	rv = serialargs_get(&args, &hash, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &mgf, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &source_type, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get(&args, &source_size, sizeof(uint32_t));
+	if (rv)
+		return rv;
+
+	rv = serialargs_get_ptr(&args, &source_data, source_size);
+	if (rv)
+		return rv;
+
+	// TODO
+	(void)processing;
+	return SKS_ERROR;
+}
+
+uint32_t load_tee_rsa_key_attrs(TEE_Attribute **tee_attrs, size_t *tee_count,
+				struct sks_object *obj)
+{
+	TEE_Attribute *attrs = NULL;
+	size_t count = 0;
+	uint32_t rv = SKS_ERROR;
+
+	assert(get_type(obj->attributes) == SKS_CKK_RSA);
+
+	switch (get_class(obj->attributes)) {
+	case SKS_CKO_PUBLIC_KEY:
+		attrs = TEE_Malloc(3 * sizeof(TEE_Attribute),
+				   TEE_USER_MEM_HINT_NO_FILL_ZERO);
+		if (!attrs)
+			return SKS_MEMORY;
+
+		if (sks2tee_load_attr(&attrs[count], TEE_ATTR_RSA_MODULUS,
+					obj, SKS_CKA_MODULUS))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_RSA_PUBLIC_EXPONENT,
+					obj, SKS_CKA_PUBLIC_EXPONENT))
+			count++;
+
+		if (count == 2)
+			rv = SKS_OK;
+
+		break;
+
+	case SKS_CKO_PRIVATE_KEY:
+		attrs = TEE_Malloc(8 * sizeof(TEE_Attribute),
+				   TEE_USER_MEM_HINT_NO_FILL_ZERO);
+		if (!attrs)
+			return SKS_MEMORY;
+
+		if (sks2tee_load_attr(&attrs[count], TEE_ATTR_RSA_MODULUS,
+					obj, SKS_CKA_MODULUS))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_RSA_PUBLIC_EXPONENT,
+					obj, SKS_CKA_PUBLIC_EXPONENT))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_RSA_PRIVATE_EXPONENT,
+					obj, SKS_CKA_PRIVATE_EXPONENT))
+			count++;
+
+		if (count != 3)
+			break;
+
+		if (get_attribute(obj->attributes, SKS_CKA_PRIME_1,
+					   NULL, NULL)) {
+			rv = SKS_OK;
+			break;
+		}
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_RSA_PRIME1,
+					obj, SKS_CKA_PRIME_1))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_RSA_PRIME2,
+					obj, SKS_CKA_PRIME_2))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_RSA_EXPONENT1,
+					obj, SKS_CKA_EXPONENT_1))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_RSA_EXPONENT2,
+					obj, SKS_CKA_EXPONENT_2))
+			count++;
+
+		if (sks2tee_load_attr(&attrs[count],
+					TEE_ATTR_RSA_COEFFICIENT,
+					obj, SKS_CKA_COEFFICIENT))
+			count++;
+
+		if (count == 8)
+			rv = SKS_OK;
+
+		break;
+
+	default:
+		assert(0);
+		break;
+	}
+
+	if (rv == SKS_OK) {
+		*tee_attrs = attrs;
+		*tee_count = count;
+	}
+
+	return rv;
+}
+
+static uint32_t tee2sks_rsa_attributes(struct sks_attrs_head **pub_head,
+					struct sks_attrs_head **priv_head,
+					TEE_ObjectHandle tee_obj)
+{
+	uint32_t rv;
+
+	rv = tee2sks_add_attribute(pub_head, SKS_CKA_MODULUS,
+				   tee_obj, TEE_ATTR_RSA_MODULUS);
+	if (rv)
+		goto bail;
+
+	if (get_attribute_ptr(*pub_head, SKS_CKA_PUBLIC_EXPONENT, NULL, NULL)) {
+		rv = tee2sks_add_attribute(pub_head,
+					   SKS_CKA_PUBLIC_EXPONENT,
+					   tee_obj,
+					   TEE_ATTR_RSA_PUBLIC_EXPONENT);
+		if (rv)
+			goto bail;
+	}
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_MODULUS,
+				   tee_obj, TEE_ATTR_RSA_MODULUS);
+	if (rv)
+		goto bail;
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_PUBLIC_EXPONENT,
+				   tee_obj, TEE_ATTR_RSA_PUBLIC_EXPONENT);
+	if (rv)
+		goto bail;
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_PRIVATE_EXPONENT,
+				   tee_obj, TEE_ATTR_RSA_PRIVATE_EXPONENT);
+	if (rv)
+		goto bail;
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_PRIME_1,
+				   tee_obj, TEE_ATTR_RSA_PRIME1);
+	if (rv)
+		goto bail;
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_PRIME_2,
+				   tee_obj, TEE_ATTR_RSA_PRIME2);
+	if (rv)
+		goto bail;
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_EXPONENT_1,
+				   tee_obj, TEE_ATTR_RSA_EXPONENT1);
+	if (rv)
+		goto bail;
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_EXPONENT_2,
+				   tee_obj, TEE_ATTR_RSA_EXPONENT2);
+	if (rv)
+		goto bail;
+
+	rv = tee2sks_add_attribute(priv_head, SKS_CKA_COEFFICIENT,
+				   tee_obj, TEE_ATTR_RSA_COEFFICIENT);
+bail:
+	return rv;
+}
+
+uint32_t generate_rsa_keys(struct sks_attribute_head *proc_params,
+			   struct sks_attrs_head **pub_head,
+			   struct sks_attrs_head **priv_head)
+{
+	uint32_t rv;
+	void *a_ptr;
+	size_t a_size;
+	TEE_ObjectHandle tee_obj;
+	TEE_Result res;
+	uint32_t tee_size;
+	TEE_Attribute tee_attrs[1];
+	uint32_t tee_count = 0;
+
+	if (!proc_params || !*pub_head || !*priv_head) {
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	if (get_attribute_ptr(*pub_head, SKS_CKA_MODULUS_BITS,
+				&a_ptr, &a_size)) {
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	if (a_size != sizeof(uint32_t)) {
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	TEE_MemMove(&tee_size, a_ptr, sizeof(uint32_t));
+
+	rv = get_attribute_ptr(*pub_head, SKS_CKA_PUBLIC_EXPONENT,
+				&a_ptr, &a_size);
+	if (rv == SKS_OK) {
+		TEE_InitRefAttribute(&tee_attrs[tee_count],
+				     TEE_ATTR_RSA_PUBLIC_EXPONENT,
+				     a_ptr, a_size);
+
+		tee_count++;
+	}
+
+	if (!get_attribute(*pub_head, SKS_CKA_MODULUS, NULL, NULL) ||
+	    !get_attribute(*priv_head, SKS_CKA_MODULUS, NULL, NULL) ||
+	    !get_attribute(*priv_head, SKS_CKA_PUBLIC_EXPONENT, NULL, NULL) ||
+	    !get_attribute(*priv_head, SKS_CKA_PRIVATE_EXPONENT, NULL, NULL) ||
+	    !get_attribute(*priv_head, SKS_CKA_PRIME_1, NULL, NULL) ||
+	    !get_attribute(*priv_head, SKS_CKA_PRIME_2, NULL, NULL) ||
+	    !get_attribute(*priv_head, SKS_CKA_EXPONENT_1, NULL, NULL) ||
+	    !get_attribute(*priv_head, SKS_CKA_EXPONENT_2, NULL, NULL) ||
+	    !get_attribute(*priv_head, SKS_CKA_COEFFICIENT, NULL, NULL)) {
+		EMSG("Unexpected attribute(s) found");
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+	}
+
+	/* Create an ECDSA TEE key: will match PKCS11 ECDSA and ECDH */
+	res = TEE_AllocateTransientObject(TEE_TYPE_RSA_KEYPAIR,
+					  tee_size, &tee_obj);
+	if (res) {
+		DMSG("TEE_AllocateTransientObject failed 0x%" PRIx32, res);
+		return tee2sks_error(res);
+	}
+
+	res = TEE_RestrictObjectUsage1(tee_obj, TEE_USAGE_EXTRACTABLE);
+	if (res) {
+		DMSG("TEE_RestrictObjectUsage1 failed 0x%" PRIx32, res);
+		rv = tee2sks_error(res);
+		goto bail;
+	}
+
+	res = TEE_GenerateKey(tee_obj, tee_size, &tee_attrs[0], tee_count);
+	if (res) {
+		DMSG("TEE_GenerateKey failed 0x%" PRIx32, res);
+		rv = tee2sks_error(res);
+		goto bail;
+	}
+
+	rv = tee2sks_rsa_attributes(pub_head, priv_head, tee_obj);
+
+bail:
+	if (tee_obj != TEE_HANDLE_NULL)
+		TEE_FreeTransientObject(tee_obj);
+
+	return rv;
+}
+
diff --git a/ta/secure_key_services/src/processing_symm.c b/ta/secure_key_services/src/processing_symm.c
new file mode 100644
index 00000000..71314a3c
--- /dev/null
+++ b/ta/secure_key_services/src/processing_symm.c
@@ -0,0 +1,627 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <assert.h>
+#include <sks_internal_abi.h>
+#include <sks_ta.h>
+#include <string.h>
+#include <tee_api_defines.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include <util.h>
+
+#include "attributes.h"
+#include "object.h"
+#include "pkcs11_token.h"
+#include "pkcs11_attributes.h"
+#include "processing.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+bool processing_is_tee_symm(uint32_t proc_id)
+{
+	switch (proc_id) {
+	/* Authentication */
+	case SKS_CKM_AES_CMAC_GENERAL:
+	case SKS_CKM_AES_CMAC:
+	case SKS_CKM_MD5_HMAC:
+	case SKS_CKM_SHA_1_HMAC:
+	case SKS_CKM_SHA224_HMAC:
+	case SKS_CKM_SHA256_HMAC:
+	case SKS_CKM_SHA384_HMAC:
+	case SKS_CKM_SHA512_HMAC:
+	case SKS_CKM_AES_XCBC_MAC:
+	/* Cipherering */
+	case SKS_CKM_AES_ECB:
+	case SKS_CKM_AES_CBC:
+	case SKS_CKM_AES_CBC_PAD:
+	case SKS_CKM_AES_CTS:
+	case SKS_CKM_AES_CTR:
+	case SKS_CKM_AES_CCM:
+	case SKS_CKM_AES_GCM:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static uint32_t sks2tee_algorithm(uint32_t *tee_id,
+			      struct sks_attribute_head *proc_params)
+{
+	static const uint32_t sks2tee_algo[][2] = {
+		/* AES flavors */
+		{ SKS_CKM_AES_ECB, TEE_ALG_AES_ECB_NOPAD },
+		{ SKS_CKM_AES_CBC, TEE_ALG_AES_CBC_NOPAD },
+		{ SKS_CKM_AES_CBC_PAD, TEE_ALG_AES_CBC_NOPAD }, // TODO
+		{ SKS_CKM_AES_CTR, TEE_ALG_AES_CTR },
+		{ SKS_CKM_AES_CTS, TEE_ALG_AES_CTS },
+		{ SKS_CKM_AES_CCM, TEE_ALG_AES_CCM },
+		{ SKS_CKM_AES_GCM, TEE_ALG_AES_GCM },
+		{ SKS_CKM_AES_CMAC, TEE_ALG_AES_CMAC },
+		{ SKS_CKM_AES_CMAC_GENERAL, TEE_ALG_AES_CMAC },
+		{ SKS_CKM_AES_XCBC_MAC, TEE_ALG_AES_CBC_MAC_NOPAD },
+		/* HMAC flavors */
+		{ SKS_CKM_MD5_HMAC, TEE_ALG_HMAC_MD5 },
+		{ SKS_CKM_SHA_1_HMAC, TEE_ALG_HMAC_SHA1 },
+		{ SKS_CKM_SHA224_HMAC, TEE_ALG_HMAC_SHA224 },
+		{ SKS_CKM_SHA256_HMAC, TEE_ALG_HMAC_SHA256 },
+		{ SKS_CKM_SHA384_HMAC, TEE_ALG_HMAC_SHA384 },
+		{ SKS_CKM_SHA512_HMAC, TEE_ALG_HMAC_SHA512 },
+	};
+	size_t end = sizeof(sks2tee_algo) / (2 * sizeof(uint32_t));
+	size_t n = 0;
+
+	for (n = 0; n < end; n++) {
+		if (proc_params->id == sks2tee_algo[n][0]) {
+			*tee_id = sks2tee_algo[n][1];
+			break;
+		}
+	}
+
+	if (n == end)
+		return SKS_NOT_IMPLEMENTED;
+
+	return SKS_OK;
+}
+
+static uint32_t sks2tee_key_type(uint32_t *tee_type,
+				  struct sks_attribute_head *proc_params,
+				  struct sks_object *obj)
+{
+	static const uint32_t sks2tee_key_type[][2] = {
+		{ SKS_CKK_AES, TEE_TYPE_AES },
+		{ SKS_CKK_GENERIC_SECRET, TEE_TYPE_GENERIC_SECRET },
+		{ SKS_CKK_MD5_HMAC, TEE_TYPE_HMAC_MD5 },
+		{ SKS_CKK_SHA_1_HMAC, TEE_TYPE_HMAC_SHA1 },
+		{ SKS_CKK_SHA224_HMAC, TEE_TYPE_HMAC_SHA224 },
+		{ SKS_CKK_SHA256_HMAC, TEE_TYPE_HMAC_SHA256 },
+		{ SKS_CKK_SHA384_HMAC, TEE_TYPE_HMAC_SHA384 },
+		{ SKS_CKK_SHA512_HMAC, TEE_TYPE_HMAC_SHA512 },
+	};
+	static const uint32_t sks_mech2tee_type[][2] = {
+		{ SKS_CKM_MD5_HMAC, TEE_TYPE_HMAC_MD5 },
+		{ SKS_CKM_SHA_1_HMAC, TEE_TYPE_HMAC_SHA1 },
+		{ SKS_CKM_SHA224_HMAC, TEE_TYPE_HMAC_SHA224 },
+		{ SKS_CKM_SHA256_HMAC, TEE_TYPE_HMAC_SHA256 },
+		{ SKS_CKM_SHA384_HMAC, TEE_TYPE_HMAC_SHA384 },
+		{ SKS_CKM_SHA512_HMAC, TEE_TYPE_HMAC_SHA512 },
+	};
+	size_t last = 0;
+	size_t n = 0;
+	uint32_t type = 0;
+	uint32_t key_type = 0;
+
+	assert(get_class(obj->attributes) == SKS_CKO_SECRET_KEY);
+
+	key_type = get_type(obj->attributes);
+	last = sizeof(sks2tee_key_type) / (2 * sizeof(uint32_t));
+	for (n = 0; n < last; n++) {
+		if (sks2tee_key_type[n][0] == key_type) {
+			type = sks2tee_key_type[n][1];
+			break;
+		}
+	}
+	if (n == last)
+		return SKS_NOT_FOUND;
+
+	/*
+	 * HMAC secret corresponds to the generic secret key type
+	 * or the mechanism specific key type. If generic, find the
+	 * corresponding TEE_TYPE based on the mechanism used.
+	 */
+	if (type == TEE_TYPE_GENERIC_SECRET) {
+		last = sizeof(sks_mech2tee_type) /
+				(2 * sizeof(uint32_t));
+		for (n = 0; n < last; n++) {
+			if (sks_mech2tee_type[n][0] == proc_params->id) {
+				type = sks_mech2tee_type[n][1];
+				break;
+			}
+		}
+	}
+
+	*tee_type = type;
+
+	return SKS_OK;
+}
+
+static uint32_t allocate_tee_operation(struct pkcs11_session *session,
+					enum processing_func function,
+					struct sks_attribute_head *proc_params,
+					struct sks_object *obj)
+{
+	uint32_t size = (uint32_t)get_object_key_bit_size(obj);
+	uint32_t algo = 0;
+	uint32_t mode = 0;
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	assert(session->processing->tee_op_handle == TEE_HANDLE_NULL);
+
+	if (sks2tee_algorithm(&algo, proc_params))
+		return SKS_FAILED;
+
+	/* Sign/Verify with AES or generic key relate to TEE MAC operation */
+	switch (proc_params->id) {
+	case SKS_CKM_AES_CMAC_GENERAL:
+	case SKS_CKM_AES_CMAC:
+	case SKS_CKM_MD5_HMAC:
+	case SKS_CKM_SHA_1_HMAC:
+	case SKS_CKM_SHA224_HMAC:
+	case SKS_CKM_SHA256_HMAC:
+	case SKS_CKM_SHA384_HMAC:
+	case SKS_CKM_SHA512_HMAC:
+	case SKS_CKM_AES_XCBC_MAC:
+		mode = TEE_MODE_MAC;
+		break;
+	default:
+		sks2tee_mode(&mode, function);
+		break;
+	}
+
+	res = TEE_AllocateOperation(&session->processing->tee_op_handle,
+				    algo, mode, size);
+	switch (res) {
+	case TEE_ERROR_NOT_SUPPORTED:
+		return SKS_CKR_MECHANISM_INVALID;
+	case TEE_SUCCESS:
+		break;
+	default:
+		EMSG("TEE_AllocateOp. failed %" PRIx32 " %" PRIx32 " %" PRIx32,
+			algo, mode, size);
+	}
+
+	return tee2sks_error(res);
+}
+
+static uint32_t load_tee_key(struct pkcs11_session *session,
+				struct sks_attribute_head *proc_params,
+				struct sks_object *obj)
+{
+	TEE_Attribute tee_attr;
+	size_t object_size = 0;
+	uint32_t key_type = 0;
+	uint32_t rv = 0;
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	TEE_MemFill(&tee_attr, 0, sizeof(tee_attr));
+
+	if (obj->key_handle != TEE_HANDLE_NULL) {
+		/* Key was already loaded and fits current need */
+		goto key_ready;
+	}
+
+	if (!sks2tee_load_attr(&tee_attr, TEE_ATTR_SECRET_VALUE,
+			       obj, SKS_CKA_VALUE)) {
+		EMSG("No secret found");
+		return SKS_FAILED;
+	}
+
+	rv = sks2tee_key_type(&key_type, proc_params, obj);
+	if (rv)
+		return rv;
+
+	object_size = get_object_key_bit_size(obj);
+	if (!object_size)
+		return SKS_ERROR;
+
+	res = TEE_AllocateTransientObject(key_type, object_size,
+					  &obj->key_handle);
+	if (res) {
+		DMSG("TEE_AllocateTransientObject failed, %" PRIx32, res);
+		return tee2sks_error(res);
+	}
+
+	res = TEE_PopulateTransientObject(obj->key_handle, &tee_attr, 1);
+	if (res) {
+		DMSG("TEE_PopulateTransientObject failed, %" PRIx32, res);
+		goto error;
+	}
+
+key_ready:
+	res = TEE_SetOperationKey(session->processing->tee_op_handle,
+				  obj->key_handle);
+	if (res) {
+		DMSG("TEE_SetOperationKey failed, %" PRIx32, res);
+		goto error;
+	}
+
+	return tee2sks_error(res);
+
+error:
+	TEE_FreeTransientObject(obj->key_handle);
+	obj->key_handle = TEE_HANDLE_NULL;
+
+	return tee2sks_error(res);
+}
+
+static uint32_t init_tee_operation(struct pkcs11_session *session,
+				   struct sks_attribute_head *proc_params)
+{
+	uint32_t rv = SKS_ERROR;
+
+	switch (proc_params->id) {
+	case SKS_CKM_AES_CMAC_GENERAL:
+	case SKS_CKM_AES_CMAC:
+	case SKS_CKM_MD5_HMAC:
+	case SKS_CKM_SHA_1_HMAC:
+	case SKS_CKM_SHA224_HMAC:
+	case SKS_CKM_SHA256_HMAC:
+	case SKS_CKM_SHA384_HMAC:
+	case SKS_CKM_SHA512_HMAC:
+	case SKS_CKM_AES_XCBC_MAC:
+		if (proc_params->size)
+			return SKS_CKR_MECHANISM_PARAM_INVALID;
+
+		TEE_MACInit(session->processing->tee_op_handle, NULL, 0);
+		rv = SKS_OK;
+		break;
+	case SKS_CKM_AES_ECB:
+		if (proc_params->size)
+			return SKS_CKR_MECHANISM_PARAM_INVALID;
+
+		TEE_CipherInit(session->processing->tee_op_handle, NULL, 0);
+		rv = SKS_OK;
+		break;
+	case SKS_CKM_AES_CBC:
+	case SKS_CKM_AES_CBC_PAD:
+	case SKS_CKM_AES_CTS:
+		if (proc_params->size != 16)
+			return SKS_CKR_MECHANISM_PARAM_INVALID;
+
+		TEE_CipherInit(session->processing->tee_op_handle,
+			       proc_params->data, 16);
+		rv = SKS_OK;
+		break;
+	case SKS_CKM_AES_CTR:
+		rv = tee_init_ctr_operation(session->processing,
+					    proc_params->data,
+					    proc_params->size);
+		break;
+	case SKS_CKM_AES_CCM:
+		rv = tee_init_ccm_operation(session->processing,
+					    proc_params->data,
+					    proc_params->size);
+		break;
+	case SKS_CKM_AES_GCM:
+		rv = tee_init_gcm_operation(session->processing,
+					    proc_params->data,
+					    proc_params->size);
+		break;
+	default:
+		TEE_Panic(proc_params->id);
+		break;
+	}
+
+	return rv;
+}
+
+uint32_t init_symm_operation(struct pkcs11_session *session,
+				enum processing_func function,
+				struct sks_attribute_head *proc_params,
+				struct sks_object *obj)
+{
+	uint32_t rv = 0;
+
+	assert(processing_is_tee_symm(proc_params->id));
+
+	rv = allocate_tee_operation(session, function, proc_params, obj);
+	if (rv)
+		return rv;
+
+	rv = load_tee_key(session, proc_params, obj);
+	if (rv)
+		return rv;
+
+	return init_tee_operation(session, proc_params);
+}
+
+/*
+ * step_sym_cipher - processing symmetric (and related) cipher operation step
+ *
+ * @session - current session
+ * @function
+ * @step - step ID in the processing (oneshot, update,final)
+ * @in - input data reference #1
+ * @io2 - input or output data reference #2, depending on function/step.
+ */
+uint32_t step_symm_operation(struct pkcs11_session *session,
+			     enum processing_func function,
+			     enum processing_step step,
+			     TEE_Param *in, TEE_Param *io2)
+{
+	uint32_t rv = SKS_ERROR;
+	TEE_Result res = TEE_ERROR_GENERIC;
+	void *in_buf = in ? in->memref.buffer : NULL;
+	size_t in_size = in ? in->memref.size : 0;
+	void *out_buf = io2 ? io2->memref.buffer : NULL;
+	uint32_t out_size = io2 ? io2->memref.size : 0;
+	uint32_t out_size2 = out_size;
+	void *in2_buf = io2 ? io2->memref.buffer : NULL;
+	uint32_t in2_size = io2 ? io2->memref.size : 0;
+	bool output_data = false;
+	struct active_processing *proc = session->processing;
+
+	switch (step) {
+	case SKS_FUNC_STEP_ONESHOT:
+	case SKS_FUNC_STEP_UPDATE:
+	case SKS_FUNC_STEP_FINAL:
+		break;
+	default:
+		return SKS_ERROR;
+	}
+
+	/* Validate input buffer size */
+	switch (proc->mecha_type) {
+	case SKS_CKM_AES_ECB:
+	case SKS_CKM_AES_CBC:
+		switch (function) {
+		case SKS_FUNCTION_ENCRYPT:
+			if ((in_size % 16) != 0)
+				return SKS_CKR_DATA_LEN_RANGE;
+			break;
+		case SKS_FUNCTION_DECRYPT:
+			if ((in_size % 16) != 0)
+				return SKS_CKR_ENCRYPTED_DATA_LEN_RANGE;
+			break;
+		default:
+			break;
+		}
+		break;
+	case SKS_CKM_AES_CBC_PAD:
+		switch (function) {
+		case SKS_FUNCTION_DECRYPT:
+			if ((in_size % 16) != 0)
+				return SKS_CKR_ENCRYPTED_DATA_LEN_RANGE;
+			break;
+		default:
+			break;
+		}
+		break;
+	case SKS_CKM_AES_CTS:
+		switch (function) {
+		case SKS_FUNCTION_ENCRYPT:
+			if (in_size < 16)
+				return SKS_CKR_DATA_LEN_RANGE;
+			break;
+		case SKS_FUNCTION_DECRYPT:
+			if (in_size < 16)
+				return SKS_CKR_ENCRYPTED_DATA_LEN_RANGE;
+			break;
+		default:
+			break;
+		}
+	default:
+		break;
+	}
+
+	/*
+	 * Feed active operation with with data
+	 * (SKS_FUNC_STEP_UPDATE/_ONESHOT)
+	 */
+	switch (proc->mecha_type) {
+	case SKS_CKM_AES_CMAC_GENERAL:
+	case SKS_CKM_AES_CMAC:
+	case SKS_CKM_MD5_HMAC:
+	case SKS_CKM_SHA_1_HMAC:
+	case SKS_CKM_SHA224_HMAC:
+	case SKS_CKM_SHA256_HMAC:
+	case SKS_CKM_SHA384_HMAC:
+	case SKS_CKM_SHA512_HMAC:
+	case SKS_CKM_AES_XCBC_MAC:
+		if (step == SKS_FUNC_STEP_FINAL)
+			break;
+
+		if (!in) {
+			DMSG("No input data");
+			return SKS_BAD_PARAM;
+		}
+
+		switch (function) {
+		case SKS_FUNCTION_SIGN:
+		case SKS_FUNCTION_VERIFY:
+			TEE_MACUpdate(proc->tee_op_handle, in_buf, in_size);
+			rv = SKS_OK;
+			break;
+		default:
+			TEE_Panic(function);
+			break;
+		}
+		break;
+
+	case SKS_CKM_AES_ECB:
+	case SKS_CKM_AES_CBC:
+	case SKS_CKM_AES_CBC_PAD:
+	case SKS_CKM_AES_CTS:
+	case SKS_CKM_AES_CTR:
+		if (step == SKS_FUNC_STEP_FINAL ||
+		    step == SKS_FUNC_STEP_ONESHOT)
+			break;
+
+		if (!in) {
+			DMSG("No input data");
+			return SKS_BAD_PARAM;
+		}
+
+		switch (function) {
+		case SKS_FUNCTION_ENCRYPT:
+		case SKS_FUNCTION_DECRYPT:
+			res = TEE_CipherUpdate(proc->tee_op_handle,
+						in_buf, in_size,
+						out_buf, &out_size);
+			output_data = true;
+			rv = tee2sks_error(res);
+			break;
+		default:
+			TEE_Panic(function);
+			break;
+		}
+		break;
+
+	case SKS_CKM_AES_CCM:
+	case SKS_CKM_AES_GCM:
+		if (step == SKS_FUNC_STEP_FINAL)
+			break;
+
+		if (!in) {
+			DMSG("No input data");
+			return SKS_BAD_PARAM;
+		}
+
+		switch (function) {
+		case SKS_FUNCTION_ENCRYPT:
+			res = TEE_AEUpdate(proc->tee_op_handle,
+					   in_buf, in_size, out_buf, &out_size);
+			output_data = true;
+			rv = tee2sks_error(res);
+
+			if (step == SKS_FUNC_STEP_ONESHOT &&
+			    (rv == SKS_OK || rv == SKS_SHORT_BUFFER)) {
+				out_buf = (char *)out_buf + out_size;
+				out_size2 -= out_size;
+			}
+			break;
+		case SKS_FUNCTION_DECRYPT:
+			rv = tee_ae_decrypt_update(proc, in_buf, in_size);
+			out_size = 0;
+			output_data = true;
+			break;
+		default:
+			TEE_Panic(function);
+			break;
+		}
+		break;
+	default:
+		TEE_Panic(proc->mecha_type);
+		break;
+	}
+
+	if (step == SKS_FUNC_STEP_UPDATE)
+		goto bail;
+
+	/*
+	 * Finalize (SKS_FUNC_STEP_ONESHOT/_FINAL) operation
+	 */
+	switch (session->processing->mecha_type) {
+	case SKS_CKM_AES_CMAC_GENERAL:
+	case SKS_CKM_AES_CMAC:
+	case SKS_CKM_MD5_HMAC:
+	case SKS_CKM_SHA_1_HMAC:
+	case SKS_CKM_SHA224_HMAC:
+	case SKS_CKM_SHA256_HMAC:
+	case SKS_CKM_SHA384_HMAC:
+	case SKS_CKM_SHA512_HMAC:
+	case SKS_CKM_AES_XCBC_MAC:
+		switch (function) {
+		case SKS_FUNCTION_SIGN:
+			res = TEE_MACComputeFinal(proc->tee_op_handle,
+						  NULL, 0, out_buf, &out_size);
+			output_data = true;
+			rv = tee2sks_error(res);
+			break;
+		case SKS_FUNCTION_VERIFY:
+			res = TEE_MACCompareFinal(proc->tee_op_handle,
+						  NULL, 0, in2_buf, in2_size);
+			rv = tee2sks_error(res);
+			break;
+		default:
+			TEE_Panic(function);
+			break;
+		}
+		break;
+
+	case SKS_CKM_AES_ECB:
+	case SKS_CKM_AES_CBC:
+	case SKS_CKM_AES_CBC_PAD:
+	case SKS_CKM_AES_CTS:
+	case SKS_CKM_AES_CTR:
+		if (step == SKS_FUNC_STEP_ONESHOT && !in) {
+			DMSG("No input data");
+			return SKS_BAD_PARAM;
+		}
+		switch (function) {
+		case SKS_FUNCTION_ENCRYPT:
+		case SKS_FUNCTION_DECRYPT:
+			res = TEE_CipherDoFinal(proc->tee_op_handle,
+						in_buf, in_size,
+						out_buf, &out_size);
+			output_data = true;
+			rv = tee2sks_error(res);
+			break;
+		default:
+			TEE_Panic(function);
+			break;
+		}
+		break;
+
+	case SKS_CKM_AES_CCM:
+	case SKS_CKM_AES_GCM:
+		switch (function) {
+		case SKS_FUNCTION_ENCRYPT:
+			rv = tee_ae_encrypt_final(proc, out_buf, &out_size2);
+			output_data = true;
+
+			/*
+			 * FIXME: on failure & ONESHOT, restore operation state
+			 * before TEE_AEUpdate() was called
+			 */
+			if (step == SKS_FUNC_STEP_ONESHOT) {
+				out_size += out_size2;
+			} else {
+				out_size = out_size2;
+			}
+			break;
+		case SKS_FUNCTION_DECRYPT:
+			rv = tee_ae_decrypt_final(proc, out_buf, &out_size);
+			output_data = true;
+			break;
+		default:
+			TEE_Panic(function);
+			break;
+		}
+		break;
+	default:
+		TEE_Panic(proc->mecha_type);
+		break;
+	}
+
+bail:
+	if (output_data && (rv == SKS_OK || rv == SKS_SHORT_BUFFER)) {
+		if (io2)
+			io2->memref.size = out_size;
+		else
+			rv = SKS_BAD_PARAM;
+	}
+
+	return rv;
+}
+
+uint32_t do_symm_derivation(struct pkcs11_session *session __unused,
+			     struct sks_attribute_head *proc_params __unused,
+			     struct sks_object *parent_key __unused,
+			     struct sks_attrs_head **head __unused)
+{
+	EMSG("Symm key derivation not yet supported");
+	return SKS_ERROR;
+}
diff --git a/ta/secure_key_services/src/sanitize_object.c b/ta/secure_key_services/src/sanitize_object.c
new file mode 100644
index 00000000..cd08a6df
--- /dev/null
+++ b/ta/secure_key_services/src/sanitize_object.c
@@ -0,0 +1,474 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#include <sks_internal_abi.h>
+#include <sks_ta.h>
+#include <stdlib.h>
+#include <string.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include <trace.h>
+
+#include "attributes.h"
+#include "sanitize_object.h"
+#include "serializer.h"
+#include "sks_helpers.h"
+
+/*
+ * Functions to generate a serialized object.
+ * References are pointers to struct serializer.
+ */
+#define SKS_ID(sks)			case sks:
+
+bool sanitize_consistent_class_and_type(struct sks_attrs_head *attrs)
+{
+	uint32_t class = get_class(attrs);
+	uint32_t type = get_type(attrs);
+
+	switch (class) {
+	case SKS_CKO_DATA:
+		return true;
+	case SKS_CKO_SECRET_KEY:
+		return key_type_is_symm_key(type);
+	case SKS_CKO_MECHANISM:
+		return mechanism_is_valid(type);
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+		return key_type_is_asymm_key(type);
+	case SKS_CKO_CERTIFICATE:
+		return certificate_is_valid(type);
+	case SKS_CKO_OTP_KEY:
+	case SKS_CKO_DOMAIN_PARAMETERS:
+	case SKS_CKO_HW_FEATURE:
+	default:
+		return false;
+	}
+
+	return false;
+}
+
+/* Sanitize class/type in a client attribute list */
+static uint32_t sanitize_class_and_type(struct sks_attrs_head **dst,
+				     void *src)
+{
+	struct sks_object_head head;
+	char *cur = NULL;
+	char *end = NULL;
+	size_t len = 0;
+	uint32_t class_found = 0;
+	uint32_t type_found = 0;
+	struct sks_attribute_head cli_ref;
+	uint32_t rc = SKS_OK;
+	size_t src_size = 0;
+
+	TEE_MemMove(&head, src, sizeof(head));
+	TEE_MemFill(&cli_ref, 0, sizeof(cli_ref));
+
+	src_size = sizeof(struct sks_object_head) + head.attrs_size;
+
+	class_found = SKS_UNDEFINED_ID;
+	type_found = SKS_UNDEFINED_ID;
+
+	cur = (char *)src + sizeof(struct sks_object_head);
+	end = cur + head.attrs_size;
+
+	for (; cur < end; cur += len) {
+		/* Structure aligned copy of client reference in the object */
+		TEE_MemMove(&cli_ref, cur, sizeof(cli_ref));
+		len = sizeof(cli_ref) + cli_ref.size;
+
+		if (sks_attr_is_class(cli_ref.id)) {
+			uint32_t class;
+
+			if (cli_ref.size != sks_attr_is_class(cli_ref.id)) {
+				rc = SKS_CKR_TEMPLATE_INCONSISTENT;
+				goto bail;
+			}
+
+			TEE_MemMove(&class, cur + sizeof(cli_ref), cli_ref.size);
+
+			if (class_found != SKS_UNDEFINED_ID &&
+			    class_found != class) {
+				EMSG("Conflicting class value");
+				rc = SKS_CKR_TEMPLATE_INCONSISTENT;
+				goto bail;
+			}
+
+			class_found = class;
+			continue;
+		}
+
+		/* The attribute is a type-in-class */
+		if (sks_attr_is_type(cli_ref.id)) {
+			uint32_t type = 0;
+
+			if (cli_ref.size != sks_attr_is_type(cli_ref.id)) {
+				rc = SKS_CKR_TEMPLATE_INCONSISTENT;
+				goto bail;
+			}
+
+			TEE_MemMove(&type, cur + sizeof(cli_ref), cli_ref.size);
+
+			if (type_found != SKS_UNDEFINED_ID &&
+			    type_found != type) {
+				EMSG("Conflicting type-in-class value");
+				rc = SKS_CKR_TEMPLATE_INCONSISTENT;
+				goto bail;
+			}
+
+			type_found = type;
+		}
+	}
+
+	/* Sanity */
+	if (cur != end) {
+		EMSG("Unexpected alignment issue");
+		rc = SKS_FAILED;
+		goto bail;
+	}
+
+	if (class_found != SKS_UNDEFINED_ID) {
+		rc = add_attribute(dst, SKS_CKA_CLASS,
+				   &class_found, sizeof(uint32_t));
+		if (rc)
+			goto bail;
+	}
+
+	if (type_found != SKS_UNDEFINED_ID) {
+		rc = add_attribute(dst, SKS_CKA_KEY_TYPE,
+				   &type_found, sizeof(uint32_t));
+	}
+
+bail:
+	if (rc)
+		trace_attributes_from_api_head("bad-template", src, src_size);
+
+	return rc;
+}
+
+static uint32_t sanitize_boolprop(struct sks_attrs_head **dst,
+				struct sks_attribute_head *cli_ref,
+				char *cur, uint32_t *boolprop_base,
+				uint32_t *sanity)
+{
+	int shift = 0;
+	uint32_t mask = 0;
+	uint32_t value = 0;
+	uint32_t *boolprop_ptr = NULL;
+	uint32_t *sanity_ptr = NULL;
+
+	/* Get the booloean property shift position and value */
+	shift = sks_attr2boolprop_shift(cli_ref->id);
+	if (shift < 0)
+		return SKS_NOT_FOUND;
+
+	if (shift >= SKS_MAX_BOOLPROP_SHIFT)
+		return SKS_FAILED;
+
+	mask = 1 << (shift % 32);
+	if ((*(uint8_t *)(cur + sizeof(*cli_ref))) == SKS_TRUE)
+		value = mask;
+	else
+		value = 0;
+
+	/* Locate the current config value for the boolean property */
+	boolprop_ptr = boolprop_base + (shift / 32);
+	sanity_ptr = sanity + (shift / 32);
+
+	/* Error if already set to a different boolean value */
+	if (*sanity_ptr & mask && value != (*boolprop_ptr & mask))
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+
+	if (value)
+		*boolprop_ptr |= mask;
+	else
+		*boolprop_ptr &= ~mask;
+
+	/* Store the attribute inside the serialized data */
+	if (!(*sanity_ptr & mask)) {
+		uint32_t rc = 0;
+		uint8_t sks_bool = !!value;
+
+		rc = add_attribute(dst, SKS_BOOLPROPS_BASE + shift,
+				   &sks_bool, sizeof(uint8_t));
+		if (rc)
+			return rc;
+	}
+
+	*sanity_ptr |= mask;
+
+	return SKS_OK;
+}
+
+static uint32_t sanitize_boolprops(struct sks_attrs_head **dst, void *src)
+{
+	struct sks_object_head head;
+	char *cur = NULL;
+	char *end = NULL;
+	size_t len = 0;
+	struct sks_attribute_head cli_ref;
+	uint32_t sanity[SKS_MAX_BOOLPROP_ARRAY] = { 0 };
+	uint32_t boolprops[SKS_MAX_BOOLPROP_ARRAY] = { 0 };
+	uint32_t rc = 0;
+
+	TEE_MemMove(&head, src, sizeof(head));
+	TEE_MemFill(&cli_ref, 0, sizeof(cli_ref));
+
+	cur = (char *)src + sizeof(struct sks_object_head);
+	end = cur + head.attrs_size;
+
+	for (; cur < end; cur += len) {
+		/* Structure aligned copy of the cli_ref in the object */
+		TEE_MemMove(&cli_ref, cur, sizeof(cli_ref));
+		len = sizeof(cli_ref) + cli_ref.size;
+
+		rc = sanitize_boolprop(dst, &cli_ref, cur, boolprops, sanity);
+		if (rc != SKS_OK && rc != SKS_NOT_FOUND)
+			return rc;
+	}
+
+	return SKS_OK;
+}
+
+/* Counterpart of serialize_indirect_attribute() */
+static uint32_t sanitize_indirect_attr(struct sks_attrs_head **dst,
+					struct sks_attribute_head *cli_ref,
+					char *cur)
+{
+	struct sks_attrs_head *obj2 = NULL;
+	uint32_t rc = 0;
+	uint32_t class = get_class(*dst);
+
+	if (class == SKS_UNDEFINED_ID)
+		return SKS_NOT_FOUND;
+
+	/*
+	 * Serialized attributes: current applicable only the key templates which
+	 * are tables of attributes.
+	 */
+	switch (cli_ref->id) {
+	case SKS_CKA_WRAP_TEMPLATE:
+	case SKS_CKA_UNWRAP_TEMPLATE:
+	case SKS_CKA_DERIVE_TEMPLATE:
+		break;
+	default:
+		return SKS_NOT_FOUND;
+	}
+	/* Such attributes are expected only for keys (and vendor defined) */
+	if (sks_attr_class_is_key(class))
+		return SKS_CKR_TEMPLATE_INCONSISTENT;
+
+	init_attributes_head(&obj2);
+
+	/* Build a new serial object while sanitizing the attributes list */
+	rc = sanitize_client_object(&obj2, cur + sizeof(*cli_ref),
+				    cli_ref->size);
+	if (rc)
+		return rc;
+
+	return add_attribute(dst, cli_ref->id, obj2,
+			     sizeof(struct sks_attrs_head) + obj2->attrs_size);
+}
+
+uint32_t sanitize_client_object(struct sks_attrs_head **dst,
+				void *src, size_t size)
+{
+	struct sks_object_head head;
+	uint32_t rc = 0;
+	char *cur = NULL;
+	char *end = NULL;
+	size_t next = 0;
+
+	TEE_MemFill(&head, 0, sizeof(head));
+
+	if (size < sizeof(struct sks_object_head))
+		return SKS_BAD_PARAM;
+
+	TEE_MemMove(&head, src, sizeof(struct sks_object_head));
+
+	if (size < (sizeof(struct sks_object_head) + head.attrs_size))
+		return SKS_BAD_PARAM;
+
+	init_attributes_head(dst);
+
+	rc = sanitize_class_and_type(dst, src);
+	if (rc)
+		goto bail;
+
+	rc = sanitize_boolprops(dst, src);
+	if (rc)
+		goto bail;
+
+	cur = (char *)src + sizeof(struct sks_object_head);
+	end = cur + head.attrs_size;
+
+	for (; cur < end; cur += next) {
+		struct sks_attribute_head cli_ref;
+
+		TEE_MemMove(&cli_ref, cur, sizeof(cli_ref));
+		next = sizeof(cli_ref) + cli_ref.size;
+
+		if (sks_attr_is_class(cli_ref.id) ||
+		    sks_attr_is_type(cli_ref.id) ||
+		    sks_attr2boolprop_shift(cli_ref.id) >= 0)
+			continue;
+
+		rc = sanitize_indirect_attr(dst, &cli_ref, cur);
+		if (rc == SKS_OK)
+			continue;
+		if (rc != SKS_NOT_FOUND)
+			goto bail;
+
+		if (!valid_sks_attribute_id(cli_ref.id, cli_ref.size)) {
+			EMSG("Invalid attribute id 0x%" PRIx32, cli_ref.id);
+			rc = SKS_CKR_TEMPLATE_INCONSISTENT;
+			goto bail;
+		}
+
+		rc = add_attribute(dst, cli_ref.id, cur + sizeof(cli_ref),
+				   cli_ref.size);
+		if (rc)
+			goto bail;
+	}
+
+	/* sanity */
+	if (cur != end) {
+		EMSG("Unexpected alignment inssue");
+		rc = SKS_FAILED;
+		goto bail;
+	}
+
+bail:
+	return rc;
+}
+
+/*
+ * Debug: dump object attribute array to output trace
+ */
+
+static uint32_t __trace_attributes(char *prefix, void *src, void *end)
+{
+	size_t next = 0;
+	char *prefix2 = NULL;
+	size_t prefix_len = strlen(prefix);
+	char *cur = src;
+	uint32_t rc = 0;
+
+	/* append 4 spaces to the prefix plus terminal '\0' */
+	prefix2 = TEE_Malloc(prefix_len + 1 + 4, TEE_MALLOC_FILL_ZERO);
+	if (!prefix2)
+		return SKS_MEMORY;
+
+	TEE_MemMove(prefix2, prefix, prefix_len + 1);
+	TEE_MemFill(prefix2 + prefix_len, ' ', 4);
+	*(prefix2 + prefix_len + 4) = '\0';
+
+	for (; cur < (char *)end; cur += next) {
+		struct sks_ref sks_ref;
+		uint8_t data[4] = { 0 };
+		uint32_t data_u32 = 0;
+
+		TEE_MemMove(&sks_ref, cur, sizeof(sks_ref));
+		TEE_MemMove(&data[0], cur + sizeof(sks_ref),
+			    MIN(sks_ref.size, sizeof(data)));
+		TEE_MemMove(&data_u32, cur + sizeof(sks_ref), sizeof(data_u32));
+
+		next = sizeof(sks_ref) + sks_ref.size;
+
+		IMSG_RAW("%s Attr %s / %s (0x%04" PRIx32 " %" PRIu32 "-byte)",
+			prefix, sks2str_attr(sks_ref.id),
+			sks2str_attr_value(sks_ref.id, sks_ref.size,
+					   cur + sizeof(sks_ref)),
+			sks_ref.id, sks_ref.size);
+
+		switch (sks_ref.size) {
+		case 0:
+			break;
+		case 1:
+			DMSG_RAW("%s Attr byte value: %02x", prefix, data[0]);
+			break;
+		case 2:
+			DMSG_RAW("%s Attr byte value: %02x %02x",
+				 prefix, data[0], data[1]);
+			break;
+		case 3:
+			DMSG_RAW("%s Attr byte value: %02x %02x %02x",
+				 prefix, data[0], data[1], data[2]);
+			break;
+		case 4:
+			DMSG_RAW("%s Attr byte value: %02x %02x %02x %02x",
+				 prefix, data[0], data[1], data[2], data[3]);
+			break;
+		default:
+			DMSG_RAW("%s Attr byte value: %02x %02x %02x %02x ...",
+				 prefix, data[0], data[1], data[2], data[3]);
+			break;
+		}
+
+		switch (sks_ref.id) {
+		case SKS_CKA_WRAP_TEMPLATE:
+		case SKS_CKA_UNWRAP_TEMPLATE:
+		case SKS_CKA_DERIVE_TEMPLATE:
+			rc = trace_attributes_from_api_head(prefix2,
+							cur + sizeof(sks_ref),
+							(char *)end - cur);
+			if (rc)
+				return rc;
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* Sanity */
+	if (cur != (char *)end) {
+		EMSG("Warning: unexpected alignment issue");
+	}
+
+	TEE_Free(prefix2);
+	return SKS_OK;
+}
+
+uint32_t trace_attributes_from_api_head(const char *prefix,
+					void *ref, size_t size)
+{
+	struct sks_object_head head;
+	char *pre = NULL;
+	size_t offset = 0;
+	uint32_t rc = 0;
+
+	TEE_MemMove(&head, ref, sizeof(head));
+
+	if (size > sizeof(head) + head.attrs_size) {
+		EMSG("template overflows client buffer (%lu/%lu)",
+			size, sizeof(head) + head.attrs_size);
+		return SKS_FAILED;
+	}
+
+
+	pre = TEE_Malloc(prefix ? strlen(prefix) + 2 : 2, TEE_MALLOC_FILL_ZERO);
+	if (!pre)
+		return SKS_MEMORY;
+	if (prefix)
+		TEE_MemMove(pre, prefix, strlen(prefix));
+
+	IMSG_RAW("%s,--- (serial object) Attributes list --------", pre);
+	IMSG_RAW("%s| %" PRIx32 " item(s) - %" PRIu32 " bytes",
+		pre, head.attrs_count, head.attrs_size);
+
+	offset = sizeof(head);
+	pre[prefix ? strlen(prefix) : 0] = '|';
+	rc = __trace_attributes(pre, (char *)ref + offset,
+			      (char *)ref + offset + head.attrs_size);
+	if (rc)
+		goto bail;
+
+	IMSG_RAW("%s`-----------------------", prefix ? prefix : "");
+
+bail:
+	TEE_Free(pre);
+	return rc;
+}
diff --git a/ta/secure_key_services/src/sanitize_object.h b/ta/secure_key_services/src/sanitize_object.h
new file mode 100644
index 00000000..76e6dfa4
--- /dev/null
+++ b/ta/secure_key_services/src/sanitize_object.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef __SERIAL_SANITIZE_H
+#define __SERIAL_SANITIZE_H
+
+#include "serializer.h"
+
+/*
+ * sanitize_consistent_class_and_type - Check object type matches object class
+ *
+ * @attrs - object attributes
+ * Return true if class/type matches, else return false
+ */
+bool sanitize_consistent_class_and_type(struct sks_attrs_head *attrs);
+
+/**
+ * sanitize_client_object - Setup a serializer from a serialized object
+ *
+ * @dst - output structure tracking the generated serial object
+ * @head - pointer to the formated serialized object (its head)
+ * @size - byte size of the serialized binary blob
+ *
+ * This function copies an attribute list from a client API attribute head
+ * into a SKS internal attribute structure. It generates a serialized attribute
+ * list with a consistent format and identifed attribute IDs.
+ *
+ * ref points to a blob starting with a sks head.
+ * ref may pointer to an unaligned address.
+ * This function allocates, fill and returns a serialized attribute list
+ * into a serializer container.
+ */
+uint32_t sanitize_client_object(struct sks_attrs_head **dst,
+				void *head, size_t size);
+
+/* Debug: dump attribute content as debug traces */
+uint32_t trace_attributes_from_api_head(const char *prefix,
+					void *ref, size_t size);
+
+#endif /*__SERIAL_SANITIZE_H*/
+
diff --git a/ta/secure_key_services/src/serializer.c b/ta/secure_key_services/src/serializer.c
new file mode 100644
index 00000000..b2a8dc3d
--- /dev/null
+++ b/ta/secure_key_services/src/serializer.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <sks_internal_abi.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <string_ext.h>
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include <trace.h>
+
+#include "serializer.h"
+#include "sks_helpers.h"
+
+/*
+ * Util routines for serializes unformatted arguments in a client memref
+ */
+void serialargs_init(struct serialargs *args, void *in, size_t size)
+{
+	args->start = in;
+	args->next = in;
+	args->size = size;
+}
+
+uint32_t serialargs_get(struct serialargs *args, void *out, size_t size)
+{
+	if (args->next + size > args->start + args->size) {
+		EMSG("arg too short: full %zd, remain %zd, expect %zd",
+		     args->size, args->size - (args->next - args->start), size);
+		return SKS_BAD_PARAM;
+	}
+
+	TEE_MemMove(out, args->next, size);
+
+	args->next += size;
+
+	return SKS_OK;
+}
+
+uint32_t serialargs_alloc_and_get(struct serialargs *args,
+				  void **out, size_t size)
+{
+	void *ptr = NULL;
+
+	if (!size) {
+		*out = NULL;
+		return SKS_OK;
+	}
+
+	if (args->next + size > args->start + args->size) {
+		EMSG("arg too short: full %zd, remain %zd, expect %zd",
+		     args->size, args->size - (args->next - args->start), size);
+		return SKS_BAD_PARAM;
+	}
+
+	ptr = TEE_Malloc(size, TEE_MALLOC_FILL_ZERO);
+	if (!ptr)
+		return SKS_MEMORY;
+
+	TEE_MemMove(ptr, args->next, size);
+
+	args->next += size;
+	*out = ptr;
+
+	return SKS_OK;
+}
+
+uint32_t serialargs_get_ptr(struct serialargs *args, void **out, size_t size)
+{
+	void *ptr = args->next;
+
+	if (!size) {
+		*out = NULL;
+		return SKS_OK;
+	}
+
+	if (args->next + size > args->start + args->size) {
+		EMSG("arg too short: full %zd, remain %zd, expect %zd",
+		     args->size, args->size - (args->next - args->start), size);
+		return SKS_BAD_PARAM;
+	}
+
+	args->next += size;
+	*out = ptr;
+
+	return SKS_OK;
+}
+
+uint32_t serialargs_alloc_get_one_attribute(struct serialargs *args __unused,
+					    struct sks_attribute_head **out __unused)
+{
+	struct sks_attribute_head head;
+	size_t out_size = sizeof(head);
+	void *pref = NULL;
+
+	TEE_MemFill(&head, 0, sizeof(head));
+
+	if (args->next + out_size > args->start + args->size) {
+		EMSG("arg too short: full %zd, remain %zd, expect at least %zd",
+		     args->size, args->size - (args->next - args->start),
+		     out_size);
+		return SKS_BAD_PARAM;
+	}
+
+	TEE_MemMove(&head, args->next, out_size);
+
+	out_size += head.size;
+	if (args->next + out_size > args->start + args->size) {
+		EMSG("arg too short: full %zd, remain %zd, expect %zd",
+		     args->size, args->size - (args->next - args->start),
+		     out_size);
+		return SKS_BAD_PARAM;
+	}
+
+	pref = TEE_Malloc(out_size, TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!pref)
+		return SKS_MEMORY;
+
+	TEE_MemMove(pref, args->next, out_size);
+	args->next += out_size;
+
+	*out = pref;
+
+	return SKS_OK;
+}
+
+uint32_t serialargs_alloc_get_attributes(struct serialargs *args __unused,
+					 struct sks_object_head **out __unused)
+{
+	struct sks_object_head attr;
+	struct sks_object_head *pattr = NULL;
+	size_t attr_size = sizeof(attr);
+
+	TEE_MemFill(&attr, 0, sizeof(attr));
+
+	if (args->next + attr_size > args->start + args->size) {
+		EMSG("arg too short: full %zd, remain %zd, expect at least %zd",
+		     args->size, args->size - (args->next - args->start),
+		     attr_size);
+		return SKS_BAD_PARAM;
+	}
+
+	TEE_MemMove(&attr, args->next, attr_size);
+
+	attr_size += attr.attrs_size;
+	if (args->next + attr_size > args->start + args->size) {
+		EMSG("arg too short: full %zd, remain %zd, expect %zd",
+		     args->size, args->size - (args->next - args->start),
+		     attr_size);
+		return SKS_BAD_PARAM;
+	}
+
+	pattr = TEE_Malloc(attr_size, TEE_USER_MEM_HINT_NO_FILL_ZERO);
+	if (!pattr)
+		return SKS_MEMORY;
+
+	TEE_MemMove(pattr, args->next, attr_size);
+	args->next += attr_size;
+
+	*out = pattr;
+
+	return SKS_OK;
+}
+
+/*
+ * serialize - serialize input data in buffer
+ *
+ * Serialize data in provided buffer.
+ * Insure 64byte alignement of appended data in the buffer.
+ */
+uint32_t serialize(char **bstart, size_t *blen, void *data, size_t len)
+{
+	char *buf = NULL;
+	size_t nlen = *blen + len;
+
+	buf = TEE_Realloc(*bstart, nlen);
+	if (!buf)
+		return SKS_MEMORY;
+
+	TEE_MemMove(buf + *blen, data, len);
+
+	*blen = nlen;
+	*bstart = buf;
+
+	return SKS_OK;
+}
diff --git a/ta/secure_key_services/src/serializer.h b/ta/secure_key_services/src/serializer.h
new file mode 100644
index 00000000..05b7c479
--- /dev/null
+++ b/ta/secure_key_services/src/serializer.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#ifndef __SERIALIZER_H__
+#define __SERIALIZER_H__
+
+#include <sks_internal_abi.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <tee_internal_api.h>
+
+/*
+ * Util routines for serializes unformated arguments in a client memref
+ */
+struct serialargs {
+	char *start;
+	char *next;
+	size_t size;
+};
+
+void serialargs_init(struct serialargs *args, void *in, size_t size);
+
+uint32_t serialargs_get(struct serialargs *args, void *out, size_t sz);
+
+uint32_t serialargs_get_ptr(struct serialargs *args, void **out, size_t size);
+
+uint32_t serialargs_alloc_get_one_attribute(struct serialargs *args,
+					    struct sks_attribute_head **out);
+
+uint32_t serialargs_alloc_get_attributes(struct serialargs *args,
+					 struct sks_object_head **out);
+
+uint32_t serialargs_alloc_and_get(struct serialargs *args,
+				   void **out, size_t size);
+
+#define SKS_MAX_BOOLPROP_SHIFT	64
+#define SKS_MAX_BOOLPROP_ARRAY	(SKS_MAX_BOOLPROP_SHIFT / sizeof(uint32_t))
+
+/**
+ * serialize - Append data into a serialized buffer
+ */
+uint32_t serialize(char **bstart, size_t *blen, void *data, size_t len);
+
+#endif /*__SERIALIZER_H*/
+
diff --git a/ta/secure_key_services/src/sks_helpers.c b/ta/secure_key_services/src/sks_helpers.c
new file mode 100644
index 00000000..eedb3b82
--- /dev/null
+++ b/ta/secure_key_services/src/sks_helpers.c
@@ -0,0 +1,889 @@
+// SPDX-License-Identifier: BSD-2-Clause
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#include <assert.h>
+#include <sks_internal_abi.h>
+#include <sks_ta.h>
+#include <string.h>
+#include <tee_internal_api.h>
+
+#include "attributes.h"
+#include "object.h"
+#include "pkcs11_attributes.h"
+#include "processing.h"
+#include "sks_helpers.h"
+
+static const char __maybe_unused unknown[] = "<unknown-identifier>";
+
+struct attr_size {
+	uint32_t id;
+	uint32_t size;
+#if CFG_TEE_TA_LOG_LEVEL > 0
+	const char *string;
+#endif
+};
+
+#if CFG_TEE_TA_LOG_LEVEL > 0
+#define SKS_ID_SZ(_id, _size)	{ .id = _id, .size = _size, .string = #_id }
+#else
+#define SKS_ID_SZ(_id, _size)	{ .id = _id, .size = _size }
+#endif
+
+static const struct attr_size attr_ids[] = {
+	SKS_ID_SZ(SKS_CKA_CLASS, 4),
+	SKS_ID_SZ(SKS_CKA_KEY_TYPE, 4),
+	SKS_ID_SZ(SKS_CKA_VALUE, 0),
+	SKS_ID_SZ(SKS_CKA_VALUE_LEN, 4),
+	SKS_ID_SZ(SKS_CKA_LABEL, 0),
+	SKS_ID_SZ(SKS_CKA_WRAP_TEMPLATE, 0),
+	SKS_ID_SZ(SKS_CKA_UNWRAP_TEMPLATE, 0),
+	SKS_ID_SZ(SKS_CKA_DERIVE_TEMPLATE, 0),
+	SKS_ID_SZ(SKS_CKA_START_DATE, 4),
+	SKS_ID_SZ(SKS_CKA_END_DATE, 4),
+	SKS_ID_SZ(SKS_CKA_OBJECT_ID, 0),
+	SKS_ID_SZ(SKS_CKA_APPLICATION, 0),
+	SKS_ID_SZ(SKS_CKA_MECHANISM_TYPE, 4),
+	SKS_ID_SZ(SKS_CKA_ID, 0),
+	SKS_ID_SZ(SKS_CKA_ALLOWED_MECHANISMS, 0),
+	SKS_ID_SZ(SKS_CKA_EC_POINT, 0),
+	SKS_ID_SZ(SKS_CKA_EC_PARAMS, 0),
+	SKS_ID_SZ(SKS_CKA_MODULUS, 0),
+	SKS_ID_SZ(SKS_CKA_MODULUS_BITS, 4),
+	SKS_ID_SZ(SKS_CKA_PUBLIC_EXPONENT, 0),
+	SKS_ID_SZ(SKS_CKA_PRIVATE_EXPONENT, 0),
+	SKS_ID_SZ(SKS_CKA_PRIME_1, 0),
+	SKS_ID_SZ(SKS_CKA_PRIME_2, 0),
+	SKS_ID_SZ(SKS_CKA_EXPONENT_1, 0),
+	SKS_ID_SZ(SKS_CKA_EXPONENT_2, 0),
+	SKS_ID_SZ(SKS_CKA_COEFFICIENT, 0),
+	SKS_ID_SZ(SKS_CKA_SUBJECT, 0),
+	SKS_ID_SZ(SKS_CKA_PUBLIC_KEY_INFO, 0),
+	SKS_ID_SZ(SKS_CKA_CERTIFICATE_TYPE, 4),
+	SKS_ID_SZ(SKS_CKA_CERTIFICATE_CATEGORY, 4),
+	SKS_ID_SZ(SKS_CKA_ISSUER, 0),
+	SKS_ID_SZ(SKS_CKA_SERIAL_NUMBER, 0),
+	SKS_ID_SZ(SKS_CKA_URL, 0),
+	SKS_ID_SZ(SKS_CKA_HASH_OF_SUBJECT_PUBLIC_KEY, 0),
+	SKS_ID_SZ(SKS_CKA_HASH_OF_ISSUER_PUBLIC_KEY, 0),
+	SKS_ID_SZ(SKS_CKA_NAME_HASH_ALGORITHM, 4),
+	SKS_ID_SZ(SKS_CKA_KEY_GEN_MECHANISM, 4),
+	/* Below are boolean attributes */
+	SKS_ID_SZ(SKS_CKA_TOKEN, 1),
+	SKS_ID_SZ(SKS_CKA_PRIVATE, 1),
+	SKS_ID_SZ(SKS_CKA_TRUSTED, 1),
+	SKS_ID_SZ(SKS_CKA_SENSITIVE, 1),
+	SKS_ID_SZ(SKS_CKA_ENCRYPT, 1),
+	SKS_ID_SZ(SKS_CKA_DECRYPT, 1),
+	SKS_ID_SZ(SKS_CKA_WRAP, 1),
+	SKS_ID_SZ(SKS_CKA_UNWRAP, 1),
+	SKS_ID_SZ(SKS_CKA_SIGN, 1),
+	SKS_ID_SZ(SKS_CKA_SIGN_RECOVER, 1),
+	SKS_ID_SZ(SKS_CKA_VERIFY, 1),
+	SKS_ID_SZ(SKS_CKA_VERIFY_RECOVER, 1),
+	SKS_ID_SZ(SKS_CKA_DERIVE, 1),
+	SKS_ID_SZ(SKS_CKA_EXTRACTABLE, 1),
+	SKS_ID_SZ(SKS_CKA_LOCAL, 1),
+	SKS_ID_SZ(SKS_CKA_NEVER_EXTRACTABLE, 1),
+	SKS_ID_SZ(SKS_CKA_ALWAYS_SENSITIVE, 1),
+	SKS_ID_SZ(SKS_CKA_MODIFIABLE, 1),
+	SKS_ID_SZ(SKS_CKA_COPYABLE, 1),
+	SKS_ID_SZ(SKS_CKA_DESTROYABLE, 1),
+	SKS_ID_SZ(SKS_CKA_ALWAYS_AUTHENTICATE, 1),
+	SKS_ID_SZ(SKS_CKA_WRAP_WITH_TRUSTED, 1),
+	/* Specific SKS attribute IDs */
+	SKS_ID_SZ(SKS_UNDEFINED_ID, 0),
+};
+
+struct processing_id {
+	uint32_t id;
+	bool supported;
+#if CFG_TEE_TA_LOG_LEVEL > 0
+	const char *string;
+#endif
+};
+
+#if CFG_TEE_TA_LOG_LEVEL > 0
+#define SKS_PROCESSING_ID(_id) \
+			{ .id = _id, .supported = true, .string = #_id }
+#define SKS_UNSUPPORTED_PROCESSING_ID(_id) \
+			{ .id = _id, .supported = false, .string = #_id }
+#else
+#define SKS_PROCESSING_ID(_id) \
+			{ .id = _id, .supported = true }
+#define SKS_UNSUPPORTED_PROCESSING_ID(_id) \
+			{ .id = _id, .supported = false }
+
+#endif
+
+static const struct processing_id __maybe_unused processing_ids[] = {
+	SKS_PROCESSING_ID(SKS_CKM_AES_ECB),
+	SKS_PROCESSING_ID(SKS_CKM_AES_CBC),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_AES_CBC_PAD),
+	SKS_PROCESSING_ID(SKS_CKM_AES_CTR),
+	SKS_PROCESSING_ID(SKS_CKM_AES_GCM),
+	SKS_PROCESSING_ID(SKS_CKM_AES_CCM),
+	SKS_PROCESSING_ID(SKS_CKM_AES_CTS),
+	SKS_PROCESSING_ID(SKS_CKM_AES_GMAC),
+	SKS_PROCESSING_ID(SKS_CKM_AES_CMAC),
+	SKS_PROCESSING_ID(SKS_CKM_AES_CMAC_GENERAL),
+	SKS_PROCESSING_ID(SKS_CKM_AES_ECB_ENCRYPT_DATA),
+	SKS_PROCESSING_ID(SKS_CKM_AES_CBC_ENCRYPT_DATA),
+	SKS_PROCESSING_ID(SKS_CKM_AES_KEY_GEN),
+	SKS_PROCESSING_ID(SKS_CKM_GENERIC_SECRET_KEY_GEN),
+	SKS_PROCESSING_ID(SKS_CKM_MD5_HMAC),
+	SKS_PROCESSING_ID(SKS_CKM_SHA_1_HMAC),
+	SKS_PROCESSING_ID(SKS_CKM_SHA224_HMAC),
+	SKS_PROCESSING_ID(SKS_CKM_SHA256_HMAC),
+	SKS_PROCESSING_ID(SKS_CKM_SHA384_HMAC),
+	SKS_PROCESSING_ID(SKS_CKM_SHA512_HMAC),
+	SKS_PROCESSING_ID(SKS_CKM_AES_XCBC_MAC),
+	SKS_PROCESSING_ID(SKS_CKM_EC_KEY_PAIR_GEN),
+	SKS_PROCESSING_ID(SKS_CKM_ECDSA),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECDSA_SHA1),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECDSA_SHA224),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECDSA_SHA256),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECDSA_SHA384),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECDSA_SHA512),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECDH1_DERIVE),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECDH1_COFACTOR_DERIVE),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECMQV_DERIVE),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_ECDH_AES_KEY_WRAP),
+	SKS_PROCESSING_ID(SKS_CKM_RSA_PKCS_KEY_PAIR_GEN),
+	SKS_PROCESSING_ID(SKS_CKM_RSA_PKCS),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_RSA_9796),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_RSA_X_509),
+	SKS_PROCESSING_ID(SKS_CKM_SHA1_RSA_PKCS),
+	SKS_PROCESSING_ID(SKS_CKM_RSA_PKCS_OAEP),
+	SKS_PROCESSING_ID(SKS_CKM_SHA1_RSA_PKCS_PSS),
+	SKS_PROCESSING_ID(SKS_CKM_SHA256_RSA_PKCS),
+	SKS_PROCESSING_ID(SKS_CKM_SHA384_RSA_PKCS),
+	SKS_PROCESSING_ID(SKS_CKM_SHA512_RSA_PKCS),
+	SKS_PROCESSING_ID(SKS_CKM_SHA256_RSA_PKCS_PSS),
+	SKS_PROCESSING_ID(SKS_CKM_SHA384_RSA_PKCS_PSS),
+	SKS_PROCESSING_ID(SKS_CKM_SHA512_RSA_PKCS_PSS),
+	SKS_PROCESSING_ID(SKS_CKM_SHA224_RSA_PKCS),
+	SKS_PROCESSING_ID(SKS_CKM_SHA224_RSA_PKCS_PSS),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_RSA_AES_KEY_WRAP),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_MD5),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_SHA_1),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_SHA224),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_SHA256),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_SHA384),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_CKM_SHA512),
+	SKS_UNSUPPORTED_PROCESSING_ID(SKS_UNDEFINED_ID)
+};
+
+struct string_id {
+	uint32_t id;
+#if CFG_TEE_TA_LOG_LEVEL > 0
+	const char *string;
+#endif
+};
+
+#if CFG_TEE_TA_LOG_LEVEL > 0
+#define SKS_ID(_id)		{ .id = _id, .string = #_id }
+#else
+#define SKS_ID(_id)		{ .id = _id }
+#endif
+
+static const struct string_id __maybe_unused string_cmd[] = {
+	SKS_ID(SKS_CMD_PING),
+	SKS_ID(SKS_CMD_CK_SLOT_LIST),
+	SKS_ID(SKS_CMD_CK_SLOT_INFO),
+	SKS_ID(SKS_CMD_CK_TOKEN_INFO),
+	SKS_ID(SKS_CMD_CK_MECHANISM_IDS),
+	SKS_ID(SKS_CMD_CK_MECHANISM_INFO),
+	SKS_ID(SKS_CMD_CK_INIT_TOKEN),
+	SKS_ID(SKS_CMD_CK_INIT_PIN),
+	SKS_ID(SKS_CMD_CK_SET_PIN),
+	SKS_ID(SKS_CMD_CK_OPEN_RO_SESSION),
+	SKS_ID(SKS_CMD_CK_OPEN_RW_SESSION),
+	SKS_ID(SKS_CMD_CK_CLOSE_SESSION),
+	SKS_ID(SKS_CMD_CK_SESSION_INFO),
+	SKS_ID(SKS_CMD_CK_CLOSE_ALL_SESSIONS),
+	SKS_ID(SKS_CMD_IMPORT_OBJECT),
+	SKS_ID(SKS_CMD_DESTROY_OBJECT),
+	SKS_ID(SKS_CMD_ENCRYPT_INIT),
+	SKS_ID(SKS_CMD_DECRYPT_INIT),
+	SKS_ID(SKS_CMD_ENCRYPT_UPDATE),
+	SKS_ID(SKS_CMD_DECRYPT_UPDATE),
+	SKS_ID(SKS_CMD_ENCRYPT_FINAL),
+	SKS_ID(SKS_CMD_DECRYPT_FINAL),
+	SKS_ID(SKS_CMD_GENERATE_SYMM_KEY),
+	SKS_ID(SKS_CMD_SIGN_INIT),
+	SKS_ID(SKS_CMD_VERIFY_INIT),
+	SKS_ID(SKS_CMD_SIGN_UPDATE),
+	SKS_ID(SKS_CMD_VERIFY_UPDATE),
+	SKS_ID(SKS_CMD_SIGN_FINAL),
+	SKS_ID(SKS_CMD_VERIFY_FINAL),
+	SKS_ID(SKS_CMD_FIND_OBJECTS_INIT),
+	SKS_ID(SKS_CMD_FIND_OBJECTS),
+	SKS_ID(SKS_CMD_FIND_OBJECTS_FINAL),
+	SKS_ID(SKS_CMD_GET_OBJECT_SIZE),
+	SKS_ID(SKS_CMD_GET_ATTRIBUTE_VALUE),
+	SKS_ID(SKS_CMD_SET_ATTRIBUTE_VALUE),
+	SKS_ID(SKS_CMD_DERIVE_KEY),
+	SKS_ID(SKS_CMD_INIT_PIN),
+	SKS_ID(SKS_CMD_SET_PIN),
+	SKS_ID(SKS_CMD_LOGIN),
+	SKS_ID(SKS_CMD_LOGOUT),
+	SKS_ID(SKS_CMD_GENERATE_KEY_PAIR),
+	SKS_ID(SKS_CMD_ENCRYPT_ONESHOT),
+	SKS_ID(SKS_CMD_DECRYPT_ONESHOT),
+	SKS_ID(SKS_CMD_SIGN_ONESHOT),
+	SKS_ID(SKS_CMD_VERIFY_ONESHOT),
+};
+
+static const struct string_id __maybe_unused string_rc[] = {
+	SKS_ID(SKS_CKR_OK),
+	SKS_ID(SKS_CKR_GENERAL_ERROR),
+	SKS_ID(SKS_CKR_DEVICE_MEMORY),
+	SKS_ID(SKS_CKR_ARGUMENTS_BAD),
+	SKS_ID(SKS_CKR_BUFFER_TOO_SMALL),
+	SKS_ID(SKS_CKR_FUNCTION_FAILED),
+	SKS_ID(SKS_CKR_SIGNATURE_INVALID),
+	SKS_ID(SKS_CKR_ATTRIBUTE_TYPE_INVALID),
+	SKS_ID(SKS_CKR_ATTRIBUTE_VALUE_INVALID),
+	SKS_ID(SKS_CKR_OBJECT_HANDLE_INVALID),
+	SKS_ID(SKS_CKR_KEY_HANDLE_INVALID),
+	SKS_ID(SKS_CKR_MECHANISM_INVALID),
+	SKS_ID(SKS_CKR_SESSION_HANDLE_INVALID),
+	SKS_ID(SKS_CKR_SLOT_ID_INVALID),
+	SKS_ID(SKS_CKR_MECHANISM_PARAM_INVALID),
+	SKS_ID(SKS_CKR_TEMPLATE_INCONSISTENT),
+	SKS_ID(SKS_CKR_TEMPLATE_INCOMPLETE),
+	SKS_ID(SKS_CKR_PIN_INCORRECT),
+	SKS_ID(SKS_CKR_PIN_LOCKED),
+	SKS_ID(SKS_CKR_PIN_EXPIRED),
+	SKS_ID(SKS_CKR_PIN_INVALID),
+	SKS_ID(SKS_CKR_PIN_LEN_RANGE),
+	SKS_ID(SKS_CKR_SESSION_EXISTS),
+	SKS_ID(SKS_CKR_SESSION_READ_ONLY),
+	SKS_ID(SKS_CKR_SESSION_READ_WRITE_SO_EXISTS),
+	SKS_ID(SKS_CKR_OPERATION_ACTIVE),
+	SKS_ID(SKS_CKR_KEY_TYPE_INCONSISTENT),
+	SKS_ID(SKS_CKR_KEY_FUNCTION_NOT_PERMITTED),
+	SKS_ID(SKS_CKR_OPERATION_NOT_INITIALIZED),
+	SKS_ID(SKS_CKR_TOKEN_WRITE_PROTECTED),
+	SKS_ID(SKS_CKR_TOKEN_NOT_PRESENT),
+	SKS_ID(SKS_CKR_TOKEN_NOT_RECOGNIZED),
+	SKS_ID(SKS_CKR_ACTION_PROHIBITED),
+	SKS_ID(SKS_CKR_ATTRIBUTE_READ_ONLY),
+	SKS_ID(SKS_CKR_PIN_TOO_WEAK),
+	SKS_ID(SKS_CKR_CURVE_NOT_SUPPORTED),
+	SKS_ID(SKS_CKR_DOMAIN_PARAMS_INVALID),
+	SKS_ID(SKS_CKR_USER_ALREADY_LOGGED_IN),
+	SKS_ID(SKS_CKR_USER_ANOTHER_ALREADY_LOGGED_IN),
+	SKS_ID(SKS_CKR_USER_NOT_LOGGED_IN),
+	SKS_ID(SKS_CKR_USER_PIN_NOT_INITIALIZED),
+	SKS_ID(SKS_CKR_USER_TOO_MANY_TYPES),
+	SKS_ID(SKS_CKR_USER_TYPE_INVALID),
+	SKS_ID(SKS_CKR_SESSION_READ_ONLY_EXISTS),
+	SKS_ID(SKS_CKR_KEY_SIZE_RANGE),
+	SKS_ID(SKS_CKR_ATTRIBUTE_SENSITIVE),
+	SKS_ID(SKS_CKR_SIGNATURE_LEN_RANGE),
+	SKS_ID(SKS_CKR_DATA_LEN_RANGE),
+	SKS_ID(SKS_CKR_ENCRYPTED_DATA_LEN_RANGE),
+	SKS_ID(SKS_NOT_FOUND),
+	SKS_ID(SKS_NOT_IMPLEMENTED),
+};
+
+static const struct string_id __maybe_unused string_slot_flags[] = {
+	SKS_ID(SKS_CKFS_TOKEN_PRESENT),
+	SKS_ID(SKS_CKFS_REMOVABLE_DEVICE),
+	SKS_ID(SKS_CKFS_HW_SLOT),
+};
+
+static const struct string_id __maybe_unused string_token_flags[] = {
+	SKS_ID(SKS_CKFT_RNG),
+	SKS_ID(SKS_CKFT_WRITE_PROTECTED),
+	SKS_ID(SKS_CKFT_LOGIN_REQUIRED),
+	SKS_ID(SKS_CKFT_USER_PIN_INITIALIZED),
+	SKS_ID(SKS_CKFT_RESTORE_KEY_NOT_NEEDED),
+	SKS_ID(SKS_CKFT_CLOCK_ON_TOKEN),
+	SKS_ID(SKS_CKFT_PROTECTED_AUTHENTICATION_PATH),
+	SKS_ID(SKS_CKFT_DUAL_CRYPTO_OPERATIONS),
+	SKS_ID(SKS_CKFT_TOKEN_INITIALIZED),
+	SKS_ID(SKS_CKFT_USER_PIN_COUNT_LOW),
+	SKS_ID(SKS_CKFT_USER_PIN_FINAL_TRY),
+	SKS_ID(SKS_CKFT_USER_PIN_LOCKED),
+	SKS_ID(SKS_CKFT_USER_PIN_TO_BE_CHANGED),
+	SKS_ID(SKS_CKFT_SO_PIN_COUNT_LOW),
+	SKS_ID(SKS_CKFT_SO_PIN_FINAL_TRY),
+	SKS_ID(SKS_CKFT_SO_PIN_LOCKED),
+	SKS_ID(SKS_CKFT_SO_PIN_TO_BE_CHANGED),
+	SKS_ID(SKS_CKFT_ERROR_STATE),
+};
+
+static const struct string_id __maybe_unused string_class[] = {
+	SKS_ID(SKS_CKO_SECRET_KEY),
+	SKS_ID(SKS_CKO_PUBLIC_KEY),
+	SKS_ID(SKS_CKO_PRIVATE_KEY),
+	SKS_ID(SKS_CKO_OTP_KEY),
+	SKS_ID(SKS_CKO_CERTIFICATE),
+	SKS_ID(SKS_CKO_DATA),
+	SKS_ID(SKS_CKO_DOMAIN_PARAMETERS),
+	SKS_ID(SKS_CKO_HW_FEATURE),
+	SKS_ID(SKS_CKO_MECHANISM),
+	SKS_ID(SKS_UNDEFINED_ID)
+};
+
+static const struct string_id __maybe_unused string_key_type[] = {
+	SKS_ID(SKS_CKK_AES),
+	SKS_ID(SKS_CKK_GENERIC_SECRET),
+	SKS_ID(SKS_CKK_MD5_HMAC),
+	SKS_ID(SKS_CKK_SHA_1_HMAC),
+	SKS_ID(SKS_CKK_SHA224_HMAC),
+	SKS_ID(SKS_CKK_SHA256_HMAC),
+	SKS_ID(SKS_CKK_SHA384_HMAC),
+	SKS_ID(SKS_CKK_SHA512_HMAC),
+	SKS_ID(SKS_CKK_EC),
+	SKS_ID(SKS_CKK_RSA),
+	SKS_ID(SKS_UNDEFINED_ID)
+};
+
+static const struct string_id __maybe_unused string_certificate_type[] = {
+	SKS_ID(SKS_CKC_X_509),
+	SKS_ID(SKS_CKC_X_509_ATTR_CER),
+	SKS_ID(SKS_CKC_WTLS),
+	SKS_ID(SKS_UNDEFINED_ID)
+};
+
+/* Processing IDs not exported in the TA API */
+static const struct string_id __maybe_unused string_internal_processing[] = {
+	SKS_ID(SKS_PROCESSING_IMPORT),
+	SKS_ID(SKS_PROCESSING_COPY),
+};
+
+static const struct string_id __maybe_unused string_proc_flags[] = {
+	SKS_ID(SKS_CKFM_HW),
+	SKS_ID(SKS_CKFM_ENCRYPT),
+	SKS_ID(SKS_CKFM_DECRYPT),
+	SKS_ID(SKS_CKFM_DIGEST),
+	SKS_ID(SKS_CKFM_SIGN),
+	SKS_ID(SKS_CKFM_SIGN_RECOVER),
+	SKS_ID(SKS_CKFM_VERIFY),
+	SKS_ID(SKS_CKFM_VERIFY_RECOVER),
+	SKS_ID(SKS_CKFM_GENERATE),
+	SKS_ID(SKS_CKFM_GENERATE_PAIR),
+	SKS_ID(SKS_CKFM_WRAP),
+	SKS_ID(SKS_CKFM_UNWRAP),
+	SKS_ID(SKS_CKFM_DERIVE),
+	SKS_ID(SKS_CKFM_EC_F_P),
+	SKS_ID(SKS_CKFM_EC_F_2M),
+	SKS_ID(SKS_CKFM_EC_ECPARAMETERS),
+	SKS_ID(SKS_CKFM_EC_NAMEDCURVE),
+	SKS_ID(SKS_CKFM_EC_UNCOMPRESS),
+	SKS_ID(SKS_CKFM_EC_COMPRESS),
+};
+
+static const struct string_id __maybe_unused string_functions[] = {
+	SKS_ID(SKS_FUNCTION_ENCRYPT),
+	SKS_ID(SKS_FUNCTION_DECRYPT),
+	SKS_ID(SKS_FUNCTION_SIGN),
+	SKS_ID(SKS_FUNCTION_VERIFY),
+	SKS_ID(SKS_FUNCTION_DERIVE),
+};
+
+/*
+ * Helper functions to analyse SKS identifiers
+ */
+
+size_t sks_attr_is_class(uint32_t attribute_id)
+{
+	if (attribute_id == SKS_CKA_CLASS)
+		return sizeof(uint32_t);
+	else
+		return 0;
+}
+
+size_t sks_attr_is_type(uint32_t attribute_id)
+{
+	switch (attribute_id) {
+	case SKS_CKA_CERTIFICATE_TYPE:
+	case SKS_CKA_KEY_TYPE:
+	case SKS_CKA_MECHANISM_TYPE:
+	case SKS_CKA_KEY_GEN_MECHANISM:
+		return sizeof(uint32_t);
+	default:
+		return 0;
+	}
+}
+
+bool sks_class_has_type(uint32_t class)
+{
+	switch (class) {
+	case SKS_CKO_CERTIFICATE:
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_MECHANISM:
+	case SKS_CKO_HW_FEATURE:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+bool sks_attr_class_is_key(uint32_t class)
+{
+	switch (class) {
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/* Returns shift position or -1 on error */
+int sks_attr2boolprop_shift(uint32_t attr)
+{
+	COMPILE_TIME_ASSERT(SKS_BOOLPROPS_BASE == 0);
+
+	if (attr > SKS_BOOLPROPS_LAST)
+		return -1;
+
+	return attr;
+}
+
+/*
+ * Conversion between SKS and GPD TEE return codes
+ */
+
+TEE_Result sks2tee_error(uint32_t rv)
+{
+	switch (rv) {
+	case SKS_CKR_OK:
+		return TEE_SUCCESS;
+
+	case SKS_CKR_ARGUMENTS_BAD:
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	case SKS_CKR_DEVICE_MEMORY:
+		return TEE_ERROR_OUT_OF_MEMORY;
+
+	case SKS_CKR_BUFFER_TOO_SMALL:
+		return TEE_ERROR_SHORT_BUFFER;
+
+	default:
+		return TEE_ERROR_GENERIC;
+	}
+}
+
+TEE_Result sks2tee_noerr(uint32_t rc)
+{
+	switch (rc) {
+	case SKS_CKR_ARGUMENTS_BAD:
+		return TEE_ERROR_BAD_PARAMETERS;
+
+	case SKS_CKR_DEVICE_MEMORY:
+		return TEE_ERROR_OUT_OF_MEMORY;
+
+	case SKS_CKR_BUFFER_TOO_SMALL:
+		return TEE_ERROR_SHORT_BUFFER;
+
+	case SKS_CKR_GENERAL_ERROR:
+		return TEE_ERROR_GENERIC;
+
+	default:
+		return TEE_SUCCESS;
+	}
+}
+
+uint32_t tee2sks_error(TEE_Result res)
+{
+	switch (res) {
+	case TEE_SUCCESS:
+		return SKS_CKR_OK;
+
+	case TEE_ERROR_BAD_PARAMETERS:
+		return SKS_CKR_ARGUMENTS_BAD;
+
+	case TEE_ERROR_OUT_OF_MEMORY:
+		return SKS_CKR_DEVICE_MEMORY;
+
+	case TEE_ERROR_SHORT_BUFFER:
+		return SKS_CKR_BUFFER_TOO_SMALL;
+
+	case TEE_ERROR_MAC_INVALID:
+		return SKS_CKR_SIGNATURE_INVALID;
+
+	case TEE_ERROR_SIGNATURE_INVALID:
+		return SKS_CKR_SIGNATURE_INVALID;
+
+	default:
+		return SKS_CKR_GENERAL_ERROR;
+	}
+}
+
+bool valid_sks_attribute_id(uint32_t id, uint32_t size)
+{
+	size_t n = 0;
+
+	for (n = 0; n < ARRAY_SIZE(attr_ids); n++) {
+		if (id != attr_ids[n].id)
+			continue;
+
+		/* Check size matches if provided */
+		return !attr_ids[n].size || size == attr_ids[n].size;
+	}
+
+	return false;
+}
+
+bool key_type_is_symm_key(uint32_t id)
+{
+	switch (id) {
+	case SKS_CKK_AES:
+	case SKS_CKK_GENERIC_SECRET:
+	case SKS_CKK_MD5_HMAC:
+	case SKS_CKK_SHA_1_HMAC:
+	case SKS_CKK_SHA224_HMAC:
+	case SKS_CKK_SHA256_HMAC:
+	case SKS_CKK_SHA384_HMAC:
+	case SKS_CKK_SHA512_HMAC:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool key_type_is_asymm_key(uint32_t id)
+{
+	switch (id) {
+	case SKS_CKK_EC:
+	case SKS_CKK_RSA:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool certificate_is_valid(uint32_t id)
+{
+	switch (id) {
+	case SKS_CKC_X_509:
+	case SKS_CKC_X_509_ATTR_CER:
+	case SKS_CKC_WTLS:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool mechanism_is_valid(uint32_t id)
+{
+	size_t n = 0;
+
+	for (n = 0; n < ARRAY_SIZE(processing_ids); n++)
+		if (id == processing_ids[n].id)
+			return true;
+
+	return false;
+}
+
+bool mechanism_is_supported(uint32_t id)
+{
+	size_t n = 0;
+
+	for (n = 0; n < ARRAY_SIZE(processing_ids); n++) {
+		if (processing_ids[n].id == id)
+			return processing_ids[n].supported;
+	}
+
+	return false;
+}
+
+size_t get_supported_mechanisms(uint32_t *array, size_t array_count)
+{
+	size_t n = 0;
+	size_t m = 0;
+	size_t count = 0;
+
+	for (n = 0; n < ARRAY_SIZE(processing_ids); n++) {
+		if (processing_ids[n].supported)
+			count++;
+	}
+
+	if (array_count == 0)
+		return count;
+
+	if (array_count < count) {
+		EMSG("Expect well sized array");
+		return 0;
+	}
+
+	for (n = 0, m = 0; n < ARRAY_SIZE(processing_ids); n++) {
+		if (processing_ids[n].supported) {
+			array[m] = processing_ids[n].id;
+			m++;
+		}
+	}
+
+	assert(m == count);
+
+	return m;
+}
+
+/* Initialize a TEE attribute for a target SKS attribute in an object */
+bool sks2tee_load_attr(TEE_Attribute *tee_ref, uint32_t tee_id,
+			struct sks_object *obj, uint32_t sks_id)
+{
+	void *a_ptr = NULL;
+	size_t a_size = 0;
+	uint32_t data32 = 0;
+
+	switch (tee_id) {
+	case TEE_ATTR_ECC_PUBLIC_VALUE_X:
+	case TEE_ATTR_ECC_PUBLIC_VALUE_Y:
+	case TEE_ATTR_ECC_CURVE:
+		if (get_attribute_ptr(obj->attributes, SKS_CKA_EC_PARAMS,
+					&a_ptr, &a_size)) {
+			EMSG("Missing EC_PARAMS attribute");
+			return false;
+		}
+
+		if (tee_id == TEE_ATTR_ECC_CURVE) {
+			data32 = ec_params2tee_curve(a_ptr, a_size);
+			TEE_InitValueAttribute(tee_ref, TEE_ATTR_ECC_CURVE,
+					data32, 0);
+			return true;
+		}
+
+		data32 = (ec_params2tee_keysize(a_ptr, a_size) + 7) / 8;
+
+		if (get_attribute_ptr(obj->attributes, SKS_CKA_EC_POINT,
+					&a_ptr, &a_size)) {
+			/*
+			 * Public X/Y is required for both TEE keypair and
+			 * public key, so abort if EC_POINT is not provided
+			 * during object import.
+			 */
+			EMSG("Missing EC_POINT attribute");
+			return false;
+		}
+
+		/* TODO: Support DER long definitive form */
+		if (a_size >= 0x80) {
+			EMSG("DER long definitive form not yet supported");
+			return false;
+		}
+		if (((char *)a_ptr)[2] != 0x04) {
+			EMSG("Unsupported EC_POINT form");
+			return false;
+		}
+		if (a_size != 2 + 2 * data32 + 1) {
+			EMSG("Invalid EC_POINT attribute");
+			return false;
+		}
+
+		if (tee_id == TEE_ATTR_ECC_PUBLIC_VALUE_X)
+			TEE_InitRefAttribute(tee_ref, tee_id,
+					(uint8_t *)a_ptr + 3, data32);
+		else
+			TEE_InitRefAttribute(tee_ref, tee_id,
+					(uint8_t *)a_ptr + 3 + data32, data32);
+
+		return true;
+
+	default:
+		break;
+	}
+
+	if (get_attribute_ptr(obj->attributes, sks_id, &a_ptr, &a_size))
+		return false;
+
+	TEE_InitRefAttribute(tee_ref, tee_id, a_ptr, a_size);
+
+	return true;
+}
+
+/* Easy conversion between SKS function of TEE crypto mode */
+void sks2tee_mode(uint32_t *tee_id, uint32_t function)
+{
+	switch (function) {
+	case SKS_FUNCTION_ENCRYPT:
+		*tee_id = TEE_MODE_ENCRYPT;
+		break;
+	case SKS_FUNCTION_DECRYPT:
+		*tee_id = TEE_MODE_DECRYPT;
+		break;
+	case SKS_FUNCTION_SIGN:
+		*tee_id = TEE_MODE_SIGN;
+		break;
+	case SKS_FUNCTION_VERIFY:
+		*tee_id = TEE_MODE_VERIFY;
+		break;
+	case SKS_FUNCTION_DERIVE:
+		*tee_id = TEE_MODE_DERIVE;
+		break;
+	default:
+		TEE_Panic(function);
+	}
+}
+
+#if CFG_TEE_TA_LOG_LEVEL > 0
+/*
+ * Convert a SKS ID into its label string
+ */
+const char *sks2str_attr(uint32_t id)
+{
+	size_t n = 0;
+
+	for (n = 0; n < ARRAY_SIZE(attr_ids); n++) {
+		if (id != attr_ids[n].id)
+			continue;
+
+		/* Skip SKS_ prefix */
+		return (char *)attr_ids[n].string + strlen("SKS_CKA_");
+	}
+
+	return unknown;
+}
+
+static const char *sks2str_mechanism_type(uint32_t id)
+{
+	size_t n = 0;
+
+	for (n = 0; n < ARRAY_SIZE(processing_ids); n++) {
+		if (id != processing_ids[n].id)
+			continue;
+
+		/* Skip SKS_ prefix */
+		return (char *)processing_ids[n].string + strlen("SKS_CKM_");
+	}
+
+	return unknown;
+}
+
+static const char *id2str(uint32_t id, const struct string_id *table,
+			  size_t count, const char *prefix)
+{
+	size_t n = 0;
+	const char *str = NULL;
+
+	for (n = 0; n < count; n++) {
+		if (id != table[n].id)
+			continue;
+
+		str = table[n].string;
+
+		/* Skip prefix provided matches found */
+		if (prefix && !TEE_MemCompare(str, prefix, strlen(prefix)))
+			str += strlen(prefix);
+
+		return str;
+	}
+
+	return unknown;
+}
+
+#define ID2STR(id, table, prefix)	\
+	id2str(id, table, ARRAY_SIZE(table), prefix)
+
+const char *sks2str_class(uint32_t id)
+{
+	return ID2STR(id, string_class, "SKS_CKO_");
+}
+
+const char *sks2str_type(uint32_t id, uint32_t class)
+{
+	switch (class) {
+	case SKS_CKO_SECRET_KEY:
+	case SKS_CKO_PUBLIC_KEY:
+	case SKS_CKO_PRIVATE_KEY:
+		return sks2str_key_type(id);
+	default:
+		return unknown;
+	}
+}
+const char *sks2str_key_type(uint32_t id)
+{
+	return ID2STR(id, string_key_type, "SKS_CKK_");
+}
+
+const char *sks2str_certificate_type(uint32_t id)
+{
+	return ID2STR(id, string_certificate_type, "SKS_CKC_");
+}
+
+const char *sks2str_boolprop(uint32_t id)
+{
+	if (id < 64)
+		return sks2str_attr(id);
+
+	return unknown;
+}
+
+const char *sks2str_proc(uint32_t id)
+{
+	const char *str = ID2STR(id, string_internal_processing,
+				 "SKS_PROCESSING_");
+
+	if (str != unknown)
+		return str;
+
+	return sks2str_mechanism_type(id);
+}
+
+const char *sks2str_proc_flag(uint32_t id)
+{
+	return ID2STR(id, string_proc_flags, "SKS_CKFM_");
+}
+
+const char *sks2str_rc(uint32_t id)
+{
+	return ID2STR(id, string_rc, "SKS_CKR_");
+}
+
+const char *sks2str_skscmd(uint32_t id)
+{
+	return ID2STR(id, string_cmd, NULL);
+}
+
+const char *sks2str_slot_flag(uint32_t id)
+{
+	return ID2STR(id, string_slot_flags, "SKS_CKFS_");
+}
+
+const char *sks2str_token_flag(uint32_t id)
+{
+	return ID2STR(id, string_token_flags, "SKS_CKFT_");
+}
+
+const char *sks2str_attr_value(uint32_t id, size_t size, void *value)
+{
+	static const char str_true[] = "TRUE";
+	static const char str_false[] = "FALSE";
+	static const char str_unkwon[] = "*";
+	uint32_t type = 0;
+
+	if (sks_attr2boolprop_shift(id) >= 0)
+		return !!*(uint8_t *)value ? str_true : str_false;
+
+	if (size < sizeof(uint32_t))
+		return str_unkwon;
+
+	TEE_MemMove(&type, value, sizeof(uint32_t));
+
+	if (sks_attr_is_class(id))
+		return sks2str_class(type);
+
+	if (id == SKS_CKA_KEY_TYPE)
+		return sks2str_key_type(type);
+
+	if (id == SKS_CKA_MECHANISM_TYPE)
+		return sks2str_mechanism_type(type);
+
+	return str_unkwon;
+}
+
+const char *sks2str_function(uint32_t id)
+{
+	return ID2STR(id, string_functions, "SKS_FUNCTION_");
+}
+#endif /*CFG_TEE_TA_LOG_LEVEL*/
diff --git a/ta/secure_key_services/src/sks_helpers.h b/ta/secure_key_services/src/sks_helpers.h
new file mode 100644
index 00000000..4420a989
--- /dev/null
+++ b/ta/secure_key_services/src/sks_helpers.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#ifndef __SKS_HELPERS_H
+#define __SKS_HELPERS_H
+
+#include <sks_ta.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <tee_internal_api.h>
+
+/* Short aliases for return code */
+#define SKS_OK				SKS_CKR_OK
+#define SKS_ERROR			SKS_CKR_GENERAL_ERROR
+#define SKS_MEMORY			SKS_CKR_DEVICE_MEMORY
+#define SKS_BAD_PARAM			SKS_CKR_ARGUMENTS_BAD
+#define SKS_SHORT_BUFFER		SKS_CKR_BUFFER_TOO_SMALL
+#define SKS_FAILED			SKS_CKR_FUNCTION_FAILED
+
+struct sks_object;
+
+/*
+ * Helper functions to analyse CK fields
+ */
+bool valid_sks_attribute_id(uint32_t id, uint32_t size);
+
+size_t sks_attr_is_class(uint32_t attribute_id);
+size_t sks_attr_is_type(uint32_t attribute_id);
+bool sks_class_has_boolprop(uint32_t class);
+bool sks_class_has_type(uint32_t class);
+bool sks_attr_class_is_key(uint32_t class);
+int sks_attr2boolprop_shift(uint32_t attr);
+
+bool key_type_is_symm_key(uint32_t id);
+bool key_type_is_asymm_key(uint32_t id);
+bool certificate_is_valid(uint32_t id);
+bool mechanism_is_valid(uint32_t id);
+size_t get_supported_mechanisms(uint32_t *array, size_t array_count);
+bool mechanism_is_supported(uint32_t id);
+
+void sks2tee_mode(uint32_t *tee_id, uint32_t function);
+bool sks2tee_load_attr(TEE_Attribute *tee_ref, uint32_t tee_id,
+			struct sks_object *obj, uint32_t sks_id);
+
+/*
+ * Convert SKS retrun code into a GPD TEE result ID when matching.
+ * If not, return a TEE success (_noerr) or generic error (_error).
+ */
+TEE_Result sks2tee_noerr(uint32_t rv);
+TEE_Result sks2tee_error(uint32_t rv);
+uint32_t tee2sks_error(TEE_Result res);
+
+/* Id-to-string conversions when CFG_TEE_TA_LOG_LEVEL > 0 */
+const char *sks2str_attr(uint32_t id);
+const char *sks2str_class(uint32_t id);
+const char *sks2str_type(uint32_t id, uint32_t class);
+const char *sks2str_key_type(uint32_t id);
+const char *sks2str_certificate_type(uint32_t id);
+const char *sks2str_boolprop(uint32_t id);
+const char *sks2str_proc(uint32_t id);
+const char *sks2str_proc_flag(uint32_t id);
+const char *sks2str_slot_flag(uint32_t id);
+const char *sks2str_token_flag(uint32_t id);
+const char *sks2str_rc(uint32_t id);
+const char *sks2str_skscmd(uint32_t id);
+const char *sks2str_attr_value(uint32_t id, size_t size, void *value);
+const char *sks2str_function(uint32_t id);
+
+#endif /*__CK_HELPERS_H*/
diff --git a/ta/secure_key_services/src/sub.mk b/ta/secure_key_services/src/sub.mk
new file mode 100644
index 00000000..a89e8c99
--- /dev/null
+++ b/ta/secure_key_services/src/sub.mk
@@ -0,0 +1,16 @@
+srcs-y += entry.c
+srcs-y += sks_helpers.c
+srcs-y += handle.c
+srcs-y += pkcs11_token.c
+srcs-y += persistent_token.c
+srcs-y += serializer.c
+srcs-y += sanitize_object.c
+srcs-y += object.c
+srcs-y += processing.c
+srcs-y += processing_aes.c
+srcs-y += pkcs11_attributes.c
+srcs-y += attributes.c
+srcs-y += processing_symm.c
+srcs-y += processing_ec.c
+srcs-y += processing_rsa.c
+srcs-y += processing_asymm.c
diff --git a/ta/secure_key_services/src/user_ta_header_defines.h b/ta/secure_key_services/src/user_ta_header_defines.h
new file mode 100644
index 00000000..1d33a3ed
--- /dev/null
+++ b/ta/secure_key_services/src/user_ta_header_defines.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2017-2018, Linaro Limited
+ */
+
+#ifndef USER_TA_HEADER_DEFINES_H
+#define USER_TA_HEADER_DEFINES_H
+
+#include <sks_ta.h>
+
+#define TA_UUID				TA_SKS_UUID
+
+#define TA_FLAGS			(TA_FLAG_SINGLE_INSTANCE | \
+						TA_FLAG_MULTI_SESSION | \
+						TA_FLAG_EXEC_DDR | \
+						TA_FLAG_INSTANCE_KEEP_ALIVE)
+
+#define TA_STACK_SIZE			(2 * 1024)
+#define TA_DATA_SIZE			(16 * 1024)
+
+#define TA_CURRENT_TA_EXT_PROPERTIES \
+    { "gp.ta.description", USER_TA_PROP_TYPE_STRING, \
+        "Secure key services trusted application" }, \
+    { "gp.ta.version", USER_TA_PROP_TYPE_U32, &(const uint32_t){ 0x0000 } }
+
+#endif /*USER_TA_HEADER_DEFINES_H*/
diff --git a/ta/secure_key_services/sub.mk b/ta/secure_key_services/sub.mk
new file mode 100644
index 00000000..b927f9b3
--- /dev/null
+++ b/ta/secure_key_services/sub.mk
@@ -0,0 +1,6 @@
+global-incdirs-y += include
+global-incdirs-y += src
+subdirs-y += src
+
+CFG_SKS_TA_TOKEN_COUNT ?= 3
+CPPFLAGS += -DCFG_SKS_TA_TOKEN_COUNT=$(CFG_SKS_TA_TOKEN_COUNT)
diff --git a/ta/secure_key_services/user_ta.mk b/ta/secure_key_services/user_ta.mk
new file mode 100644
index 00000000..f3ada688
--- /dev/null
+++ b/ta/secure_key_services/user_ta.mk
@@ -0,0 +1 @@
+user-ta-uuid := fd02c9da-306c-48c7-a49c-bbd827ae86ee
